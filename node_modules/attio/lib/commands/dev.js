import chalk from "chalk";
import { Command, Option } from "commander";
import notifier from "node-notifier";
import { z } from "zod";
import { isErrored } from "@attio/fetchable-npm";
import { authenticator } from "../auth/auth.js";
import { HIDDEN_ATTIO_DIRECTORY } from "../constants/hidden-attio-directory.js";
import { printUploadError } from "../print-errors.js";
import { addAttioHiddenDirectoryToTsConfig } from "../util/add-attio-hidden-directory-to-ts-config.js";
import { ensureAppEntryPoint } from "../util/ensure-app-entry-point.js";
import { generateGitignore } from "../util/generate-gitignore.js";
import { generateSettingsTypes } from "../util/generate-settings-types.js";
import { hardExit } from "../util/hard-exit.js";
import { printMessage } from "../util/print-message.js";
import { printJsError, printTsError } from "../util/typescript.js";
import { boot } from "./dev/boot.js";
import { bundleJavaScript } from "./dev/bundle-javascript.js";
import { watchGraphqlCodegen } from "./dev/graphql-code-gen.js";
import { graphqlServer } from "./dev/graphql-server.js";
import { onboarding } from "./dev/onboarding.js";
import { printBuildContextError } from "./dev/prepare-build-context.js";
import { upload } from "./dev/upload.js";
import { validateTypeScript } from "./dev/validate-typescript.js";
const notifyTsErrors = (errors) => {
    try {
        notifier.notify({
            title: `TypeScript Error${errors.length === 1 ? "" : "s"}`,
            message: `There ${errors.length === 1 ? "was one error" : `were ${errors.length} errors`} in your TypeScript code`,
        });
    }
    catch {
    }
};
const notifyJsErrors = (errors) => {
    const totalErrors = (errors.errors?.length || 0) + (errors.warnings?.length || 0);
    try {
        notifier.notify({
            title: `JavaScript ${totalErrors === 1 ? "Error" : "Errors"}`,
            message: `There ${totalErrors === 1 ? "was one error" : `were ${totalErrors} errors`} in your JavaScript code`,
        });
    }
    catch {
    }
};
export const optionsSchema = z.object({
    workspace: z.string().optional(),
});
export const dev = new Command("dev")
    .description("Develop your Attio app")
    .addOption(new Option("-w, --workspace <slug>", "The slug of the workspace to use"))
    .action(async (unparsedOptions) => {
    const { workspace: workspaceSlug } = optionsSchema.parse(unparsedOptions);
    const cleanupFunctions = [];
    let isCleaningUp = false;
    const appEntryPointResult = await ensureAppEntryPoint(true);
    if (isErrored(appEntryPointResult)) {
        switch (appEntryPointResult.error.code) {
            case "APP_ENTRY_POINT_NOT_FOUND":
                hardExit("Could not find app.ts");
            case "FAILED_TO_GENERATE_ENTRY_POINT":
                hardExit("Failed to generate app.ts");
        }
    }
    await generateGitignore();
    const updateTsconfigResult = await addAttioHiddenDirectoryToTsConfig();
    if (isErrored(updateTsconfigResult)) {
        switch (updateTsconfigResult.error.code) {
            case "TS_CONFIG_NOT_FOUND":
            case "FAILED_TO_READ_TSCONFIG":
            case "FAILED_TO_PARSE_TSCONFIG":
            case "FAILED_TO_WRITE_TSCONFIG":
                process.stderr.write(chalk.yellow(`Failed to update tsconfig. Make sure the "include" field contains the ${HIDDEN_ATTIO_DIRECTORY} directory \n`));
                break;
            default:
                throw new Error(updateTsconfigResult.error);
        }
    }
    const generateSettingsTypesResult = await generateSettingsTypes();
    if (isErrored(generateSettingsTypesResult)) {
        hardExit("Failed to generate settings types");
    }
    await authenticator.ensureAuthed();
    const cleanup = async () => {
        if (isCleaningUp)
            return;
        isCleaningUp = true;
        try {
            for (const cleanup of cleanupFunctions.reverse()) {
                try {
                    await Promise.race([
                        cleanup(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error("Cleanup timeout")), 2000)),
                    ]);
                }
                catch (error) {
                    process.stderr.write(chalk.yellow(`Warning during cleanup: ${error}\n`));
                }
            }
        }
        catch (error) {
            process.stderr.write(chalk.red(`Error during cleanup: ${error}\n`));
        }
    };
    try {
        const { appId, appSlug, workspace, devVersionId } = await boot({ workspaceSlug });
        const cleanupGraphqlServer = graphqlServer();
        cleanupFunctions.push(cleanupGraphqlServer);
        const cleanupOnboardingDaemon = onboarding({ appId, appSlug, workspace });
        cleanupFunctions.push(cleanupOnboardingDaemon);
        let haveTsErrors = false;
        const [cleanupTs, triggerTs] = validateTypeScript(() => {
            if (haveTsErrors) {
                process.stdout.write(`${chalk.green("âœ“")} TypeScript errors fixed\n`);
                haveTsErrors = false;
            }
        }, (errors) => {
            haveTsErrors = true;
            errors.forEach(printTsError);
            notifyTsErrors(errors);
        });
        cleanupFunctions.push(cleanupTs);
        let hasGraphqlCodeGenError = false;
        const cleanupGraphqlCodeGen = watchGraphqlCodegen(() => {
            if (hasGraphqlCodeGenError) {
                process.stdout.write(`${chalk.green("âœ“")} GraphQL errors fixed\n`);
                hasGraphqlCodeGenError = false;
            }
            triggerTs();
        }, (error) => {
            hasGraphqlCodeGenError = true;
            process.stderr.write(error);
        });
        cleanupFunctions.push(cleanupGraphqlCodeGen);
        let haveBundlingErrors = false;
        const cleanupJs = bundleJavaScript(async (contents) => {
            if (haveBundlingErrors) {
                process.stdout.write(`${chalk.green("âœ“")} Bundling errors fixed\n`);
                haveBundlingErrors = false;
            }
            const uploadResult = await upload({ contents, devVersionId, appId });
            if (isErrored(uploadResult)) {
                printUploadError(uploadResult.error);
            }
        }, async (error) => {
            haveBundlingErrors = true;
            if (error.code === "BUILD_JAVASCRIPT_ERROR") {
                notifyJsErrors(error);
                const { errors, warnings } = error;
                errors?.forEach((error) => printJsError(error, "error"));
                warnings?.forEach((warning) => printJsError(warning, "warning"));
            }
            else {
                printBuildContextError(error);
            }
        });
        cleanupFunctions.push(cleanupJs);
        printMessage("\nðŸ‘€ Watching for changes...");
        process.on("SIGINT", async () => {
            await cleanup();
            process.exit(0);
        });
        process.on("SIGTERM", async () => {
            await cleanup();
            process.exit(0);
        });
        process.on("uncaughtException", async (error) => {
            process.stderr.write(chalk.red(`Uncaught exception: ${error}\n`));
            await cleanup();
            process.exit(1);
        });
        process.on("unhandledRejection", async (error) => {
            process.stderr.write(chalk.red(`Unhandled rejection: ${error}\n`));
            await cleanup();
            process.exit(1);
        });
        await new Promise(() => {
        });
    }
    catch (error) {
        process.stderr.write(chalk.red(`âœ– ${error}\n`));
        await cleanup();
        process.exit(1);
    }
});
