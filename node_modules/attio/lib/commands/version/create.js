import chalk from "chalk";
import { Command } from "commander";
import { combineAsync, isErrored } from "@attio/fetchable-npm";
import { api } from "../../api/api.js";
import { authenticator } from "../../auth/auth.js";
import { printCliVersionError, printFetcherError, printPackageJsonError } from "../../print-errors.js";
import { getAppInfo } from "../../spinners/get-app-info.spinner.js";
import { getAppSlugFromPackageJson } from "../../spinners/get-app-slug-from-package-json.js";
import { getVersions } from "../../spinners/get-versions.spinner.js";
import { ensureAppEntryPoint } from "../../util/ensure-app-entry-point.js";
import { exitWithMissingEntryPoint } from "../../util/exit-with-missing-entry-point.js";
import { loadAttioCliVersion } from "../../util/load-attio-cli-version.js";
import { spinnerify } from "../../util/spinner.js";
import { printJsError } from "../../util/typescript.js";
import { uploadBundle } from "../../util/upload-bundle.js";
import { printBuildContextError } from "../dev/prepare-build-context.js";
import { bundleJavaScript } from "./create/bundle-javascript.js";
export const versionCreate = new Command("create")
    .description("Create a new unpublished version of your Attio app")
    .action(async () => {
    const appEntryPointResult = await ensureAppEntryPoint();
    if (isErrored(appEntryPointResult)) {
        exitWithMissingEntryPoint();
    }
    await authenticator.ensureAuthed();
    const appSlugResult = await getAppSlugFromPackageJson();
    if (isErrored(appSlugResult)) {
        printPackageJsonError(appSlugResult.error);
        process.exit(1);
    }
    const appSlug = appSlugResult.value;
    const appInfoResult = await getAppInfo(appSlug);
    if (isErrored(appInfoResult)) {
        printFetcherError("Error loading app info", appInfoResult.error);
        process.exit(1);
    }
    const appInfo = appInfoResult.value;
    const bundleResult = await spinnerify("Bundling JavaScript...", "Bundling complete", bundleJavaScript);
    if (isErrored(bundleResult)) {
        if (bundleResult.error.code === "ERROR_BUILDING_BUNDLE") {
            const { error } = bundleResult.error;
            if (error.code === "BUILD_JAVASCRIPT_ERROR") {
                const { errors, warnings } = error;
                errors?.forEach((error) => printJsError(error, "error"));
                warnings?.forEach((warning) => printJsError(warning, "warning"));
            }
            else {
                printBuildContextError(error);
            }
        }
        else {
            printBuildContextError(bundleResult.error.error);
        }
        process.exit(1);
    }
    const [clientBundle, serverBundle] = bundleResult.value;
    const versionsResult = await getVersions(appInfo);
    if (isErrored(versionsResult)) {
        printFetcherError("Error fetching versions", versionsResult.error);
        process.exit(1);
    }
    const versions = versionsResult.value;
    const versionResult = await spinnerify("Uploading...", "Upload complete", async () => {
        const cliVersionResult = loadAttioCliVersion();
        if (isErrored(cliVersionResult)) {
            printCliVersionError(cliVersionResult);
            process.exit(1);
        }
        const cliVersion = cliVersionResult.value;
        const versionResult = await api.createVersion({
            appId: appInfo.app_id,
            major: versions.length === 0
                ? 1
                : Math.max(...versions.map((version) => version.major), 1),
            cliVersion,
        });
        if (isErrored(versionResult)) {
            printFetcherError("Error creating version", versionResult.error);
            process.exit(1);
        }
        const { client_bundle_upload_url, server_bundle_upload_url } = versionResult.value;
        const uploadResult = await combineAsync([
            uploadBundle(clientBundle, client_bundle_upload_url),
            uploadBundle(serverBundle, server_bundle_upload_url),
        ]);
        if (isErrored(uploadResult)) {
            process.stderr.write(`${chalk.red("✖ ")}Failed to upload bundle to: ${uploadResult.error.upload_url}\n`);
            process.exit(1);
        }
        return versionResult;
    });
    if (isErrored(versionResult)) {
        process.stderr.write(`${chalk.red("✖ ")}Failed to create version: ${versionResult.error}\n`);
        process.exit(1);
    }
    const version = versionResult.value;
    const signingResult = await spinnerify("Signing bundles...", "Bundles signed", async () => await api.completeProdBundleUpload({
        appId: appInfo.app_id,
        major: version.major,
        minor: version.minor,
        bundleId: version.app_prod_version_bundle_id,
    }));
    if (isErrored(signingResult)) {
        printFetcherError("Error signing bundles", signingResult.error);
        process.exit(1);
    }
    process.stdout.write(`\nVersion ${chalk.green(`${version.major}.${version.minor}`)} created!\n\n`);
    process.exit(0);
});
