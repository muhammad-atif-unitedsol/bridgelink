import readline from "node:readline/promises";
import chalk from "chalk";
import { Command, Option } from "commander";
import { z } from "zod";
import { isErrored } from "@attio/fetchable-npm";
import { authenticator } from "../auth/auth.js";
import { printDetermineWorkspaceError, printFetcherError, printLogSubscriptionError, printPackageJsonError, } from "../print-errors.js";
import { determineWorkspace } from "../spinners/determine-workspace.spinner.js";
import { getAppInfo } from "../spinners/get-app-info.spinner.js";
import { getAppSlugFromPackageJson } from "../spinners/get-app-slug-from-package-json.js";
import { spinnerify } from "../util/spinner.js";
import { subscribeToLogs } from "./log/subscribe-to-logs.js";
export const optionsSchema = z.object({
    workspace: z.string().optional(),
});
export const logs = new Command("logs")
    .description("Stream development server logs")
    .addOption(new Option("-w, --workspace <slug>", "The slug of the workspace to get the logs from"))
    .action(async (unparsedOptions) => {
    const { workspace: workspaceSlug } = optionsSchema.parse(unparsedOptions);
    await authenticator.ensureAuthed();
    const appSlugResult = await getAppSlugFromPackageJson();
    if (isErrored(appSlugResult)) {
        printPackageJsonError(appSlugResult.error);
        process.exit(1);
    }
    const appSlug = appSlugResult.value;
    const appInfoResult = await getAppInfo(appSlug);
    if (isErrored(appInfoResult)) {
        printFetcherError("Error loading app info", appInfoResult.error);
        process.exit(1);
    }
    const appInfo = appInfoResult.value;
    const workspaceResult = await determineWorkspace(workspaceSlug);
    if (isErrored(workspaceResult)) {
        printDetermineWorkspaceError(workspaceResult.error);
        process.exit(1);
    }
    const workspace = workspaceResult.value;
    const readlineInterface = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    const waitForEnter = async (prompt = "Press Enter to resume...") => {
        await readlineInterface.question(prompt);
    };
    const subscriptionResult = await spinnerify("Connecting to log server...", "Connected to log server", async () => {
        return subscribeToLogs({ workspaceId: workspace.workspace_id, appId: appInfo.app_id }, ({ message, severity, timestamp }) => {
            let coloredSeverity;
            switch (severity) {
                case "INFO":
                    coloredSeverity = chalk.blue(severity);
                    break;
                case "ERROR":
                    coloredSeverity = chalk.red(severity);
                    break;
                case "WARNING":
                    coloredSeverity = chalk.yellow(severity);
                    break;
                default:
                    coloredSeverity = severity;
            }
            const logLine = `${timestamp} ${coloredSeverity}: ${message.trim()}`;
            process.stdout.write(`\n${logLine}`);
        }, async ({ close, reconnect }) => {
            await close();
            await waitForEnter("The connection to the logs server was closed. Press Enter to reconnect...");
            const reconnectResult = await spinnerify("Connecting to log server...", "Connected to log server", () => reconnect());
            if (isErrored(reconnectResult)) {
                printLogSubscriptionError(reconnectResult.error);
                process.exit(2);
            }
        });
    }).finally(() => {
        readlineInterface.close();
    });
    if (isErrored(subscriptionResult)) {
        printLogSubscriptionError(subscriptionResult.error);
        process.exit(2);
    }
    let isShuttingDown = false;
    const shutdown = async (exitCode = 0) => {
        if (isShuttingDown) {
            return;
        }
        isShuttingDown = true;
        try {
            await subscriptionResult.value.unsubscribe();
        }
        catch {
            exitCode = Math.min(exitCode, 1);
        }
        finally {
            process.exit(exitCode);
        }
    };
    ["SIGINT", "SIGTERM"].forEach((signal) => process.on(signal, async () => shutdown(0)));
    process.on("beforeExit", async (exitCode) => {
        await shutdown(exitCode);
    });
    process.on("uncaughtException", async (error) => {
        process.stderr.write(chalk.red(`Uncaught exception: ${error}\n`));
        await shutdown(1);
    });
    process.on("unhandledRejection", async (error) => {
        process.stderr.write(chalk.red(`Unhandled rejection: ${error}\n`));
        await shutdown(1);
    });
    await new Promise(() => {
    });
});
