import fs from "fs/promises";
import path from "path";
import * as esbuild from "esbuild";
import tmp from "tmp-promise";
import { complete, errored, isErrored } from "@attio/fetchable-npm";
import { createServerBuildConfig } from "../../build/server/create-server-build-config.js";
import { generateServerEntry } from "../../build/server/generate-server-entry.js";
import { errorsAndWarningsSchema } from "../../build.js";
export class ServerBuilder {
    _lastJs;
    _esbuildContext;
    _tempFile;
    _directories;
    constructor({ esbuildContext, tempFile, directories, }) {
        this._esbuildContext = esbuildContext;
        this._tempFile = tempFile;
        this._directories = directories;
    }
    static async create({ outfile, directories, mode, }) {
        try {
            const tempFile = await tmp.file({ postfix: ".js" });
            const esbuildContext = await esbuild.context({
                ...createServerBuildConfig(tempFile.path),
                write: mode === "write-to-disk",
                outfile,
            });
            return complete(new ServerBuilder({ esbuildContext, tempFile, directories }));
        }
        catch (error) {
            return errored({
                code: "FAILED_TO_CREATE_ESBUILD_CONTEXT",
                outfile,
                error,
            });
        }
    }
    async rebuild({ workflowBlockModules, }) {
        const jsResult = await generateServerEntry({
            appDirAbsolute: path.resolve(this._directories.app),
            srcDirAbsolute: path.resolve(this._directories.src),
            webhooksDirAbsolute: path.resolve(this._directories.webhooks),
            eventDirAbsolute: path.resolve(this._directories.events),
            workflowBlockModules,
        });
        if (isErrored(jsResult)) {
            return jsResult;
        }
        const js = jsResult.value;
        if (js !== this._lastJs) {
            try {
                await fs.writeFile(this._tempFile.path, js);
                this._lastJs = js;
            }
            catch (error) {
                return errored({
                    code: "FAILED_TO_CREATE_TEMP_FILE",
                    path: this._tempFile.path,
                    error,
                });
            }
        }
        try {
            return complete(await this._esbuildContext.rebuild());
        }
        catch (error) {
            const parseResult = errorsAndWarningsSchema.safeParse(error);
            if (!parseResult.success) {
                return errored({
                    code: "UNPARSABLE_BUILD_ERROR",
                    error,
                });
            }
            return errored({
                code: "BUILD_JAVASCRIPT_ERROR",
                errors: parseResult.data.errors ?? [],
                warnings: parseResult.data.warnings ?? [],
            });
        }
    }
    async dispose(timeoutMs) {
        try {
            await Promise.race([
                Promise.all([this._esbuildContext.dispose(), this._tempFile.cleanup()]),
                new Promise((_, reject) => setTimeout(() => reject(new Error("Context disposal timeout")), timeoutMs)),
            ]);
        }
        catch (error) {
            return errored({
                code: "FAILED_TO_DISPOSE_OF_BUILD_CONTEXT",
                error,
            });
        }
        return complete(undefined);
    }
}
