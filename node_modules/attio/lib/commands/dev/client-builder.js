import fs from "fs/promises";
import path from "path";
import * as esbuild from "esbuild";
import tmp from "tmp-promise";
import { complete, errored, isErrored } from "@attio/fetchable-npm";
import { createClientBuildConfig } from "../../build/client/create-client-build-config.js";
import { generateClientEntry } from "../../build/client/generate-client-entry.js";
import { errorsAndWarningsSchema } from "../../build.js";
export class ClientBuilder {
    _lastJs;
    _esbuildContext;
    _tempFile;
    _directories;
    _workflowBlockModulesRef;
    constructor({ tempFile, directories, workflowBlockModulesRef, esbuildContext, }) {
        this._esbuildContext = esbuildContext;
        this._tempFile = tempFile;
        this._workflowBlockModulesRef = workflowBlockModulesRef;
        this._directories = directories;
    }
    static async create({ outfile, directories, mode, }) {
        try {
            const workflowBlockModulesRef = { current: new Map() };
            const tempFile = await tmp.file({ postfix: ".js" });
            const esbuildContext = await esbuild.context({
                ...createClientBuildConfig({
                    appDir: directories.app,
                    entryPoint: tempFile.path,
                    srcDir: directories.src,
                    workflowBlockModulesRef,
                }),
                write: mode === "write-to-disk",
                outfile,
                loader: { ".png": "dataurl", ".graphql": "text", ".gql": "text" },
            });
            return complete(new ClientBuilder({ esbuildContext, tempFile, workflowBlockModulesRef, directories }));
        }
        catch (error) {
            return errored({
                code: "FAILED_TO_CREATE_ESBUILD_CONTEXT",
                outfile,
                error,
            });
        }
    }
    async rebuild({ workflowBlockModules, }) {
        this._workflowBlockModulesRef.current = workflowBlockModules;
        const jsResult = await generateClientEntry({
            srcDirAbsolute: path.resolve(this._directories.src),
            assetsDirAbsolute: path.resolve(this._directories.assets),
        });
        if (isErrored(jsResult)) {
            return jsResult;
        }
        const js = jsResult.value;
        if (js !== this._lastJs) {
            try {
                await fs.writeFile(this._tempFile.path, js);
                this._lastJs = js;
            }
            catch (error) {
                return errored({
                    code: "FAILED_TO_CREATE_TEMP_FILE",
                    path: this._tempFile.path,
                    error,
                });
            }
        }
        try {
            return complete(await this._esbuildContext.rebuild());
        }
        catch (error) {
            const parseResult = errorsAndWarningsSchema.safeParse(error);
            if (!parseResult.success) {
                return errored({
                    code: "UNPARSABLE_BUILD_ERROR",
                    error,
                });
            }
            return errored({
                code: "BUILD_JAVASCRIPT_ERROR",
                errors: parseResult.data.errors ?? [],
                warnings: parseResult.data.warnings ?? [],
            });
        }
    }
    async dispose(timeoutMs) {
        try {
            await Promise.race([
                Promise.all([this._esbuildContext.dispose(), this._tempFile.cleanup()]),
                new Promise((_, reject) => setTimeout(() => reject(new Error("Context disposal timeout")), timeoutMs)),
            ]);
        }
        catch (error) {
            return errored({
                code: "FAILED_TO_DISPOSE_OF_BUILD_CONTEXT",
                error,
            });
        }
        return complete(undefined);
    }
}
