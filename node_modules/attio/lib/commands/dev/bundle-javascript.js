import chokidar from "chokidar";
import { complete, isErrored } from "@attio/fetchable-npm";
import { prepareBuildContext } from "./prepare-build-context.js";
export function bundleJavaScript(onSuccess, onError) {
    const watcher = chokidar.watch(["./src/**/*.{js,jsx,ts,tsx}"], {
        ignored: ["**/node_modules/**", "**/dist/**", "**/*.graphql.d.ts", "**/*.gql.d.ts"],
        cwd: process.cwd(),
    });
    let buildContext;
    let isBuilding = false;
    let buildQueued = false;
    let isDisposing = false;
    async function handleBuild() {
        if (isBuilding || isDisposing) {
            buildQueued = true;
            return complete(undefined);
        }
        isBuilding = true;
        try {
            if (!buildContext) {
                const buildContextResult = await prepareBuildContext("in-memory");
                if (isErrored(buildContextResult)) {
                    return buildContextResult;
                }
                buildContext = buildContextResult.value;
            }
            const bundleResults = await buildContext.rebuild();
            if (isErrored(bundleResults)) {
                return bundleResults;
            }
            const results = bundleResults.value;
            await onSuccess?.([
                results.client.outputFiles[0].text,
                results.server.outputFiles[0].text,
            ]);
            isBuilding = false;
            if (buildQueued && !isDisposing) {
                buildQueued = false;
                return await handleBuild();
            }
            return complete(undefined);
        }
        finally {
            isBuilding = false;
        }
    }
    watcher.on("ready", async () => {
        const result = await handleBuild();
        if (isErrored(result)) {
            onError?.(result.error);
        }
        watcher.on("all", async (event) => {
            if (event === "add" || event === "change" || event === "unlink") {
                const result = await handleBuild();
                if (isErrored(result)) {
                    onError?.(result.error);
                }
            }
        });
    });
    return async () => {
        isDisposing = true;
        if (isBuilding) {
            await new Promise((resolve) => {
                const checkBuild = setInterval(() => {
                    if (!isBuilding) {
                        clearInterval(checkBuild);
                        resolve(undefined);
                    }
                }, 10);
            });
        }
        await watcher.close();
        if (buildContext) {
            const result = await buildContext.dispose(1_000);
            if (isErrored(result)) {
                process.stderr.write(`Error disposing build context: ${result.error}\n`);
            }
            buildContext = undefined;
        }
    };
}
