export class LogsBuffer {
    bufferDelayMs;
    buffer = [];
    listeners = [];
    flushInterval;
    constructor(bufferDelayMs) {
        this.bufferDelayMs = bufferDelayMs;
        this.flushInterval = setInterval(() => {
            this.flush();
        }, bufferDelayMs / 5);
    }
    close() {
        if (this.flushInterval) {
            clearInterval(this.flushInterval);
        }
        this.flushInterval = null;
    }
    listen(listener) {
        this.assertNotClosed();
        this.listeners.push(listener);
    }
    add(event) {
        this.assertNotClosed();
        const receivedAt = Date.now();
        const insertIndex = this.buffer.findIndex((bufferItem) => event.timestamp > bufferItem.event.timestamp);
        if (insertIndex >= 0) {
            this.buffer.splice(insertIndex, 0, { event, receivedAt });
        }
        else {
            this.buffer.push({ event, receivedAt });
        }
    }
    flush() {
        const now = Date.now();
        const firstFlushIndex = this.buffer.findIndex((bufferItem) => now - bufferItem.receivedAt > this.bufferDelayMs);
        if (firstFlushIndex === -1) {
            return;
        }
        const eventsToFlush = this.buffer
            .splice(firstFlushIndex, this.buffer.length - firstFlushIndex)
            .reverse()
            .map(({ event }) => event);
        for (const listener of this.listeners) {
            listener(eventsToFlush);
        }
    }
    assertNotClosed() {
        if (this.flushInterval === null) {
            throw new Error("This buffer was closed");
        }
    }
}
