import { z } from "zod";
import { complete, errored, isErrored } from "@attio/fetchable-npm";
import { authenticator } from "../auth/auth.js";
import { API } from "../env.js";
const apiErrorResponseSchema = z.object({
    message: z.string(),
});
export class Fetcher {
    async _fetch({ path, fetchOptions, schema, authenticated, }) {
        const tokenResult = authenticated === "Authenticated" ? await authenticator.ensureAuthed() : complete(null);
        if (isErrored(tokenResult)) {
            return errored({
                code: "UNAUTHORIZED",
                error: tokenResult.error,
            });
        }
        const token = tokenResult.value;
        try {
            const response = await fetch(path.startsWith("https") ? path : `${API}${path}`, {
                ...fetchOptions,
                headers: {
                    "x-attio-platform": "developer-cli",
                    ...(token ? { Authorization: `Bearer ${token}` } : {}),
                    "Content-Type": "application/json",
                    ...fetchOptions.headers,
                },
            });
            if (!response.ok) {
                const message = this._parseErrorResponseMessage(await response.text());
                return errored({
                    code: "HTTP_ERROR",
                    status: response.status,
                    message,
                });
            }
            const data = await response.json();
            const result = schema.safeParse(data);
            if (!result.success) {
                return errored({
                    code: "INVALID_RESPONSE",
                    message: result.error.message,
                });
            }
            return complete(result.data);
        }
        catch (error) {
            return errored({
                code: "NETWORK_ERROR",
                message: error instanceof Error ? error.message : String(error),
            });
        }
    }
    _parseErrorResponseMessage(responseText) {
        try {
            const parsedResponseText = apiErrorResponseSchema.parse(JSON.parse(responseText));
            return parsedResponseText.message;
        }
        catch {
            return responseText;
        }
    }
    async get({ path, schema, headers = {}, authenticated = "Authenticated", }) {
        return this._fetch({ path, fetchOptions: { method: "GET", headers }, schema, authenticated });
    }
    async post({ path, body, schema, headers = {}, authenticated = "Authenticated", }) {
        return this._fetch({
            path,
            fetchOptions: {
                method: "POST",
                body: body instanceof URLSearchParams ? body.toString() : JSON.stringify(body),
                headers: {
                    "Content-Type": body instanceof URLSearchParams
                        ? "application/x-www-form-urlencoded"
                        : "application/json",
                    ...headers,
                },
            },
            schema,
            authenticated,
        });
    }
}
