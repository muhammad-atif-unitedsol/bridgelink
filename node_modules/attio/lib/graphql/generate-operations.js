import { codegen } from "@graphql-codegen/core";
import * as typescriptOpsPlugin from "@graphql-codegen/typescript-operations";
import fs from "fs";
import { parse, isExecutableDefinitionNode, Kind, OperationTypeNode } from "graphql";
import path from "path";
import { format } from "prettier";
import { getLineAndColumn, GraphQLError } from "./graphql-error.js";
function findGraphQLFiles(dir) {
    const files = [];
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory() && entry.name === "node_modules") {
            continue;
        }
        if (entry.isDirectory()) {
            files.push(...findGraphQLFiles(fullPath));
        }
        else if (entry.isFile() &&
            (path.extname(entry.name) === ".graphql" || path.extname(entry.name) === ".gql")) {
            files.push(fullPath);
        }
    }
    return files;
}
function findGeneratedFiles(dir) {
    const files = [];
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
            files.push(...findGeneratedFiles(fullPath));
        }
        else if (entry.isFile() && path.extname(entry.name) === ".graphql.d.ts") {
            files.push(fullPath);
        }
    }
    return files;
}
function repairTypeScriptOutput(output) {
    return output.replace(/__typename\?: '[^']+',\s*/g, "");
}
export async function generateOperationFromQuery(fullGraphqlFileName, query, schema) {
    let parsedQuery = {};
    try {
        parsedQuery = parse(query);
    }
    catch (error) {
        if (error.message.startsWith("Syntax Error: Unexpected Name")) {
            throw new GraphQLError(error.message, error.locations, query, fullGraphqlFileName);
        }
    }
    parsedQuery.definitions?.forEach((def) => {
        if (def && def.kind === Kind.OPERATION_DEFINITION) {
            const location = def.loc;
            if (!location) {
                throw new Error("Expected a location");
            }
            switch (def.operation) {
                case OperationTypeNode.MUTATION:
                    throw new GraphQLError(`Mutations are not supported`, [getLineAndColumn(query, location)], query, fullGraphqlFileName);
                case OperationTypeNode.SUBSCRIPTION:
                    throw new GraphQLError(`Subscriptions are not supported`, [getLineAndColumn(query, location)], query, fullGraphqlFileName);
                case OperationTypeNode.QUERY:
                    break;
                default:
                    return def.operation;
            }
        }
    });
    const queries = parsedQuery.definitions?.filter((def) => def &&
        def.kind === Kind.OPERATION_DEFINITION &&
        isExecutableDefinitionNode(def) &&
        def.operation === OperationTypeNode.QUERY) ?? [];
    if (queries.length > 1) {
        const location = queries[1]?.loc;
        if (!location) {
            throw new Error("Expected a location");
        }
        throw new GraphQLError(`Only one query is allowed per .graphql file`, [getLineAndColumn(query, location)], query, fullGraphqlFileName);
    }
    if (!queries.length) {
        throw new GraphQLError(`No query found.`, [{ line: 1, column: 1 }], query, fullGraphqlFileName);
    }
    const def = queries[0];
    switch (def.kind) {
        case Kind.OPERATION_DEFINITION:
            const name = (isExecutableDefinitionNode(def) && def.kind === Kind.OPERATION_DEFINITION
                ? def.name?.value
                : undefined) ?? "";
            const capitalizedName = name
                ? name.charAt(0).toUpperCase() + name.slice(1)
                : "Unnamed_1_";
            let code = "";
            try {
                code = await codegen({
                    documents: [{ document: parsedQuery }],
                    config: {},
                    filename: "relative/pathTo/filename.ts",
                    schema,
                    plugins: [
                        {
                            "typescript-operations": {
                                avoidOptionals: true,
                                enumsAsTypes: true,
                            },
                        },
                    ],
                    pluginMap: {
                        "typescript-operations": typescriptOpsPlugin,
                    },
                });
            }
            catch (error) {
                if (error.message.startsWith("GraphQL Document Validation failed with")) {
                    const errorMatch = error.message.match(/Error 0: (.+)\n\s+at GraphQL request:(\d+):(\d+)/);
                    if (errorMatch) {
                        const [, errorMessage, line, column] = errorMatch;
                        throw new GraphQLError(errorMessage, [{ line: parseInt(line), column: parseInt(column) }], query, fullGraphqlFileName);
                    }
                }
                if (error.message.startsWith("Unable to find root schema type for")) {
                    throw new GraphQLError(error.message, [{ line: 1, column: 1 }], query, fullGraphqlFileName);
                }
                throw error;
            }
            return format(`
    declare module "./${path.basename(fullGraphqlFileName)}" {
    ${repairTypeScriptOutput(code)}
  const value: Query<${capitalizedName}QueryVariables, ${capitalizedName}Query>
  export default value
}
    `, { parser: "typescript" });
        case Kind.FRAGMENT_DEFINITION:
        case Kind.SCHEMA_DEFINITION:
        case Kind.SCALAR_TYPE_DEFINITION:
        case Kind.OBJECT_TYPE_DEFINITION:
        case Kind.INTERFACE_TYPE_DEFINITION:
        case Kind.UNION_TYPE_DEFINITION:
        case Kind.ENUM_TYPE_DEFINITION:
        case Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case Kind.DIRECTIVE_DEFINITION:
        case Kind.SCHEMA_EXTENSION:
        case Kind.SCALAR_TYPE_EXTENSION:
        case Kind.OBJECT_TYPE_EXTENSION:
        case Kind.INTERFACE_TYPE_EXTENSION:
        case Kind.UNION_TYPE_EXTENSION:
        case Kind.ENUM_TYPE_EXTENSION:
        case Kind.INPUT_OBJECT_TYPE_EXTENSION:
            const location = def.loc;
            if (!location) {
                throw new Error("Expected a location");
            }
            throw new GraphQLError(`File should contain only a single query`, [getLineAndColumn(query, location)], query, fullGraphqlFileName);
        default:
            return def;
    }
}
export async function generateOperations(rootDir, schema) {
    await Promise.all(findGeneratedFiles(rootDir).map(async (file) => fs.promises.unlink(file)));
    const graphqlFiles = findGraphQLFiles(rootDir);
    await Promise.all(graphqlFiles.map(async (file) => {
        const query = fs.readFileSync(file, "utf-8");
        const operation = await generateOperationFromQuery(file, query, schema);
        const formattedOperation = await format(`/**
 * ****************************************************
 * THIS FILE IS AUTO-GENERATED AT DEVELOPMENT TIME.
 *
 * DO NOT EDIT DIRECTLY OR COMMIT IT TO SOURCE CONTROL.
 * ****************************************************
 */
import {Query} from "attio/client"

type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };

type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
};

${operation}
`, { parser: "typescript" });
        await fs.promises.writeFile(`${file}.d.ts`, formattedOperation);
    }));
}
