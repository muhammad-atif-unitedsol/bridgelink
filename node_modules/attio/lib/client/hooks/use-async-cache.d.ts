/**
 * An async function that returns data.
 */
export type AsyncFunction<Input extends Array<any>, Output> = (...args: Input) => Promise<Output>;
/**
 * A type-safe configuration object for multiple loaders.
 *
 * The key is used to cache the result of the loader.
 * The value is a loader that takes an array of arguments and returns a promise.
 */
export interface AsyncCacheConfig {
    [K: string]: AsyncFunction<Array<any>, any> | [AsyncFunction<Array<any>, any>, ...Array<any>];
}
/**
 * A hook that returns, and caches, the results of calling one or more async functions,
 * typically to load data from a third party via server functions.
 *
 * The component it is used in will suspend until ALL async functions have resolved.
 *
 * @example
 *
 * // load-widgets.server.ts
 * export default async function loadWidgets() : Promise<Array<Widget>> {
 *   // fetch widgets from somewhere
 * }

 * // load-sprockets.server.ts
 * export default async function loadSprockets(
 *   material: Material,
 *   max?: number
 * ): Promise<Array<Sprocket>> {
 *   // fetch sprockets from somewhere
 * }
 *
 * // component.tsx
 * import {useAsyncCache} from "attio/client"
 *
 * import loadWidgets from "./load-widgets.server.ts"
 * import loadSprockets from "./load-sprockets.server.ts"
 *
 * // ...
 *
 * // In component:
 *
 * const results = useAsyncCache({
 *   // `loadWidgets` takes zero parameters and can thus be called without an array
 *   widgets: loadWidgets,
 *   // `loadSprockets` takes a `material` parameter, so we call it like this
 *   ironSprockets: [loadSprockets, "iron"],
 *   copperSprockets: [loadSprockets, "copper", 42],
 * })
 *
 * const {widgets, ironSprockets, copperSprockets} = results.values
 *
 * // ...
 *
 * // Inside an event handler, perhaps, to refetch *only* the iron sprockets
 * results.invalidate("ironSprockets")
 */
export declare function useAsyncCache<Config extends AsyncCacheConfig>(config: Config): {
    values: {
        [K in keyof Config]: Config[K] extends AsyncFunction<any, infer Output> ? Output : Config[K] extends [AsyncFunction<infer Input, infer Output>, ...infer Args] ? Args extends Input ? Output : never : never;
    };
    invalidate: (name: Extract<keyof Config, string>) => void;
};
//# sourceMappingURL=use-async-cache.d.ts.map