import { z } from "zod";
import { complete, errored, isErrored } from "@attio/fetchable-npm";
const authTokenSchema = z.object({
    access_token: z.string(),
    refresh_token: z.string(),
    token_type: z.literal("Bearer"),
    expires_at: z.number(),
});
class KeytarKeychain {
    SERVICE_NAME = "attio-cli";
    ACCOUNT_NAME = "developer";
    keytarPromise;
    constructor() {
        this.keytarPromise = import("keytar").then((module) => module.default);
    }
    async save(token) {
        const keytar = await this.keytarPromise;
        try {
            await keytar.setPassword(this.SERVICE_NAME, this.ACCOUNT_NAME, JSON.stringify(token));
            return complete(undefined);
        }
        catch (error) {
            return errored({
                code: "SAVE_KEYCHAIN_ERROR",
                error,
            });
        }
    }
    async load() {
        const keytar = await this.keytarPromise;
        let unparsedToken = null;
        try {
            unparsedToken = await keytar.getPassword(this.SERVICE_NAME, this.ACCOUNT_NAME);
        }
        catch (error) {
            return errored({ code: "LOAD_KEYCHAIN_ERROR", error });
        }
        if (unparsedToken === null) {
            return complete(null);
        }
        let jsonToken;
        try {
            jsonToken = JSON.parse(unparsedToken);
        }
        catch {
            const deleteResult = await this.delete();
            if (isErrored(deleteResult)) {
                return errored({ code: "LOAD_KEYCHAIN_ERROR", error: deleteResult.error });
            }
            console.debug("Wiped keychain entry due to invalid JSON");
            return complete(null);
        }
        const parsedToken = authTokenSchema.safeParse(jsonToken);
        if (!parsedToken.success) {
            const deleteResult = await this.delete();
            if (isErrored(deleteResult)) {
                return errored({ code: "LOAD_KEYCHAIN_ERROR", error: deleteResult.error });
            }
            console.debug("Wiped keychain entry due to schema mismatch");
            return complete(null);
        }
        if (parsedToken.data.expires_at < Date.now() + 60_000 * 5) {
            const deleteResult = await this.delete();
            if (isErrored(deleteResult)) {
                return errored({ code: "LOAD_KEYCHAIN_ERROR", error: deleteResult.error });
            }
            return complete(null);
        }
        return complete(parsedToken.data);
    }
    async delete() {
        const keytar = await this.keytarPromise;
        try {
            await keytar.deletePassword(this.SERVICE_NAME, this.ACCOUNT_NAME);
            return complete(undefined);
        }
        catch (error) {
            return errored({
                code: "DELETE_KEYCHAIN_ERROR",
                error,
            });
        }
    }
}
class TestKeychain {
    TEST_TOKEN = {
        access_token: "TEST",
        refresh_token: "TEST",
        token_type: "Bearer",
        expires_at: Number.MAX_SAFE_INTEGER,
    };
    async save(_token) {
        return complete(undefined);
    }
    async load() {
        return complete(this.TEST_TOKEN);
    }
    async delete() {
        return complete(undefined);
    }
}
let keychain = null;
export const getKeychain = () => {
    if (keychain === null) {
        keychain = process.env.NODE_ENV === "test" ? new TestKeychain() : new KeytarKeychain();
    }
    return keychain;
};
