import { createHash, randomBytes } from "crypto";
import { serve } from "@hono/node-server";
import { Hono } from "hono";
import open from "open";
import { complete, errored, isErrored } from "@attio/fetchable-npm";
import { api } from "../api/api.js";
import { APP } from "../env.js";
import { printFetcherError, printKeychainError } from "../print-errors.js";
import { findAvailablePort } from "../util/find-available-port.js";
import { getKeychain } from "./keychain.js";
const MAX_TIMEOUT = 2_147_483_647;
class AuthenticatorImpl {
    clientId = "f881c6f1-82d7-48a5-a581-649596167845";
    isRefreshingToken = false;
    refreshTimeout = null;
    async ensureAuthed() {
        const existingTokenResult = await getKeychain().load();
        if (isErrored(existingTokenResult)) {
            return this.promptToAuthenticate();
        }
        const existingToken = existingTokenResult.value;
        if (existingToken === null || existingToken.expires_at < Date.now()) {
            return this.promptToAuthenticate();
        }
        this.scheduleRefresh(existingToken);
        return complete(existingToken.access_token);
    }
    async promptToAuthenticate() {
        if (process.env.NODE_ENV !== "test") {
            process.stdout.write("You need to log in with Attio. Press Enter to continue...\n\n");
            await new Promise((resolve) => process.stdin.once("data", resolve));
        }
        return this.authenticate();
    }
    async authenticate() {
        const existingTokenResult = await getKeychain().load();
        if (isErrored(existingTokenResult)) {
            return existingTokenResult;
        }
        const existingToken = existingTokenResult.value;
        if (existingToken !== null && existingToken.expires_at > Date.now()) {
            return complete(existingToken.access_token);
        }
        const verifier = randomBytes(32);
        const verifierString = verifier.toString("base64url");
        const hash = createHash("sha256");
        hash.update(verifier);
        const challenge = hash.digest();
        const challengeString = challenge.toString("base64url");
        const state = randomBytes(32).toString("base64url");
        const port = await findAvailablePort(3000, 65000);
        const redirectUri = `http://localhost:${port}`;
        let resolveAsyncResult;
        const asyncResult = new Promise((resolve) => {
            resolveAsyncResult = resolve;
        });
        const app = new Hono();
        let serverRef;
        app.get("/", async (c) => {
            const query = c.req.query();
            const receivedCode = query.authorization_code;
            const receivedState = query.state;
            if (receivedState !== state) {
                resolveAsyncResult(errored({ code: "OAUTH_STATE_MISMATCH" }));
            }
            if (!receivedCode) {
                resolveAsyncResult(errored({ code: "NO_AUTHORIZATION_CODE" }));
            }
            const tokenResult = await api.exchangeToken({
                receivedCode,
                verifierString,
                redirectUri,
                clientId: this.clientId,
            });
            setTimeout(() => {
                serverRef.close();
                resolveAsyncResult(tokenResult);
            }, 1_000);
            return c.html(`
        <html>
          <body>
            <script>window.location.href = '${APP}/authorized';</script>
          </body>
        </html>
      `);
        });
        serverRef = serve({
            fetch: app.fetch,
            port,
        });
        try {
            const authUrl = new URL(`${APP}/oidc/authorize`);
            authUrl.searchParams.append("scope", "openid offline_access");
            authUrl.searchParams.append("response_type", "code");
            authUrl.searchParams.append("client_id", this.clientId);
            authUrl.searchParams.append("redirect_uri", redirectUri);
            authUrl.searchParams.append("state", state);
            authUrl.searchParams.append("code_challenge", challengeString);
            authUrl.searchParams.append("code_challenge_method", "S256");
            await open(authUrl.toString());
            const tokenResult = await asyncResult;
            if (isErrored(tokenResult)) {
                return tokenResult;
            }
            const token = tokenResult.value;
            process.stdout.write("ðŸ”‘ Saving new token to keychain\n");
            const keychainToken = {
                access_token: token.access_token,
                refresh_token: token.refresh_token,
                token_type: token.token_type,
                expires_at: Date.now() + token.expires_in * 1000,
            };
            const saveResult = await getKeychain().save(keychainToken);
            if (isErrored(saveResult)) {
                return saveResult;
            }
            this.scheduleRefresh(keychainToken);
            return complete(token.access_token);
        }
        finally {
            serverRef.close();
        }
    }
    scheduleRefresh(token) {
        if (this.refreshTimeout !== null) {
            clearTimeout(this.refreshTimeout);
        }
        const delay = Math.min(Math.max(0, (token.expires_at - Date.now()) / 10), MAX_TIMEOUT);
        this.refreshTimeout = setTimeout(async () => {
            if (this.isRefreshingToken) {
                return;
            }
            this.isRefreshingToken = true;
            try {
                await this.refreshToken(token);
            }
            finally {
                this.isRefreshingToken = false;
                this.refreshTimeout = null;
            }
        }, delay);
    }
    async refreshToken(token) {
        const refreshTokenResult = await api.refreshToken({
            refreshToken: token.refresh_token,
            clientId: this.clientId,
        });
        if (isErrored(refreshTokenResult)) {
            printFetcherError("Error refreshing token", refreshTokenResult.error);
            return;
        }
        const refreshedToken = refreshTokenResult.value;
        const keychainToken = {
            access_token: refreshedToken.access_token,
            refresh_token: refreshedToken.refresh_token,
            token_type: refreshedToken.token_type,
            expires_at: Date.now() + refreshedToken.expires_in * 1000,
        };
        const saveResult = await getKeychain().save(keychainToken);
        if (isErrored(saveResult)) {
            printKeychainError(saveResult.error);
            return;
        }
        this.scheduleRefresh(keychainToken);
    }
    async logout() {
        if (this.refreshTimeout !== null) {
            clearTimeout(this.refreshTimeout);
            this.refreshTimeout = null;
        }
        await getKeychain().delete();
    }
}
export const authenticator = new AuthenticatorImpl();
