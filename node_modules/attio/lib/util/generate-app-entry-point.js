import fs from "fs/promises";
import path from "path";
import { complete, fromPromise, isErrored } from "@attio/fetchable-npm";
import { findSurfaceExports } from "./find-surface-exports/find-surface-exports.js";
import { SURFACE_TYPES } from "./surfaces.js";
import { toCamelCase } from "./to-camel-case.js";
export async function generateAppEntryPoint(srcDirAbsolute) {
    const surfaceExports = await findSurfaceExports(srcDirAbsolute);
    const surfaceImportFilesByType = SURFACE_TYPES.reduce((surfaceExports, surfaceType) => {
        surfaceExports[surfaceType] = [];
        return surfaceExports;
    }, {});
    for (const [filePath, surfaces] of surfaceExports) {
        for (const surface of surfaces) {
            surfaceImportFilesByType[surface.surfaceType].push({
                importPath: getRelativeImportPath(srcDirAbsolute, filePath),
                id: surface.id,
            });
        }
    }
    const appImportStatement = `import type {App} from "attio"\n`;
    const surfaceImportsStatements = SURFACE_TYPES.flatMap((surfaceType) => {
        const surfaceImports = surfaceImportFilesByType[surfaceType];
        return surfaceImports.map((surface) => {
            const surfaceName = getSurfaceImportName(surface.id);
            return `import {${surfaceType}${surfaceName !== surfaceType ? ` as ${surfaceName}` : ""}} from ${JSON.stringify(surface.importPath)}`;
        });
    }).join("\n");
    const getSurfaceNames = (surfaceType) => {
        const surfaceImports = surfaceImportFilesByType[surfaceType];
        return surfaceImports.map((surface) => getSurfaceImportName(surface.id));
    };
    const surfacesByType = SURFACE_TYPES.reduce((acc, surfaceType) => {
        acc[surfaceType] = getSurfaceNames(surfaceType);
        return acc;
    }, {});
    const hasCallRecordingSurfaces = surfacesByType["callRecordingInsightTextSelectionAction"].length > 0 ||
        surfacesByType["callRecordingSummaryTextSelectionAction"].length > 0 ||
        surfacesByType["callRecordingTranscriptTextSelectionAction"].length > 0;
    const appExportStatement = `
export const app: App = {
    record: {
        actions: [${surfacesByType["recordAction"].join(", ")}],
        bulkActions: [${surfacesByType["bulkRecordAction"].join(", ")}],${surfacesByType["recordWidget"].length > 0
        ? `
        widgets: [${surfacesByType["recordWidget"].join(", ")}],`
        : ""}
    },${hasCallRecordingSurfaces
        ? `
    callRecording: {
        insight: {
            textActions: [${surfacesByType["callRecordingInsightTextSelectionAction"].join(", ")}],
        },
        summary: {
            textActions: [${surfacesByType["callRecordingSummaryTextSelectionAction"].join(", ")}],
        },
        transcript: {
            textActions: [${surfacesByType["callRecordingTranscriptTextSelectionAction"].join(", ")}],
        },
    },`
        : ""}
}
`;
    const appEntryPointContent = [
        appImportStatement,
        surfaceImportsStatements,
        appExportStatement,
    ].join("\n");
    const writeResult = await fromPromise(fs.writeFile(path.join(srcDirAbsolute, "app.ts"), appEntryPointContent));
    if (isErrored(writeResult)) {
        return writeResult;
    }
    return complete(true);
}
function getRelativeImportPath(dir, filePath) {
    const relativePath = path
        .relative(dir, filePath)
        .split(path.sep)
        .join("/")
        .replace(/\.[^/.]+$/, "");
    if (relativePath.startsWith(".")) {
        return relativePath;
    }
    return `./${relativePath}`;
}
function getSurfaceImportName(surfaceId) {
    return toCamelCase(surfaceId);
}
