import { SyntaxKind } from "ts-morph";
import { SURFACE_TYPES } from "../surfaces.js";
import { getSurfaceTypeName } from "./surface-types.js";
const isTypeScript = (sourceFile) => {
    const fileName = sourceFile.getBaseName();
    return fileName.endsWith(".ts") || fileName.endsWith(".tsx");
};
export function parseFileExports({ sourceFile, existingExportSymbols, existingIds, typeChecker, surfaceTypes, }) {
    const surfaceExports = new Set();
    const filePath = sourceFile.getFilePath();
    function getOriginalDeclarationSymbol(declaration) {
        const declarationSymbol = declaration.getSymbol();
        const aliasedSymbol = declarationSymbol && typeChecker.getAliasedSymbol(declarationSymbol);
        return aliasedSymbol ?? declarationSymbol;
    }
    const declarationsByName = sourceFile.getExportedDeclarations();
    for (const surfaceType of SURFACE_TYPES) {
        const declarations = declarationsByName.get(surfaceType);
        if (!declarations) {
            continue;
        }
        const declaration = declarations[0];
        const originalSymbol = getOriginalDeclarationSymbol(declaration);
        const isDuplicateDeclaration = !originalSymbol || existingExportSymbols.has(originalSymbol);
        if (isDuplicateDeclaration) {
            continue;
        }
        const exportType = declaration.getType();
        if (isTypeScript(sourceFile) &&
            !typeChecker.isTypeAssignableTo(exportType, surfaceTypes[surfaceType])) {
            const node = declaration.getFirstChild() || declaration;
            throw {
                errors: [
                    {
                        text: `${surfaceType} in ${filePath} is not assignable to ${getSurfaceTypeName(surfaceType)}`,
                        location: {
                            file: filePath,
                            line: node.getStartLineNumber(),
                            column: 0,
                            lineText: declaration.getText().split("\n")[0],
                            additionalLines: declaration.getText().split("\n").slice(1),
                            length: node.getWidth(),
                            namespace: surfaceType,
                            suggestion: `Ensure the export matches the type ${getSurfaceTypeName(surfaceType)}`,
                        },
                    },
                ],
            };
        }
        function getPropertyValueOrThrow(propertyName) {
            if (declaration.getKind() !== SyntaxKind.VariableDeclaration) {
                throw new Error(`${surfaceType} is not an object in ${filePath} ${declaration.getKind()}`);
            }
            const initializer = declaration
                .asKindOrThrow(SyntaxKind.VariableDeclaration)
                .getInitializer();
            if (initializer?.getKind() !== SyntaxKind.ObjectLiteralExpression) {
                throw new Error(`${surfaceType} must be defined as an object literal expression in ${filePath}`);
            }
            const objectLiteral = initializer.asKindOrThrow(SyntaxKind.ObjectLiteralExpression);
            const property = objectLiteral.getProperty(propertyName);
            if (property?.getKind() !== SyntaxKind.PropertyAssignment) {
                throw new Error(`Property ${propertyName} on ${surfaceType} must be directly declared in the object declaration in ${filePath}`);
            }
            const propertyInitializer = property
                .asKindOrThrow(SyntaxKind.PropertyAssignment)
                .getInitializer();
            if (propertyInitializer?.getKind() !== SyntaxKind.StringLiteral) {
                throw new Error(`Property ${propertyName} on ${surfaceType} must be a string literal in ${filePath}`);
            }
            return propertyInitializer.asKindOrThrow(SyntaxKind.StringLiteral).getLiteralValue();
        }
        const surfaceId = getPropertyValueOrThrow("id");
        if (existingIds.has(surfaceId)) {
            throw {
                errors: [
                    {
                        text: `Duplicate surface id ${surfaceId}`,
                        location: {
                            file: filePath,
                            line: declaration.getStartLineNumber(),
                            column: 0,
                            length: declaration.getWidth(),
                            lineText: declaration.getText().split("\n")[0],
                            additionalLines: declaration.getText().split("\n").slice(1),
                            namespace: surfaceType,
                            suggestion: `Ensure the id is unique`,
                        },
                    },
                ],
            };
        }
        existingExportSymbols.add(originalSymbol);
        existingIds.add(surfaceId);
        surfaceExports.add({ surfaceType, id: surfaceId });
    }
    return surfaceExports;
}
