import fs from "fs/promises";
import path from "path";
import { Project } from "ts-morph";
import { complete, errored, isComplete } from "@attio/fetchable-npm";
import { generateRandomFileName } from "./generate-random-file-name.js";
import { parseFileExports } from "./parse-file-exports.js";
import { surfaceTypeDefinitions } from "./surface-types.js";
import { walkDir } from "./walk-dir.js";
export async function findSurfaceExports(rootDir) {
    const existingExportSymbols = new Set();
    const existingIds = new Set();
    const tsProject = new Project({
        compilerOptions: { allowJs: true },
        useInMemoryFileSystem: true,
    });
    const surfaceTypesFilePath = path.join(rootDir, generateRandomFileName("ts"));
    const surfaceTypesSourceFile = tsProject.createSourceFile(surfaceTypesFilePath, surfaceTypeDefinitions);
    const surfaceTypes = {
        recordAction: surfaceTypesSourceFile.getInterfaceOrThrow("RecordAction").getType(),
        bulkRecordAction: surfaceTypesSourceFile.getInterfaceOrThrow("BulkRecordAction").getType(),
        recordWidget: surfaceTypesSourceFile.getInterfaceOrThrow("RecordWidget").getType(),
        callRecordingInsightTextSelectionAction: surfaceTypesSourceFile
            .getInterfaceOrThrow("CallRecordingInsightTextSelectionAction")
            .getType(),
        callRecordingSummaryTextSelectionAction: surfaceTypesSourceFile
            .getInterfaceOrThrow("CallRecordingSummaryTextSelectionAction")
            .getType(),
        callRecordingTranscriptTextSelectionAction: surfaceTypesSourceFile
            .getInterfaceOrThrow("CallRecordingTranscriptTextSelectionAction")
            .getType(),
        workspaceSettings: surfaceTypesSourceFile
            .getInterfaceOrThrow("WorkspaceSettings")
            .getType(),
        workflowBlock: surfaceTypesSourceFile.getInterfaceOrThrow("WorkflowBlock").getType(),
    };
    const typeChecker = tsProject.getTypeChecker();
    async function loadSourceFile(filePath) {
        try {
            const fileContent = await fs.readFile(filePath, "utf-8");
            return complete(tsProject.createSourceFile(filePath, fileContent, { overwrite: true }));
        }
        catch (err) {
            if (typeof err === "object" && err !== null && "code" in err && err.code === "ENOENT") {
                return errored({ code: "FILE_NOT_FOUND" });
            }
            return errored({ code: "UNKNOWN_ERROR" });
        }
    }
    const loadSourceFilesPromises = [];
    const surfaceExportsByPath = [];
    for await (const filePath of walkDir(rootDir)) {
        loadSourceFilesPromises.push(loadSourceFile(filePath));
    }
    const sourceFileResults = await Promise.all(loadSourceFilesPromises);
    sourceFileResults
        .filter((sourceFileResult) => isComplete(sourceFileResult))
        .map((sourceFileResult) => {
        const surfaceExports = parseFileExports({
            sourceFile: sourceFileResult.value,
            existingExportSymbols,
            existingIds,
            typeChecker,
            surfaceTypes,
        });
        if (surfaceExports.size > 0) {
            surfaceExportsByPath.push([
                sourceFileResult.value.getFilePath(),
                [...surfaceExports],
            ]);
        }
    });
    return surfaceExportsByPath;
}
