import { createReadStream, existsSync } from "fs";
import { createInterface } from "readline";
import chalk from "chalk";
import { default as ts } from "typescript";
import { z } from "zod";
async function readLine(path, line) {
    const stream = createReadStream(path);
    const readlineInterface = createInterface({
        input: stream,
        crlfDelay: Infinity,
    });
    let currentLine = 0;
    for await (const lineText of readlineInterface) {
        currentLine += 1;
        if (currentLine === line + 1) {
            readlineInterface.close();
            stream.close();
            return lineText;
        }
    }
    return null;
}
const formatHost = {
    getCanonicalFileName: (path) => path,
    getCurrentDirectory: ts.sys.getCurrentDirectory,
    getNewLine: () => "\n",
};
export const typeScriptErrorSchema = z.object({
    text: z.string(),
    location: z
        .object({
        file: z.string(),
        lineText: z.string(),
        line: z.number(),
        character: z.number(),
        endCharacter: z.number(),
    })
        .optional(),
});
export const readConfig = async (configFile) => new Promise((resolve, reject) => {
    if (!existsSync(configFile)) {
        resolve("Not a TypeScript project");
        return;
    }
    const { config, error } = ts.readConfigFile(configFile, ts.sys.readFile);
    if (error) {
        reject(typeScriptErrorSchema.parse({ text: ts.formatDiagnostic(error, formatHost) }));
    }
    else {
        const parsedCommandLine = ts.parseJsonConfigFileContent(config, ts.sys, "./");
        resolve(ts.createProgram({
            rootNames: parsedCommandLine.fileNames,
            options: parsedCommandLine.options,
        }));
    }
});
export const getDiagnostics = async (program) => {
    const diagnostics = ts.getPreEmitDiagnostics(program);
    const errors = await Promise.all(diagnostics.map(async (diagnostic) => {
        const text = ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
        if (diagnostic.file) {
            const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
            const endPosition = diagnostic.start + diagnostic.length;
            const { character: endCharacter } = diagnostic.file.getLineAndCharacterOfPosition(endPosition);
            const lineText = await readLine(diagnostic.file.fileName, line);
            return typeScriptErrorSchema.parse({
                text,
                location: {
                    file: diagnostic.file.fileName,
                    line,
                    character,
                    endCharacter,
                    lineText,
                },
            });
        }
        else {
            return typeScriptErrorSchema.parse({ text });
        }
    }));
    return errors;
};
export function printTsError(error) {
    if (!error.location) {
        process.stderr.write(`${chalk.red("Ã—")} â€“ ${error.text}\n`);
        return;
    }
    const lineString = error.location.line.toLocaleString().padStart(3, " ");
    const lineStringLength = lineString.length;
    const emptyLine = " ".repeat(lineStringLength);
    const lineText = error.location.lineText;
    const leadingSpaces = lineText.match(/^\s*/)?.[0].length || 0;
    const trimmedLineText = lineText.trimStart();
    const beforeError = trimmedLineText.slice(0, error.location.character - leadingSpaces);
    const errorText = trimmedLineText.slice(error.location.character - leadingSpaces, error.location.endCharacter - leadingSpaces);
    const afterError = trimmedLineText.slice(error.location.endCharacter - leadingSpaces);
    process.stderr.write(`${" ".repeat(lineStringLength - 2)} ${chalk.red("Ã—")} ${error.text}\n\n`);
    process.stderr.write(`${emptyLine} â•­â”€â”€â”€ ${chalk.bold(error.location.file)}\n`);
    process.stderr.write(`${lineString} â”‚ ${beforeError}${chalk.red(errorText)}${afterError}\n`);
    process.stderr.write(`${emptyLine} â”‚ ${" ".repeat(Math.max(0, error.location.character - leadingSpaces))}${chalk.red("~".repeat(Math.max(0, error.location.endCharacter - error.location.character)))}\n`);
    process.stderr.write(`${emptyLine} â•°â”€â”€â”€\n\n`);
}
export function printJsError(error, type) {
    if (!error.location) {
        process.stderr.write(`${chalk.red("Ã—")} â€“ ${error.text}\n`);
        return;
    }
    const lineString = error.location.line.toLocaleString().padStart(3, " ");
    const lineStringLength = lineString.length;
    const emptyLine = " ".repeat(lineStringLength);
    const lineText = error.location.lineText;
    const leadingSpaces = lineText.match(/^\s*/)?.[0].length || 0;
    const trimmedLineText = lineText.trimStart();
    const beforeError = trimmedLineText.slice(0, error.location.column - leadingSpaces);
    const errorText = trimmedLineText.slice(error.location.column - leadingSpaces, error.location.column + error.location.length - leadingSpaces);
    const afterError = trimmedLineText.slice(error.location.column + error.location.length - leadingSpaces);
    process.stderr.write(`${" ".repeat(lineStringLength - 2)} ${type === "error" ? chalk.red("Ã—") : "ðŸš§"} ${error.text}\n\n`);
    process.stderr.write(`${emptyLine} â•­â”€â”€â”€ ${chalk.bold(error.location.file)}\n`);
    process.stderr.write(`${lineString} â”‚ ${beforeError}${chalk.red(errorText)}${afterError}\n`);
    process.stderr.write(`${emptyLine} â”‚ ${" ".repeat(Math.max(0, error.location.column - leadingSpaces))}${chalk.red("~".repeat(error.location.length))}\n`);
    process.stderr.write(`${emptyLine} â•°â”€â”€â”€\n\n`);
}
