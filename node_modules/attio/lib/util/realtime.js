import Ably from "ably";
import { complete, errored, isComplete, isErrored } from "@attio/fetchable-npm";
import { api } from "../api/api.js";
function makeConnectionError(error) {
    return errored({
        code: "FAILED_TO_CONNECT_TO_REALTIME_SERVER",
        error,
    });
}
export class Realtime {
    _ablyRealtime;
    _channels = new Map();
    _suspendListeners = new Set();
    constructor() {
        this._ablyRealtime = this._createAblyRealtime();
    }
    async subscribe(channelName, eventName, eventDataSchema, listener) {
        let channel = this._channels.get(channelName);
        if (!channel) {
            channel = {
                listeners: new Map(),
            };
            const authorizeResult = await this._authorizeChannel(channelName);
            if (isErrored(authorizeResult)) {
                return makeConnectionError(authorizeResult.error.error);
            }
            this._channels.set(channelName, channel);
        }
        let eventListeners = channel.listeners.get(eventName);
        if (!eventListeners) {
            eventListeners = new Set();
            channel.listeners.set(eventName, eventListeners);
        }
        const subscribeResult = await this._subscribe(channelName, eventName, (data) => {
            const parsedEventData = eventDataSchema.safeParse(data);
            if (parsedEventData.success) {
                listener(parsedEventData.data);
            }
        });
        if (isErrored(subscribeResult)) {
            return makeConnectionError(subscribeResult.error.error);
        }
        eventListeners.add(listener);
        return complete({
            unsubscribe: async () => {
                await this._unsubscribe(channelName, eventName, listener);
            },
        });
    }
    async reconnect() {
        await this._teardown();
        this._ablyRealtime = this._createAblyRealtime();
        for (const [channelName, { listeners }] of this._channels) {
            const authorizeResult = await this._authorizeChannel(channelName);
            if (isErrored(authorizeResult)) {
                return makeConnectionError(authorizeResult.error.error);
            }
            for (const [eventName, eventListeners] of listeners) {
                for (const eventListener of eventListeners) {
                    const subscribeResult = await this._subscribe(channelName, eventName, eventListener);
                    if (isErrored(subscribeResult)) {
                        return makeConnectionError(subscribeResult.error.error);
                    }
                }
            }
        }
        return complete(true);
    }
    onSuspended(cb) {
        this._suspendListeners.add(cb);
        return () => {
            this._suspendListeners.delete(cb);
        };
    }
    async close() {
        await this._teardown();
    }
    _createAblyRealtime() {
        const realtime = new Ably.Realtime({
            logLevel: 0,
            useTokenAuth: true,
            autoConnect: false,
            tls: true,
            echoMessages: false,
            authCallback: async (tokenParams, callback) => {
                const tokenResult = await api.authenticateAbly(tokenParams);
                if (isErrored(tokenResult)) {
                    return callback(tokenResult.error.message, null);
                }
                return callback(null, tokenResult.value);
            },
        });
        realtime.connection.on("suspended", () => {
            this._suspendListeners.forEach((listener) => listener());
        });
        return realtime;
    }
    async _authorizeChannel(channelName) {
        try {
            await this._ablyRealtime.auth.authorize({
                capability: {
                    [`${channelName}`]: ["subscribe"],
                },
            });
            return complete(true);
        }
        catch (error) {
            return errored({ code: "FAILED_TO_AUTHORIZE_CHANNEL", error });
        }
    }
    async _subscribe(channelName, eventName, listener) {
        try {
            const ablyChannel = this._ablyRealtime.channels.get(channelName);
            await ablyChannel.presence.enter();
            await ablyChannel.subscribe(eventName, (event) => {
                listener(event.data.data);
            });
            return complete(true);
        }
        catch (error) {
            return errored({ code: "FAILED_TO_SUBSCRIBE_TO_EVENTS", error });
        }
    }
    async _unsubscribe(channelName, eventName, listener) {
        const ablyChannel = this._ablyRealtime.channels.get(channelName);
        ablyChannel.unsubscribe(eventName, listener);
        const channel = this._channels.get(channelName);
        if (!channel) {
            return complete(true);
        }
        const eventListeners = channel.listeners.get(eventName);
        if (eventListeners) {
            eventListeners.delete(listener);
            if (eventListeners?.size === 0) {
                channel.listeners.delete(eventName);
            }
        }
        if (channel.listeners.size === 0) {
            const channelTeardownResult = await this._teardownChannel(channelName);
            if (isComplete(channelTeardownResult)) {
                this._channels.delete(channelName);
            }
        }
        return complete(true);
    }
    async _teardown() {
        for (const [channelName] of this._channels) {
            await this._teardownChannel(channelName);
        }
        this._ablyRealtime.close();
        return complete(true);
    }
    async _teardownChannel(channelName) {
        const ablyChannel = this._ablyRealtime.channels.get(channelName);
        try {
            await ablyChannel.presence.leave();
            await ablyChannel.detach();
            return complete(true);
        }
        catch (error) {
            return errored({ code: "FAILED_TO_TEARDOWN_CHANNEL", error });
        }
    }
}
