import chalk from "chalk";
import { APP } from "./env.js";
export function printFetcherError(message, { error }) {
    process.stderr.write(`${chalk.red("✖ ")}${message}\n`);
    switch (error.code) {
        case "HTTP_ERROR":
            process.stderr.write(`HTTP Error (${error.status}): ${error.message}\n`);
            break;
        case "INVALID_RESPONSE":
            process.stderr.write(`Invalid response: ${error.message}\n`);
            break;
        case "NETWORK_ERROR":
            process.stderr.write(`Network error: ${error.message}\n`);
            break;
        case "UNAUTHORIZED":
            process.stderr.write(`Unauthorized. You must log in with "attio login"\n`);
            break;
    }
}
export function printUploadError(error) {
    switch (error.code) {
        case "BUNDLE_UPLOAD_ERROR":
            process.stderr.write(chalk.red(`Error uploading bundle: ${error.upload_url}\n`));
            break;
        case "START_UPLOAD_ERROR":
            printFetcherError("Error starting upload", error);
            break;
        case "COMPLETE_BUNDLE_UPLOAD_ERROR":
            printFetcherError("Error completing bundle upload", error);
            break;
        default:
            return error;
    }
}
export function printCreateProjectError(error) {
    switch (error.code) {
        case "DIRECTORY_ALREADY_EXISTS":
            process.stderr.write(chalk.red(`✖ Directory ${error.path} already exists.\n`));
            break;
        case "WRITE_ACCESS_DENIED":
            process.stderr.write(chalk.red(`✖ Write access denied to ${error.path}\n`));
            break;
        case "FAILED_TO_CREATE_DIRECTORY":
            process.stderr.write(chalk.red(`✖ Failed to create directory ${error.path}\n`));
            break;
        case "FAILED_TO_COPY_FILE":
            process.stderr.write(chalk.red(`✖ Failed to copy file ${error.src} to ${error.dest}\n`));
            break;
        case "FAILED_TO_LIST_FILES":
            process.stderr.write(chalk.red(`✖ Failed to list files in ${error.path}\n`));
            break;
        case "FAILED_TO_READ_FILE":
            process.stderr.write(chalk.red(`✖ Failed to read file ${error.path}\n`));
            break;
        case "FAILED_TO_WRITE_FILE":
            process.stderr.write(chalk.red(`✖ Failed to write file ${error.path}\n`));
            break;
        default:
            return error;
    }
}
export function printPackageJsonError({ code, error }) {
    switch (code) {
        case "MALFORMED_PACKAGE_JSON":
            if (error.issues.length > 0) {
                process.stderr.write(`${chalk.red("✖ ")}Malformed package.json: ${error.issues[0].message}\n`);
            }
            else {
                process.stderr.write(`${chalk.red("✖ ")}Malformed package.json: ${error.message}\n`);
            }
            break;
        case "FILE_SYSTEM_ERROR":
            process.stderr.write(`${chalk.red("✖ ")}Failed to read package.json\n`);
            break;
        case "INVALID_JSON":
            process.stderr.write(`${chalk.red("✖ ")}Invalid JSON in package.json: ${error}\n`);
            break;
    }
}
export function printCliVersionError({ error }) {
    switch (error.code) {
        case "UNABLE_TO_FIND_PACKAGE_JSON":
            process.stderr.write(`${chalk.red("✖ ")}Failed to find package.json in ${error.path}\n`);
            break;
        case "UNABLE_TO_READ_PACKAGE_JSON":
            process.stderr.write(`${chalk.red("✖ ")}Failed to read package.json: ${error.error}\n`);
            break;
        case "UNABLE_TO_PARSE_PACKAGE_JSON":
            process.stderr.write(`${chalk.red("✖ ")}Failed to parse package.json: ${error.error}\n`);
            break;
        case "INVALID_PACKAGE_JSON":
            process.stderr.write(`${chalk.red("✖ ")}Invalid package.json: ${error.error}\n`);
            break;
        case "ERROR_LOADING_PACKAGE_JSON":
            process.stderr.write(`${chalk.red("✖ ")}Error loading package.json: ${error.error}\n`);
            break;
        case "NO_CLI_VERSION_FOUND":
            process.stderr.write(`${chalk.red("✖ ")}No CLI version found in attio's package.json\n`);
            break;
        default:
            return error;
    }
}
export function printDetermineWorkspaceError(error) {
    switch (error.code) {
        case "FETCH_WORKSPACES_ERROR":
            process.stderr.write(`Error fetching workspaces: ${error.error}

${APP}/welcome/workspace-details
                    `);
            break;
        case "NO_WORKSPACE_FOUND":
            process.stderr.write(`You are not the admin any workspace with the slug "${error.workspace_slug}". Either request permission from "${error.workspace_slug}" or create your own.

${APP}/welcome/workspace-details
                    `);
            break;
        case "NO_WORKSPACES_FOUND":
            process.stderr.write(`You are not the admin of any workspaces. Either request permission from an existing workspace or create your own.

${APP}/welcome/workspace-details
                    `);
            break;
        default:
            return error;
    }
}
export function printKeychainError(error) {
    switch (error.code) {
        case "SAVE_KEYCHAIN_ERROR":
            process.stderr.write(chalk.red(`Error saving token to keychain: ${error.error}`));
            break;
        case "LOAD_KEYCHAIN_ERROR":
            process.stderr.write(chalk.red(`Error loading token from keychain: ${error.error}`));
            break;
        case "DELETE_KEYCHAIN_ERROR":
            process.stderr.write(chalk.red(`Error deleting token from keychain: ${error.error}`));
            break;
        default:
            return error;
    }
}
export function printAuthenticationError(error) {
    switch (error.code) {
        case "GET_TOKEN_ERROR":
            printFetcherError("Error getting token", error);
            break;
        case "REFRESH_TOKEN_ERROR":
            printFetcherError("Error refreshing token", error);
            break;
        case "NO_AUTHORIZATION_CODE":
            process.stderr.write(chalk.red(`No authorization code received`));
            break;
        case "OAUTH_STATE_MISMATCH":
            process.stderr.write(chalk.red(`OAuth state mismatch, possible CSRF attack`));
            break;
        case "SAVE_KEYCHAIN_ERROR":
        case "LOAD_KEYCHAIN_ERROR":
        case "DELETE_KEYCHAIN_ERROR":
            printKeychainError(error);
            break;
        default:
            return error;
    }
}
export function printLogSubscriptionError(error) {
    switch (error.code) {
        case "FAILED_TO_CONNECT_TO_LOGS_SERVER":
            let message = "Failed to connect to logs server";
            if (error.error instanceof Error) {
                message = `${message}: ${error.error.message}`;
            }
            process.stderr.write(chalk.red(`\n${message}\n`));
            break;
        default:
            return error.code;
    }
}
