import type { ArrayNode } from "./array-node";
import type { BaseNode } from "./base-node";
import type { StructNode } from "./struct-node";
import type { UnionNode } from "./union-node";
type ResolvedSegment<TRoot extends BaseNode, TSegment extends string> = TRoot extends StructNode<infer TEntries> ? TSegment extends keyof TEntries ? TEntries[TSegment] : never : TRoot extends ArrayNode<infer TElement> ? TElement : TRoot extends UnionNode<infer TNodes extends Array<BaseNode>> ? ResolvedSegment<TNodes[number], TSegment> : never;
/**
 * Returns the node which lies at the given path in the schema.
 */
export type ResolvedPath<TRoot extends BaseNode, TPath extends string | undefined> = TPath extends string ? TPath extends `${infer TFirst}.${infer TRest}` ? ResolvedSegment<TRoot, TFirst> extends BaseNode ? ResolvedPath<ResolvedSegment<TRoot, TFirst>, TRest> | never : undefined : ResolvedSegment<TRoot, TPath> : TRoot;
export {};
//# sourceMappingURL=resolved-path.d.ts.map