import path from "path";
function getBlockModuleProxy(modulePath, workflowBlockModulesRef) {
    let counter = 0;
    const exports = new Map();
    for (const { execute, schema, activate, deactivate, } of workflowBlockModulesRef.current.values()) {
        for (const handler of [execute, activate, deactivate]) {
            if (!handler || handler.path !== modulePath) {
                continue;
            }
            if (handler.export === "default") {
                exports.set("default", `export default async function() {
    throw new Error("Exports from *.block.ts files cannot be called from the client.")
}`);
            }
            else {
                exports.set(handler.export, `export async function ${handler.export}() {
    throw new Error("Exports from *.block.ts files cannot be called from the client.")
}`);
            }
        }
        if (schema && schema.path === modulePath) {
            if (schema.export === "default") {
                let name;
                do {
                    name = `schema_${counter++}`;
                } while (!exports.has(name));
                exports.set("default", `const ${name} = new Proxy({}, {
    get() {
        throw new Error("Exports from *.block.ts files cannot be called from the client.");
    }
});

export default ${name};`);
            }
            else {
                exports.set(schema.export, `export const ${schema.export} = new Proxy({}, {
    get() {
        throw new Error("Exports from *.block.ts files cannot be called from the client.");
    }
});`);
            }
        }
    }
    return [...exports.values()].join("\n");
}
const PLUGIN_NAME = "proxy-block-modules-plugin";
export function proxyBlockModulesPlugin({ appDir, workflowBlockModulesRef, }) {
    return {
        name: PLUGIN_NAME,
        setup(build) {
            build.onResolve({ filter: /\.block$/ }, (args) => {
                const modulePath = path.relative(appDir, path.resolve(args.resolveDir, args.path)) + ".ts";
                return {
                    path: args.path,
                    namespace: PLUGIN_NAME,
                    pluginData: { modulePath },
                };
            });
            build.onLoad({ filter: /.*/, namespace: PLUGIN_NAME }, async (args) => {
                const pluginData = args.pluginData;
                return {
                    contents: getBlockModuleProxy(pluginData.modulePath, workflowBlockModulesRef),
                    loader: "js",
                };
            });
        },
    };
}
