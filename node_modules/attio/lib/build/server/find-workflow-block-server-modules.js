import fs from "node:fs";
import { parse } from "@typescript-eslint/parser";
import { analyze } from "@typescript-eslint/scope-manager";
import { walk } from "zimmerframe";
import { complete, errored } from "@attio/fetchable-npm";
import { getAppEntryPoint } from "../../util/get-app-entry-point.js";
function checkPath(path, doesModuleExist) {
    if (doesModuleExist(path)) {
        return path;
    }
    return null;
}
function resolvePathWithExtension(path, doesModuleExist) {
    return (checkPath(path + ".ts", doesModuleExist) ||
        checkPath(path + ".tsx", doesModuleExist) ||
        checkPath(path + ".js", doesModuleExist));
}
function loadModule(sourcePath, currPath, helpers) {
    const absolutePath = resolveAbsolutePath(sourcePath, currPath);
    const fullPath = resolvePathWithExtension(absolutePath, helpers.doesModuleExist);
    if (!fullPath) {
        throw new Error(`Unable to resolve path for module ${sourcePath} from ${currPath}`);
    }
    const modules = helpers.modules;
    if (modules.has(fullPath)) {
        return modules.get(fullPath);
    }
    const content = helpers.getModuleSource(fullPath);
    const ast = parse(content, {
        range: true,
        jsx: true,
    });
    const scopeManager = analyze(ast, {
        sourceType: "module",
    });
    const moduleScope = scopeManager.acquire(ast, true);
    const namedExports = new Map();
    const module = {
        content,
        ast,
        scope: moduleScope,
        namedExports,
        path: fullPath,
    };
    modules.set(fullPath, module);
    walk(ast, null, {
        ExportNamedDeclaration(node) {
            if (node.declaration?.type === "VariableDeclaration" &&
                node.declaration.declarations.length === 1 &&
                node.declaration.declarations[0].type === "VariableDeclarator" &&
                node.declaration.declarations[0].id.type === "Identifier") {
                const declaration = node.declaration.declarations[0];
                const id = declaration.id;
                const init = declaration.init;
                if (init?.type === "Identifier") {
                    const resolved = resolveIdentifierToValue(init, moduleScope);
                    if (resolved?.type !== "ImportBinding") {
                        namedExports.set(id.name, declaration.init);
                        return;
                    }
                }
                namedExports.set(id.name, declaration.init);
            }
            if (node?.specifiers) {
                for (const specifier of node.specifiers) {
                    if (specifier.type === "ExportSpecifier" &&
                        specifier.exported.type === "Identifier" &&
                        specifier.local.type === "Identifier") {
                        if (node.source !== null) {
                            namedExports.set(specifier.exported.name, node);
                        }
                        else {
                            const resolved = resolveIdentifierToValue(specifier.local, moduleScope);
                            namedExports.set(specifier.exported.name, resolved);
                        }
                    }
                }
            }
        },
    });
    return module;
}
function resolveIdentifierToValue(node, scope) {
    const variable = scope.set.get(node.name);
    if (!variable) {
        throw new Error(`Unable to find variable ${node.name} in scope`);
    }
    if (variable.defs.length !== 1) {
        throw new Error(`Expected exactly one definition for variable ${node.name}, found ${variable.defs.length}`);
    }
    const def = variable.defs[0];
    if (def.node.type === "VariableDeclarator") {
        return def.node.init;
    }
    if (def.type == "ImportBinding") {
        return def;
    }
    return null;
}
function resolveAbsolutePath(sourcePath, currPath) {
    if (sourcePath.startsWith(".")) {
        const currDir = currPath.split("/").slice(0, -1).join("/");
        const combinedPath = currDir + "/" + sourcePath;
        const parts = combinedPath.split("/");
        const resolvedParts = [];
        for (const part of parts) {
            if (part === "..") {
                resolvedParts.pop();
            }
            else if (part !== ".") {
                resolvedParts.push(part);
            }
        }
        return resolvedParts.join("/");
    }
    return sourcePath;
}
function captureImportPath(name, node, scope, currPath, helpers) {
    const importValue = node.type === "Identifier" ? resolveIdentifierToValue(node, scope) : node;
    if (!importValue ||
        (importValue.type !== "ImportBinding" && importValue.type !== "ExportNamedDeclaration")) {
        throw new Error(`Expected parent of import binding to be an import binding`);
    }
    const importDeclaration = importValue.type === "ExportNamedDeclaration"
        ? importValue
        : importValue.parent;
    const sourcePath = importDeclaration.source.value;
    let absolutePath = resolveAbsolutePath(sourcePath, currPath);
    if (sourcePath.endsWith(".server")) {
        throw new Error(`Unexpected .server import, did you mean to import "${name}" from a .block file?`);
    }
    if (!sourcePath.endsWith(".block") &&
        !sourcePath.endsWith(".block.ts") &&
        !sourcePath.endsWith(".block.tsx") &&
        !sourcePath.endsWith(".block.js")) {
        const module = loadModule(sourcePath, absolutePath, helpers);
        if (!module.namedExports.has(name)) {
            throw new Error(`Unable to find named export ${name} in module ${sourcePath}`);
        }
        const value = module.namedExports.get(name);
        const scope = module.scope;
        const path = module.path;
        return captureImportPath(name, value, scope, path, helpers);
    }
    let targetExport = name;
    if (importValue.type === "ImportBinding" && importValue.name.name !== name) {
        targetExport = importValue.name.name;
    }
    absolutePath = resolvePathWithExtension(absolutePath, helpers.doesModuleExist) || absolutePath;
    return { path: absolutePath, export: targetExport };
}
function visitBlock(node, scope, result, currPath, helpers) {
    if (node.type === "Identifier") {
        let targetScope = scope;
        let value = resolveIdentifierToValue(node, scope);
        let targetPath = currPath;
        if (value?.type === "ImportBinding") {
            const importDeclaration = value.parent;
            const module = loadModule(importDeclaration.source.value, currPath, helpers);
            const local = value.name.name;
            const specififier = importDeclaration.specifiers.find((s) => s.local.name === local);
            const name = (specififier
                ?.imported).name;
            if (!module.namedExports.has(name)) {
                throw new Error(`Unable to find named export ${name} in module ${importDeclaration.source.value}`);
            }
            value = module.namedExports.get(name);
            targetScope = module.scope;
            targetPath = module.path;
        }
        if (!value || value.type !== "ObjectExpression") {
            throw new Error(`Expected variable ${node.name} to have an initializer`);
        }
        visitBlock(value, targetScope, result, targetPath, helpers);
        return;
    }
    if (node.type === "ObjectExpression") {
        let id;
        let execute;
        let schema;
        let activate;
        let deactivate;
        for (const property of node.properties) {
            if (property.type !== "Property" || property.key.type !== "Identifier") {
                continue;
            }
            const name = property.key.name;
            if (name === "id") {
                if (property.value.type !== "Literal" || typeof property.value.value !== "string") {
                    throw new Error("Expected block id to be a string literal");
                }
                id = property.value.value;
            }
            else if (name === "execute") {
                execute = captureImportPath(name, property.value, scope, currPath, helpers);
            }
            else if (name === "schema") {
                schema = captureImportPath(name, property.value, scope, currPath, helpers);
            }
            else if (name === "activate") {
                activate = captureImportPath(name, property.value, scope, currPath, helpers);
            }
            else if (name === "deactivate") {
                deactivate = captureImportPath(name, property.value, scope, currPath, helpers);
            }
        }
        if (!id || !schema) {
            throw new Error("Expected block to have id and schema properties");
        }
        result.set(id, {
            execute,
            schema,
            activate,
            deactivate,
        });
    }
}
function findProperty(obj, name, scope) {
    const property = obj.properties.find((property) => property.type === "Property" &&
        property.key.type === "Identifier" &&
        property.key.name === name);
    if (!property) {
        return null;
    }
    let value = property.value;
    if (value.type === "Identifier") {
        const resolvedValue = resolveIdentifierToValue(value, scope);
        if (resolvedValue && resolvedValue?.type !== "ImportBinding") {
            value = resolvedValue;
        }
    }
    return value;
}
export function findWorkflowBlockModulesFromSource(source, currPath, helpers) {
    const result = new Map();
    try {
        const ast = parse(source, {
            range: true,
            jsx: true,
        });
        const scopeManager = analyze(ast, {
            sourceType: "module",
        });
        const moduleScope = scopeManager.acquire(ast, true);
        if (moduleScope === null) {
            throw new Error("Expected to be able to acquire module scope");
        }
        walk(ast, null, {
            ExportNamedDeclaration(node, context) {
                if (!node.declaration || node.declaration.type !== "VariableDeclaration") {
                    throw new Error("Expected export to be a variable declaration");
                }
                if (node.declaration.declarations.length !== 1) {
                    throw new Error("Expected exactly one declaration per export");
                }
                const declaration = node.declaration.declarations[0];
                if (declaration.id.type !== "Identifier" || declaration.id.name !== "app") {
                    throw new Error("Expected export to be named 'app'");
                }
                const appValue = declaration.init;
                if (!appValue || appValue.type !== "ObjectExpression") {
                    throw new Error("Expected app to be initialized to an object");
                }
                const workflow = findProperty(appValue, "workflow", moduleScope);
                if (workflow?.type !== "ObjectExpression") {
                    return;
                }
                const blocks = findProperty(workflow, "blocks", moduleScope);
                if (blocks?.type !== "ObjectExpression") {
                    return;
                }
                const triggers = findProperty(blocks, "triggers", moduleScope);
                if (triggers?.type === "ArrayExpression") {
                    for (const element of triggers.elements) {
                        if (element) {
                            visitBlock(element, moduleScope, result, currPath, helpers);
                        }
                    }
                }
                const steps = findProperty(blocks, "steps", moduleScope);
                if (steps?.type === "ArrayExpression") {
                    for (const element of steps.elements) {
                        if (element) {
                            visitBlock(element, moduleScope, result, currPath, helpers);
                        }
                    }
                }
            },
        });
    }
    catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        return errored({ code: "WORKFLOW_BLOCK_RESOLUTION_FAILED", message });
    }
    return complete(result);
}
export async function findWorkflowBlockModules(srcDirAbsolute) {
    const appEntryPoint = await getAppEntryPoint(srcDirAbsolute);
    if (!appEntryPoint) {
        return complete(new Map());
    }
    const getModuleSource = (path) => {
        return fs.readFileSync(path, "utf-8");
    };
    const doesModuleExist = (path) => {
        return fs.existsSync(path);
    };
    const modules = new Map();
    return findWorkflowBlockModulesFromSource(appEntryPoint.content, appEntryPoint.path, {
        getModuleSource,
        doesModuleExist,
        modules,
    });
}
