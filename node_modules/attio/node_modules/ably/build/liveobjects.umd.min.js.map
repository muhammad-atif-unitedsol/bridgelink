{
  "version": 3,
  "sources": ["../src/plugins/liveobjects/index.ts", "../src/plugins/liveobjects/objectid.ts", "../src/plugins/liveobjects/objectmessage.ts", "../src/plugins/liveobjects/livecountervaluetype.ts", "../node_modules/dequal/dist/index.mjs", "../src/plugins/liveobjects/constants.ts", "../src/plugins/liveobjects/liveobject.ts", "../src/plugins/liveobjects/livecounter.ts", "../src/plugins/liveobjects/livemap.ts", "../src/plugins/liveobjects/livemapvaluetype.ts", "../src/plugins/liveobjects/defaults.ts", "../src/plugins/liveobjects/objectspool.ts", "../src/plugins/liveobjects/batchcontext.ts", "../src/plugins/liveobjects/rootbatchcontext.ts", "../src/plugins/liveobjects/instance.ts", "../src/plugins/liveobjects/pathobject.ts", "../src/plugins/liveobjects/pathobjectsubscriptionregister.ts", "../src/plugins/liveobjects/syncobjectsdatapool.ts", "../src/plugins/liveobjects/realtimeobject.ts"],
  "sourcesContent": ["import { LiveCounterValueType } from './livecountervaluetype';\r\nimport { LiveMapValueType } from './livemapvaluetype';\r\nimport { ObjectMessage, WireObjectMessage } from './objectmessage';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\nexport {\r\n  LiveCounterValueType as LiveCounter,\r\n  LiveMapValueType as LiveMap,\r\n  ObjectMessage,\r\n  RealtimeObject,\r\n  WireObjectMessage,\r\n};\r\n\r\n/**\r\n * The named LiveObjects plugin object export to be passed to the Ably client.\r\n */\r\nexport const LiveObjects = {\r\n  LiveCounter: LiveCounterValueType,\r\n  LiveMap: LiveMapValueType,\r\n  ObjectMessage,\r\n  RealtimeObject,\r\n  WireObjectMessage,\r\n};\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type Platform from 'common/platform';\r\n\r\nexport type LiveObjectType = 'map' | 'counter';\r\n\r\n/**\r\n * Represents a parsed object id.\r\n *\r\n * @internal\r\n */\r\nexport class ObjectId {\r\n  private constructor(\r\n    readonly type: LiveObjectType,\r\n    readonly hash: string,\r\n    readonly msTimestamp: number,\r\n  ) {}\r\n\r\n  static fromInitialValue(\r\n    platform: typeof Platform,\r\n    objectType: LiveObjectType,\r\n    initialValue: string,\r\n    nonce: string,\r\n    msTimestamp: number,\r\n  ): ObjectId {\r\n    const valueForHashBuffer = platform.BufferUtils.concat([\r\n      platform.BufferUtils.utf8Encode(initialValue),\r\n      platform.BufferUtils.utf8Encode(':'),\r\n      platform.BufferUtils.utf8Encode(nonce),\r\n    ]);\r\n    const hashBuffer = platform.BufferUtils.sha256(valueForHashBuffer);\r\n    const hash = platform.BufferUtils.base64UrlEncode(hashBuffer);\r\n\r\n    return new ObjectId(objectType, hash, msTimestamp);\r\n  }\r\n\r\n  /**\r\n   * Create ObjectId instance from hashed object id string.\r\n   */\r\n  static fromString(client: BaseClient, objectId: string | null | undefined): ObjectId {\r\n    if (client.Utils.isNil(objectId)) {\r\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\r\n    }\r\n\r\n    // RTO6b1\r\n    const [type, rest] = objectId.split(':');\r\n    if (!type || !rest) {\r\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\r\n    }\r\n\r\n    if (!['map', 'counter'].includes(type)) {\r\n      throw new client.ErrorInfo(`Invalid object type in object id: ${objectId}`, 92000, 500);\r\n    }\r\n\r\n    const [hash, msTimestamp] = rest.split('@');\r\n    if (!hash || !msTimestamp) {\r\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\r\n    }\r\n\r\n    if (!Number.isInteger(Number.parseInt(msTimestamp))) {\r\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\r\n    }\r\n\r\n    return new ObjectId(type as LiveObjectType, hash, Number.parseInt(msTimestamp));\r\n  }\r\n\r\n  toString(): string {\r\n    return `${this.type}:${this.hash}@${this.msTimestamp}`;\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\r\nimport type { MessageEncoding } from 'common/lib/types/basemessage';\r\nimport type * as Utils from 'common/lib/util/utils';\r\nimport type * as ObjectsApi from '../../../liveobjects';\r\n\r\nconst operationActions: ObjectsApi.ObjectOperationAction[] = [\r\n  'map.create',\r\n  'map.set',\r\n  'map.remove',\r\n  'counter.create',\r\n  'counter.inc',\r\n  'object.delete',\r\n];\r\n\r\nconst mapSemantics: ObjectsApi.ObjectsMapSemantics[] = ['lww'];\r\n\r\nexport type EncodeObjectDataFunction = (data: ObjectData | WireObjectData) => WireObjectData;\r\n\r\n/** @spec OOP2 */\r\nexport enum ObjectOperationAction {\r\n  MAP_CREATE = 0,\r\n  MAP_SET = 1,\r\n  MAP_REMOVE = 2,\r\n  COUNTER_CREATE = 3,\r\n  COUNTER_INC = 4,\r\n  OBJECT_DELETE = 5,\r\n}\r\n\r\n/** @spec OMP2 */\r\nexport enum ObjectsMapSemantics {\r\n  LWW = 0,\r\n}\r\n\r\n/**\r\n * An ObjectData represents a value in an object on a channel decoded from {@link WireObjectData}.\r\n * @spec OD1\r\n */\r\nexport interface ObjectData {\r\n  /** A reference to another object, used to support composable object structures. */\r\n  objectId?: string; // OD2a\r\n  /** A decoded leaf value from {@link WireObjectData}. */\r\n  value?: ObjectsApi.Primitive;\r\n}\r\n\r\n/**\r\n * A WireObjectData represents a value in an object on a channel received from the server.\r\n * @spec OD1\r\n */\r\nexport interface WireObjectData {\r\n  /** A reference to another object, used to support composable object structures. */\r\n  objectId?: string; // OD2a\r\n\r\n  /** A primitive boolean leaf value in the object graph. Only one value field can be set. */\r\n  boolean?: boolean; // OD2c\r\n  /** A primitive binary leaf value in the object graph. Only one value field can be set. Represented as a Base64-encoded string in JSON protocol */\r\n  bytes?: Buffer | ArrayBuffer | string; // OD2d\r\n  /** A primitive number leaf value in the object graph. Only one value field can be set. */\r\n  number?: number; // OD2e\r\n  /** A primitive string leaf value in the object graph. Only one value field can be set. */\r\n  string?: string; // OD2f\r\n  /** A primitive JSON-encoded string leaf value in the object graph. Only one value field can be set. */\r\n  json?: string; // OD2g\r\n}\r\n\r\n/**\r\n * An ObjectsMapOp describes an operation to be applied to a Map object.\r\n * @spec OMO1\r\n */\r\nexport interface ObjectsMapOp<TData> {\r\n  /** The key of the map entry to which the operation should be applied. */\r\n  key: string; // OMO2a\r\n  /** The data that the map entry should contain if the operation is a MAP_SET operation. */\r\n  data?: TData; // OMO2b\r\n}\r\n\r\n/**\r\n * An ObjectsCounterOp describes an operation to be applied to a Counter object.\r\n * @spec OCO1\r\n */\r\nexport interface ObjectsCounterOp {\r\n  /** The data value that should be added to the counter. */\r\n  amount: number; // OCO2a\r\n}\r\n\r\n/**\r\n * An ObjectsMapEntry represents the value at a given key in a Map object.\r\n * @spec OME1\r\n */\r\nexport interface ObjectsMapEntry<TData> {\r\n  /** Indicates whether the map entry has been removed. */\r\n  tombstone?: boolean; // OME2a\r\n  /**\r\n   * The {@link ObjectMessage.serial} value of the last operation that was applied to the map entry.\r\n   *\r\n   * It is optional in a MAP_CREATE operation and might be missing, in which case the client should use a nullish value for it\r\n   * and treat it as the \"earliest possible\" serial for comparison purposes.\r\n   */\r\n  timeserial?: string; // OME2b\r\n  /** A timestamp from the {@link timeserial} field. Only present if {@link tombstone} is `true` */\r\n  serialTimestamp?: number; // OME2d\r\n  /** The data that represents the value of the map entry. */\r\n  data?: TData; // OME2c\r\n}\r\n\r\n/**\r\n * An ObjectsMap object represents a map of key-value pairs.\r\n * @spec OMP1\r\n */\r\nexport interface ObjectsMap<TData> {\r\n  /** The conflict-resolution semantics used by the map object. */\r\n  semantics?: ObjectsMapSemantics; // OMP3a\r\n  /** The map entries, indexed by key. */\r\n  entries?: Record<string, ObjectsMapEntry<TData>>; // OMP3b\r\n}\r\n\r\n/**\r\n * An ObjectsCounter object represents an incrementable and decrementable value\r\n * @spec OCN1\r\n */\r\nexport interface ObjectsCounter {\r\n  /** The value of the counter */\r\n  count?: number; // OCN2a\r\n}\r\n\r\n/**\r\n * An ObjectOperation describes an operation to be applied to an object on a channel.\r\n * @spec OOP1\r\n */\r\nexport interface ObjectOperation<TData> {\r\n  /** Defines the operation to be applied to the object. */\r\n  action: ObjectOperationAction; // OOP3a\r\n  /** The object ID of the object on a channel to which the operation should be applied. */\r\n  objectId: string; // OOP3b\r\n  /** The payload for the operation if it is an operation on a Map object type. */\r\n  mapOp?: ObjectsMapOp<TData>; // OOP3c\r\n  /** The payload for the operation if it is an operation on a Counter object type. */\r\n  counterOp?: ObjectsCounterOp; // OOP3d\r\n  /**\r\n   * The payload for the operation if the operation is MAP_CREATE.\r\n   * Defines the initial value for the Map object.\r\n   */\r\n  map?: ObjectsMap<TData>; // OOP3e\r\n  /**\r\n   * The payload for the operation if the operation is COUNTER_CREATE.\r\n   * Defines the initial value for the Counter object.\r\n   */\r\n  counter?: ObjectsCounter; // OOP3f\r\n  /**\r\n   * The nonce, must be present on create operations. This is the random part\r\n   * that has been hashed with the type and initial value to create the object ID.\r\n   */\r\n  nonce?: string; // OOP3g\r\n  /**\r\n   * The initial value of the object, represented as a JSON string.\r\n   * Used along with the nonce and timestamp to create the object ID.\r\n   *\r\n   * This field must be set by the client for MAP_CREATE and COUNTER_CREATE operations.\r\n   * The server uses it to verify the object ID, and after verification, the JSON string\r\n   * is decoded into the initial value for new Map or Counter objects.\r\n   *\r\n   * This field must not be read by the client if received from the server.\r\n   */\r\n  initialValue?: string; // OOP3h\r\n}\r\n\r\n/**\r\n * An ObjectState describes the instantaneous state of an object on a channel.\r\n * @spec OST1\r\n */\r\nexport interface ObjectState<TData> {\r\n  /** The identifier of the object. */\r\n  objectId: string; // OST2a\r\n  /** A map of serials keyed by a {@link ObjectMessage.siteCode}, representing the last operations applied to this object */\r\n  siteTimeserials: Record<string, string>; // OST2b\r\n  /** True if the object has been tombstoned. */\r\n  tombstone: boolean; // OST2c\r\n  /**\r\n   * The operation that created the object.\r\n   *\r\n   * Can be missing if create operation for the object is not known at this point.\r\n   */\r\n  createOp?: ObjectOperation<TData>; // OST2d\r\n  /**\r\n   * The data that represents the result of applying all operations to a Map object\r\n   * excluding the initial value from the create operation if it is a Map object type.\r\n   */\r\n  map?: ObjectsMap<TData>; // OST2e\r\n  /**\r\n   * The data that represents the result of applying all operations to a Counter object\r\n   * excluding the initial value from the create operation if it is a Counter object type.\r\n   */\r\n  counter?: ObjectsCounter; // OST2f\r\n}\r\n\r\nfunction encode(\r\n  message: Utils.Properties<ObjectMessage> | Utils.Properties<WireObjectMessage>,\r\n  utils: typeof Utils,\r\n  messageEncoding: typeof MessageEncoding,\r\n  encodeObjectDataFn: EncodeObjectDataFunction,\r\n): WireObjectMessage {\r\n  // deep copy the message to avoid mutating the original one.\r\n  // buffer values won't be correctly copied, so we will need to use the original message when encoding.\r\n  const result = Object.assign(new WireObjectMessage(utils, messageEncoding), copyMsg(message));\r\n\r\n  // encode \"object\" field\r\n  if (message.object?.map?.entries) {\r\n    result.object!.map!.entries = encodeMapEntries(message.object.map.entries, encodeObjectDataFn);\r\n  }\r\n\r\n  if (message.object?.createOp?.map?.entries) {\r\n    result.object!.createOp!.map!.entries = encodeMapEntries(message.object.createOp.map.entries, encodeObjectDataFn);\r\n  }\r\n\r\n  if (message.object?.createOp?.mapOp?.data) {\r\n    result.object!.createOp!.mapOp!.data = encodeObjectData(message.object.createOp.mapOp.data, encodeObjectDataFn);\r\n  }\r\n\r\n  // OOP5\r\n  // encode \"operation\" field\r\n  if (message.operation?.map?.entries) {\r\n    result.operation!.map!.entries = encodeMapEntries(message.operation.map.entries, encodeObjectDataFn);\r\n  }\r\n\r\n  if (message.operation?.mapOp?.data) {\r\n    result.operation!.mapOp!.data = encodeObjectData(message.operation.mapOp.data, encodeObjectDataFn);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction encodeMapEntries(\r\n  mapEntries: Record<string, ObjectsMapEntry<ObjectData | WireObjectData>>,\r\n  encodeFn: EncodeObjectDataFunction,\r\n): Record<string, ObjectsMapEntry<WireObjectData>> {\r\n  return Object.entries(mapEntries).reduce(\r\n    (acc, v) => {\r\n      const [key, entry] = v;\r\n      const encodedData = entry.data ? encodeObjectData(entry.data, encodeFn) : undefined;\r\n      acc[key] = {\r\n        ...entry,\r\n        data: encodedData,\r\n      };\r\n      return acc;\r\n    },\r\n    {} as Record<string, ObjectsMapEntry<WireObjectData>>,\r\n  );\r\n}\r\n\r\n/** @spec OD4 */\r\nfunction encodeObjectData(data: ObjectData | WireObjectData, encodeFn: EncodeObjectDataFunction): WireObjectData {\r\n  const encodedData = encodeFn(data);\r\n  return encodedData;\r\n}\r\n\r\n/**\r\n * Used to create an {@link ObjectOperation.initialValue} JSON string for *_CREATE operations,\r\n * based on the object operation message that contains the initial value for the object.\r\n */\r\nexport function createInitialValueJSONString(\r\n  operation: Partial<ObjectOperation<ObjectData>>,\r\n  client: BaseClient,\r\n): string {\r\n  // the object operation may contain user-provided data that requires encoding.\r\n  // for example, buffers must be encoded since the initial value will be represented as a JSON string.\r\n  // we can use ObjectMessage methods to encode the object operation.\r\n  const msg = ObjectMessage.fromValues(\r\n    // cast initialValue to ObjectOperation here, even though it may lack some properties\r\n    // that are usually present on ObjectOperation.\r\n    // this ObjectMessage instance is only used to get the encoded body,\r\n    // so it's ok for the operation field to be incomplete in this context.\r\n    // doing the type assertion here avoids the need to define a separate ObjectMessage\r\n    // type that supports a fully optional ObjectOperation.\r\n    { operation: operation as ObjectOperation<ObjectData> },\r\n    client.Utils,\r\n    client.MessageEncoding,\r\n  );\r\n  const wireMsg = msg.encode(client);\r\n\r\n  // get the encoded operation that is safe to be sent over the wire as a JSON string.\r\n  const { operation: encodedOperation } = wireMsg.encodeForWire(client.Utils.Format.json);\r\n\r\n  // finally, initialValue is the JSON string representation of the encoded operation.\r\n  return JSON.stringify(encodedOperation);\r\n}\r\n\r\nfunction strMsg(msg: any, className: string) {\r\n  let result = '[' + className;\r\n\r\n  for (const attr in msg) {\r\n    if (msg[attr] === undefined || attr === '_utils' || attr === '_messageEncoding') {\r\n      continue;\r\n    }\r\n\r\n    if (attr === 'operation' || attr === 'object' || attr === 'extras') {\r\n      result += `; ${attr}=${JSON.stringify(msg[attr])}`;\r\n    } else {\r\n      result += `; ${attr}=${msg[attr]}`;\r\n    }\r\n  }\r\n\r\n  result += ']';\r\n  return result;\r\n}\r\n\r\n/**\r\n * Deep copy public properties of an object message, using `JSON.parse(JSON.stringify(object))` for nested object fields like `operation` and `object`.\r\n *\r\n * Important: Buffer instances are not copied correctly using `JSON.parse(JSON.stringify(object))`, as they lose their type and become plain objects.\r\n * If you need access to the original Buffer values, use the original message instance instead.\r\n */\r\n\r\nfunction copyMsg(\r\n  msg: Utils.Properties<ObjectMessage | WireObjectMessage>,\r\n): Utils.Properties<ObjectMessage | WireObjectMessage> {\r\n  const result: Utils.Properties<ObjectMessage | WireObjectMessage> = {\r\n    id: msg.id,\r\n    clientId: msg.clientId,\r\n    connectionId: msg.connectionId,\r\n    timestamp: msg.timestamp,\r\n    serial: msg.serial,\r\n    serialTimestamp: msg.serialTimestamp,\r\n    siteCode: msg.siteCode,\r\n  };\r\n\r\n  if (msg.operation) {\r\n    result.operation = JSON.parse(JSON.stringify(msg.operation));\r\n  }\r\n  if (msg.object) {\r\n    result.object = JSON.parse(JSON.stringify(msg.object));\r\n  }\r\n  if (msg.extras) {\r\n    result.extras = JSON.parse(JSON.stringify(msg.extras));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction stringifyOperation(operation: ObjectOperation<ObjectData>): ObjectsApi.ObjectOperation {\r\n  return {\r\n    ...operation,\r\n    action: operationActions[operation.action] || 'unknown',\r\n    map: operation.map\r\n      ? {\r\n          ...operation.map,\r\n          semantics: operation.map.semantics != null ? mapSemantics[operation.map.semantics] || 'unknown' : undefined,\r\n        }\r\n      : undefined,\r\n  };\r\n}\r\n\r\n/**\r\n * A decoded {@link WireObjectMessage} message\r\n * @spec OM1\r\n * @internal\r\n */\r\nexport class ObjectMessage {\r\n  id?: string; // OM2a\r\n  clientId?: string; // OM2b\r\n  connectionId?: string; // OM2c\r\n  extras?: any; // OM2d\r\n  timestamp?: number; // OM2e\r\n  /**\r\n   * Describes an operation to be applied to an object.\r\n   *\r\n   * Mutually exclusive with the `object` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT`.\r\n   */\r\n  operation?: ObjectOperation<ObjectData>; // OM2f\r\n  /**\r\n   * Describes the instantaneous state of an object.\r\n   *\r\n   * Mutually exclusive with the `operation` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT_SYNC`.\r\n   */\r\n  object?: ObjectState<ObjectData>; // OM2g\r\n  /** An opaque string that uniquely identifies this object message. */\r\n  serial?: string; // OM2h\r\n  /** A timestamp from the {@link serial} field. */\r\n  serialTimestamp?: number; // OM2j\r\n  /** An opaque string used as a key to update the map of serial values on an object. */\r\n  siteCode?: string; // OM2i\r\n\r\n  constructor(\r\n    private _utils: typeof Utils,\r\n    private _messageEncoding: typeof MessageEncoding,\r\n  ) {}\r\n\r\n  static fromValues(\r\n    values: Utils.Properties<ObjectMessage>,\r\n    utils: typeof Utils,\r\n    messageEncoding: typeof MessageEncoding,\r\n  ): ObjectMessage {\r\n    return Object.assign(new ObjectMessage(utils, messageEncoding), values);\r\n  }\r\n\r\n  static fromValuesArray(\r\n    values: Utils.Properties<ObjectMessage>[],\r\n    utils: typeof Utils,\r\n    messageEncoding: typeof MessageEncoding,\r\n  ): ObjectMessage[] {\r\n    return values.map((x) => ObjectMessage.fromValues(x, utils, messageEncoding));\r\n  }\r\n\r\n  /**\r\n   * Protocol agnostic encoding of this ObjectMessage. Returns a new {@link WireObjectMessage} instance.\r\n   *\r\n   * Uses encoding functions from regular `Message` processing.\r\n   *\r\n   * @spec OM4\r\n   */\r\n  encode(client: BaseClient): WireObjectMessage {\r\n    const encodeObjectDataFn: EncodeObjectDataFunction = (data: ObjectData) => {\r\n      const encodedObjectData: WireObjectData = { objectId: data.objectId };\r\n\r\n      if (client.Platform.BufferUtils.isBuffer(data.value)) {\r\n        // bytes encoding happens later when WireObjectMessage is encoded for wire transmission\r\n        encodedObjectData.bytes = data.value;\r\n      } else if (typeof data.value === 'string') {\r\n        encodedObjectData.string = data.value; // OD4c4, OD4d4\r\n      } else if (typeof data.value === 'boolean') {\r\n        encodedObjectData.boolean = data.value; // OD4c1, OD4d1\r\n      } else if (typeof data.value === 'number') {\r\n        encodedObjectData.number = data.value; // OD4c3, OD4d3\r\n      } else if (typeof data.value === 'object' && data.value !== null) {\r\n        // OD4c5, OD4d5\r\n        encodedObjectData.json = JSON.stringify(data.value);\r\n      }\r\n\r\n      return encodedObjectData;\r\n    };\r\n\r\n    return encode(this, this._utils, this._messageEncoding, encodeObjectDataFn);\r\n  }\r\n\r\n  toString(): string {\r\n    return strMsg(this, 'ObjectMessage');\r\n  }\r\n\r\n  isOperationMessage(): boolean {\r\n    return this.operation != null;\r\n  }\r\n\r\n  isSyncMessage(): boolean {\r\n    return this.object != null;\r\n  }\r\n\r\n  toUserFacingMessage(channel: RealtimeChannel): ObjectsApi.ObjectMessage {\r\n    return {\r\n      id: this.id!,\r\n      clientId: this.clientId,\r\n      connectionId: this.connectionId,\r\n      timestamp: this.timestamp!,\r\n      channel: channel.name,\r\n      // we expose only operation messages to users, so operation field is always present\r\n      operation: stringifyOperation(this.operation!),\r\n      serial: this.serial,\r\n      serialTimestamp: this.serialTimestamp,\r\n      siteCode: this.siteCode,\r\n      extras: this.extras,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * An individual object message to be sent or received via the Ably Realtime service.\r\n * @spec OM1\r\n * @internal\r\n */\r\nexport class WireObjectMessage {\r\n  id?: string; // OM2a\r\n  clientId?: string; // OM2b\r\n  connectionId?: string; // OM2c\r\n  extras?: any; // OM2d\r\n  timestamp?: number; // OM2e\r\n  /**\r\n   * Describes an operation to be applied to an object.\r\n   *\r\n   * Mutually exclusive with the `object` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT`.\r\n   */\r\n  operation?: ObjectOperation<WireObjectData>; // OM2f\r\n  /**\r\n   * Describes the instantaneous state of an object.\r\n   *\r\n   * Mutually exclusive with the `operation` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT_SYNC`.\r\n   */\r\n  object?: ObjectState<WireObjectData>; // OM2g\r\n  /** An opaque string that uniquely identifies this object message. */\r\n  serial?: string; // OM2h\r\n  /** A timestamp from the {@link serial} field. */\r\n  serialTimestamp?: number; // OM2j\r\n  /** An opaque string used as a key to update the map of serial values on an object. */\r\n  siteCode?: string; // OM2i\r\n\r\n  constructor(\r\n    private _utils: typeof Utils,\r\n    private _messageEncoding: typeof MessageEncoding,\r\n  ) {}\r\n\r\n  static fromValues(\r\n    values: Utils.Properties<WireObjectMessage>,\r\n    utils: typeof Utils,\r\n    messageEncoding: typeof MessageEncoding,\r\n  ): WireObjectMessage {\r\n    return Object.assign(new WireObjectMessage(utils, messageEncoding), values);\r\n  }\r\n\r\n  static fromValuesArray(\r\n    values: Utils.Properties<WireObjectMessage>[],\r\n    utils: typeof Utils,\r\n    messageEncoding: typeof MessageEncoding,\r\n  ): WireObjectMessage[] {\r\n    return values.map((x) => WireObjectMessage.fromValues(x, utils, messageEncoding));\r\n  }\r\n\r\n  /**\r\n   * Encodes WireObjectMessage for wire transmission. Does not mutate the provided WireObjectMessage.\r\n   *\r\n   * Uses encoding functions from regular `Message` processing.\r\n   */\r\n  encodeForWire(format: Utils.Format): WireObjectMessage {\r\n    const encodeObjectDataFn: EncodeObjectDataFunction = (data: WireObjectData) => {\r\n      if (data.bytes != null) {\r\n        // OD4c2, OD4d2\r\n        const result = this._messageEncoding.encodeDataForWire(data.bytes, null, format);\r\n        // no need to set the encoding\r\n        return { ...data, bytes: result.data };\r\n      }\r\n\r\n      return { ...data };\r\n    };\r\n\r\n    return encode(this, this._utils, this._messageEncoding, encodeObjectDataFn);\r\n  }\r\n\r\n  /**\r\n   * Decodes this WireObjectMessage and returns a new {@link ObjectMessage} instance.\r\n   *\r\n   * Format is used to decode the bytes value as it's implicitly encoded depending on the protocol used:\r\n   * - json: bytes are Base64-encoded string\r\n   * - msgpack: bytes have a binary representation and don't need to be decoded\r\n   *\r\n   * @spec OM5\r\n   */\r\n  decode(client: BaseClient, format: Utils.Format | undefined): ObjectMessage {\r\n    // deep copy the message to avoid mutating the original one.\r\n    // buffer values won't be correctly copied, so we will need to use the original message when decoding.\r\n    const result = Object.assign(new ObjectMessage(this._utils, this._messageEncoding), copyMsg(this));\r\n\r\n    try {\r\n      // decode \"object\" field\r\n      if (this.object?.map?.entries) {\r\n        result.object!.map!.entries = this._decodeMapEntries(this.object.map.entries, client, format);\r\n      }\r\n\r\n      if (this.object?.createOp?.map?.entries) {\r\n        result.object!.createOp!.map!.entries = this._decodeMapEntries(\r\n          this.object.createOp.map.entries,\r\n          client,\r\n          format,\r\n        );\r\n      }\r\n\r\n      if (this.object?.createOp?.mapOp?.data) {\r\n        result.object!.createOp!.mapOp!.data = this._decodeObjectData(this.object.createOp.mapOp.data, client, format);\r\n      }\r\n\r\n      // decode \"operation\" field\r\n      if (this.operation?.map?.entries) {\r\n        result.operation!.map!.entries = this._decodeMapEntries(this.operation.map.entries, client, format);\r\n      }\r\n\r\n      if (this.operation?.mapOp?.data) {\r\n        result.operation!.mapOp!.data = this._decodeObjectData(this.operation.mapOp.data, client, format);\r\n      }\r\n    } catch (error) {\r\n      client.Logger.logAction(\r\n        client.logger,\r\n        client.Logger.LOG_ERROR,\r\n        'WireObjectMessage.decode()',\r\n        this._utils.inspectError(error),\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify().\r\n   *\r\n   * This will prepare the message to be transmitted over the wire to Ably.\r\n   * It will encode the data payload according to the wire protocol used on the client.\r\n   */\r\n  toJSON() {\r\n    // we can infer the format used by client by inspecting with what arguments this method was called.\r\n    // if JSON protocol is being used, the JSON.stringify() will be called and this toJSON() method will have a non-empty arguments list.\r\n    // MSGPack protocol implementation also calls toJSON(), but with an empty arguments list.\r\n    const format = arguments.length > 0 ? this._utils.Format.json : this._utils.Format.msgpack;\r\n    const { _utils, _messageEncoding, ...publicProps } = this.encodeForWire(format);\r\n    return publicProps;\r\n  }\r\n\r\n  toString(): string {\r\n    return strMsg(this, 'WireObjectMessage');\r\n  }\r\n\r\n  /** @spec OM3 */\r\n  getMessageSize(): number {\r\n    let size = 0;\r\n\r\n    // OM3a\r\n    size += this.clientId?.length ?? 0; // OM3f\r\n    if (this.operation) {\r\n      size += this._getObjectOperationSize(this.operation); // OM3b\r\n    }\r\n    if (this.object) {\r\n      size += this._getObjectStateSize(this.object); // OM3c\r\n    }\r\n    if (this.extras) {\r\n      size += JSON.stringify(this.extras).length; // OM3d\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  /** @spec OOP4 */\r\n  private _getObjectOperationSize(operation: ObjectOperation<WireObjectData>): number {\r\n    let size = 0;\r\n\r\n    // OOP4a\r\n    if (operation.mapOp) {\r\n      size += this._getMapOpSize(operation.mapOp); // OOP4b\r\n    }\r\n    if (operation.counterOp) {\r\n      size += this._getCounterOpSize(operation.counterOp); // OOP4c\r\n    }\r\n    if (operation.map) {\r\n      size += this._getObjectMapSize(operation.map); // OOP4d\r\n    }\r\n    if (operation.counter) {\r\n      size += this._getObjectCounterSize(operation.counter); // OOP4e\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  /** @spec OST3 */\r\n  private _getObjectStateSize(obj: ObjectState<WireObjectData>): number {\r\n    let size = 0;\r\n\r\n    // OST3a\r\n    if (obj.map) {\r\n      size += this._getObjectMapSize(obj.map); // OST3b\r\n    }\r\n    if (obj.counter) {\r\n      size += this._getObjectCounterSize(obj.counter); // OST3c\r\n    }\r\n    if (obj.createOp) {\r\n      size += this._getObjectOperationSize(obj.createOp); // OST3d\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  /** @spec OMP4 */\r\n  private _getObjectMapSize(map: ObjectsMap<WireObjectData>): number {\r\n    let size = 0;\r\n\r\n    // OMP4a\r\n    Object.entries(map.entries ?? {}).forEach(([key, entry]) => {\r\n      size += key?.length ?? 0; // OMP4a1\r\n      if (entry) {\r\n        size += this._getMapEntrySize(entry); // OMP4a2\r\n      }\r\n    });\r\n\r\n    return size;\r\n  }\r\n\r\n  /** @spec OCN3 */\r\n  private _getObjectCounterSize(counter: ObjectsCounter): number {\r\n    // OCN3b\r\n    if (counter.count == null) {\r\n      return 0;\r\n    }\r\n\r\n    // OCN3a\r\n    return 8;\r\n  }\r\n\r\n  /** @spec OME3 */\r\n  private _getMapEntrySize(entry: ObjectsMapEntry<WireObjectData>): number {\r\n    let size = 0;\r\n\r\n    // OME3a\r\n    if (entry.data) {\r\n      size += this._getObjectDataSize(entry.data); // OME3b\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  /** @spec OMO3 */\r\n  private _getMapOpSize(mapOp: ObjectsMapOp<WireObjectData>): number {\r\n    let size = 0;\r\n\r\n    // OMO3a\r\n    size += mapOp.key?.length ?? 0; // OMO3d\r\n    if (mapOp.data) {\r\n      size += this._getObjectDataSize(mapOp.data); // OMO3b\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  /** @spec OCO3 */\r\n  private _getCounterOpSize(operation: ObjectsCounterOp): number {\r\n    // OCO3b\r\n    if (operation.amount == null) {\r\n      return 0;\r\n    }\r\n\r\n    // OCO3a\r\n    return 8;\r\n  }\r\n\r\n  /** @spec OD3 */\r\n  private _getObjectDataSize(data: WireObjectData): number {\r\n    let size = 0;\r\n\r\n    // OD3a\r\n    if (data.boolean != null) {\r\n      size += this._utils.dataSizeBytes(data.boolean); // OD3b\r\n    }\r\n    if (data.bytes != null) {\r\n      size += this._utils.dataSizeBytes(data.bytes); // OD3c\r\n    }\r\n    if (data.number != null) {\r\n      size += this._utils.dataSizeBytes(data.number); // OD3d\r\n    }\r\n    if (data.string != null) {\r\n      size += this._utils.dataSizeBytes(data.string); // OD3e\r\n    }\r\n    if (data.json != null) {\r\n      size += this._utils.dataSizeBytes(data.json);\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  private _decodeMapEntries(\r\n    mapEntries: Record<string, ObjectsMapEntry<WireObjectData>>,\r\n    client: BaseClient,\r\n    format: Utils.Format | undefined,\r\n  ): Record<string, ObjectsMapEntry<ObjectData>> {\r\n    return Object.entries(mapEntries).reduce(\r\n      (acc, v) => {\r\n        const [key, entry] = v;\r\n        const decodedData = entry.data ? this._decodeObjectData(entry.data, client, format) : undefined;\r\n        acc[key] = {\r\n          ...entry,\r\n          data: decodedData,\r\n        };\r\n        return acc;\r\n      },\r\n      {} as Record<string, ObjectsMapEntry<ObjectData>>,\r\n    );\r\n  }\r\n\r\n  /** @spec OD5 */\r\n  private _decodeObjectData(\r\n    objectData: WireObjectData,\r\n    client: BaseClient,\r\n    format: Utils.Format | undefined,\r\n  ): ObjectData {\r\n    try {\r\n      if (objectData.objectId != null) {\r\n        return {\r\n          objectId: objectData.objectId,\r\n        };\r\n      }\r\n\r\n      let decodedBytes: Buffer | ArrayBuffer | undefined;\r\n      if (objectData.bytes != null) {\r\n        decodedBytes =\r\n          format === 'msgpack'\r\n            ? // OD5a1 - connection is using msgpack protocol, bytes are already a buffer\r\n              (objectData.bytes as Buffer | ArrayBuffer)\r\n            : // OD5b2 - connection is using JSON protocol, Base64-decode bytes value\r\n              client.Platform.BufferUtils.base64Decode(String(objectData.bytes));\r\n      }\r\n\r\n      let decodedJson: ObjectsApi.JsonObject | ObjectsApi.JsonArray | undefined;\r\n      if (objectData.json != null) {\r\n        decodedJson = JSON.parse(objectData.json); // OD5a2, OD5b3\r\n      }\r\n\r\n      return {\r\n        value: decodedBytes ?? decodedJson ?? objectData.boolean ?? objectData.number ?? objectData.string,\r\n      };\r\n    } catch (error) {\r\n      client.Logger.logAction(\r\n        client.logger,\r\n        client.Logger.LOG_ERROR,\r\n        'WireObjectMessage._decodeObjectData()',\r\n        this._utils.inspectError(error),\r\n      );\r\n      // object data decoding has failed, return the data as is.\r\n      return {\r\n        ...objectData,\r\n      } as ObjectData;\r\n    }\r\n  }\r\n}\r\n", "import { __livetype } from '../../../ably';\r\nimport { LiveCounter } from '../../../liveobjects';\r\nimport { ObjectId } from './objectid';\r\nimport {\r\n  createInitialValueJSONString,\r\n  ObjectData,\r\n  ObjectMessage,\r\n  ObjectOperation,\r\n  ObjectOperationAction,\r\n} from './objectmessage';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\n/**\r\n * A value type class that serves as a simple container for LiveCounter data.\r\n * Contains sufficient information for the client to produce a COUNTER_CREATE operation\r\n * for the LiveCounter object.\r\n *\r\n * Properties of this class are immutable after construction and the instance\r\n * will be frozen to prevent mutation.\r\n */\r\nexport class LiveCounterValueType implements LiveCounter {\r\n  declare readonly [__livetype]: 'LiveCounter'; // type-only, unique symbol to satisfy branded interfaces, no JS emitted\r\n  private readonly _livetype = 'LiveCounter'; // use a runtime property to provide a reliable cross-bundle type identification instead of `instanceof` operator\r\n  private readonly _count: number;\r\n\r\n  private constructor(count: number) {\r\n    this._count = count;\r\n    Object.freeze(this);\r\n  }\r\n\r\n  static create(initialCount: number = 0): LiveCounter {\r\n    // We can't directly import the ErrorInfo class from the core library into the plugin (as this would bloat the plugin size),\r\n    // and, since we're in a user-facing static method, we can't expect a user to pass a client library instance, as this would make the API ugly.\r\n    // Since we can't use ErrorInfo here, we won't do any validation at this step; instead, validation will happen in the mutation methods\r\n    // when we try to create this object.\r\n\r\n    return new LiveCounterValueType(initialCount);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static instanceof(value: unknown): value is LiveCounterValueType {\r\n    return typeof value === 'object' && value !== null && (value as LiveCounterValueType)._livetype === 'LiveCounter';\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static async createCounterCreateMessage(\r\n    realtimeObject: RealtimeObject,\r\n    value: LiveCounterValueType,\r\n  ): Promise<ObjectMessage> {\r\n    const client = realtimeObject.getClient();\r\n    const count = value._count;\r\n\r\n    if (count !== undefined && (typeof count !== 'number' || !Number.isFinite(count))) {\r\n      throw new client.ErrorInfo('Counter value should be a valid number', 40003, 400);\r\n    }\r\n\r\n    const initialValueOperation = LiveCounterValueType.createInitialValueOperation(count);\r\n    const initialValueJSONString = createInitialValueJSONString(initialValueOperation, client);\r\n    const nonce = client.Utils.cheapRandStr();\r\n    const msTimestamp = await client.getTimestamp(true);\r\n\r\n    const objectId = ObjectId.fromInitialValue(\r\n      client.Platform,\r\n      'counter',\r\n      initialValueJSONString,\r\n      nonce,\r\n      msTimestamp,\r\n    ).toString();\r\n\r\n    const msg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          ...initialValueOperation,\r\n          action: ObjectOperationAction.COUNTER_CREATE,\r\n          objectId,\r\n          nonce,\r\n          initialValue: initialValueJSONString,\r\n        } as ObjectOperation<ObjectData>,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return msg;\r\n  }\r\n\r\n  private static createInitialValueOperation(count?: number): Pick<ObjectOperation<ObjectData>, 'counter'> {\r\n    return {\r\n      counter: {\r\n        count: count ?? 0,\r\n      },\r\n    };\r\n  }\r\n}\r\n", "var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "export const ROOT_OBJECT_ID = 'root';\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type EventEmitter from 'common/lib/util/eventemitter';\r\nimport type { EventCallback, Subscription } from '../../../ably';\r\nimport { ROOT_OBJECT_ID } from './constants';\r\nimport { InstanceEvent } from './instance';\r\nimport { ObjectData, ObjectMessage, ObjectOperation } from './objectmessage';\r\nimport { PathEvent } from './pathobjectsubscriptionregister';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\nexport enum LiveObjectSubscriptionEvent {\r\n  updated = 'updated',\r\n}\r\n\r\nexport interface LiveObjectData {\r\n  data: any;\r\n}\r\n\r\nexport interface LiveObjectUpdate {\r\n  _type: 'LiveMapUpdate' | 'LiveCounterUpdate';\r\n  /** Delta of the change */\r\n  update: any;\r\n  /** Object message that caused an update to an object, if available */\r\n  objectMessage?: ObjectMessage;\r\n  /** Indicates whether this update is a result of a tombstone (delete) operation. */\r\n  tombstone?: boolean;\r\n}\r\n\r\nexport interface LiveObjectUpdateNoop {\r\n  // have optional update field with undefined type so it's not possible to create a noop object with a meaningful update property.\r\n  update?: undefined;\r\n  noop: true;\r\n}\r\n\r\nexport abstract class LiveObject<\r\n  TData extends LiveObjectData = LiveObjectData,\r\n  TUpdate extends LiveObjectUpdate = LiveObjectUpdate,\r\n> {\r\n  protected _client: BaseClient;\r\n  protected _subscriptions: EventEmitter;\r\n  protected _objectId: string;\r\n  /**\r\n   * Represents an aggregated value for an object, which combines the initial value for an object from the create operation,\r\n   * and all object operations applied to the object.\r\n   */\r\n  protected _dataRef: TData;\r\n  protected _siteTimeserials: Record<string, string>;\r\n  protected _createOperationIsMerged: boolean;\r\n  private _tombstone: boolean;\r\n  private _tombstonedAt: number | undefined;\r\n  /**\r\n   * Track parent references - which LiveMap objects contain this object and at which keys.\r\n   * Multiple parents can reference the same object, so we use a Map of parent to Set of keys for efficient lookups.\r\n   */\r\n  private _parentReferences: Map<LiveObject, Set<string>>;\r\n\r\n  protected constructor(\r\n    protected _realtimeObject: RealtimeObject,\r\n    objectId: string,\r\n  ) {\r\n    this._client = this._realtimeObject.getClient();\r\n    this._subscriptions = new this._client.EventEmitter(this._client.logger);\r\n    this._objectId = objectId;\r\n    this._dataRef = this._getZeroValueData();\r\n    // use empty map of serials by default, so any future operation can be applied to this object\r\n    this._siteTimeserials = {};\r\n    this._createOperationIsMerged = false;\r\n    this._tombstone = false;\r\n    this._parentReferences = new Map<LiveObject, Set<string>>();\r\n  }\r\n\r\n  subscribe(listener: EventCallback<InstanceEvent>): Subscription {\r\n    this._subscriptions.on(LiveObjectSubscriptionEvent.updated, listener);\r\n\r\n    const unsubscribe = () => {\r\n      this._subscriptions.off(LiveObjectSubscriptionEvent.updated, listener);\r\n    };\r\n\r\n    return { unsubscribe };\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getObjectId(): string {\r\n    return this._objectId;\r\n  }\r\n\r\n  /**\r\n   * Emits the {@link LiveObjectSubscriptionEvent.updated} event with provided update object if it isn't a noop.\r\n   * Also notifies the path object subscriptions about path-based events.\r\n   *\r\n   * @internal\r\n   */\r\n  notifyUpdated(update: TUpdate | LiveObjectUpdateNoop): void {\r\n    if (this._isNoopUpdate(update)) {\r\n      // do not emit update events for noop updates\r\n      return;\r\n    }\r\n\r\n    this._notifyInstanceSubscriptions(update);\r\n    this._notifyPathSubscriptions(update);\r\n\r\n    if (update.tombstone) {\r\n      // deregister all listeners if update was a result of a tombstone operation\r\n      this._subscriptions.off();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the object's data, cancels any buffered operations and sets the tombstone flag to `true`.\r\n   *\r\n   * @internal\r\n   */\r\n  tombstone(objectMessage: ObjectMessage): TUpdate {\r\n    this._tombstone = true;\r\n    if (objectMessage.serialTimestamp != null) {\r\n      this._tombstonedAt = objectMessage.serialTimestamp;\r\n    } else {\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MINOR,\r\n        'LiveObject.tombstone()',\r\n        `object has been tombstoned but no \"serialTimestamp\" found in the message, using local clock instead; objectId=${this.getObjectId()}`,\r\n      );\r\n      this._tombstonedAt = Date.now(); // best-effort estimate since no timestamp provided by the server\r\n    }\r\n    const update = this.clearData();\r\n    update.objectMessage = objectMessage;\r\n    update.tombstone = true;\r\n\r\n    return update;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  isTombstoned(): boolean {\r\n    return this._tombstone;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  tombstonedAt(): number | undefined {\r\n    return this._tombstonedAt;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  clearData(): TUpdate {\r\n    const previousDataRef = this._dataRef;\r\n    this._dataRef = this._getZeroValueData();\r\n    return this._updateFromDataDiff(previousDataRef, this._dataRef);\r\n  }\r\n\r\n  /**\r\n   * Add a parent reference indicating that this object is referenced by the given parent LiveMap at the specified key.\r\n   *\r\n   * @internal\r\n   */\r\n  addParentReference(parent: LiveObject, key: string): void {\r\n    const keys = this._parentReferences.get(parent);\r\n\r\n    if (keys) {\r\n      keys.add(key);\r\n    } else {\r\n      this._parentReferences.set(parent, new Set([key]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a parent reference indicating that this object is no longer referenced by the given parent LiveMap at the specified key.\r\n   *\r\n   * @internal\r\n   */\r\n  removeParentReference(parent: LiveObject, key: string): void {\r\n    const keys = this._parentReferences.get(parent);\r\n\r\n    if (keys) {\r\n      keys.delete(key);\r\n      // If no more keys for this parent, remove the parent entry entirely\r\n      if (keys.size === 0) {\r\n        this._parentReferences.delete(parent);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove all parent references for a specific parent (when parent is being deleted or cleared).\r\n   *\r\n   * @internal\r\n   */\r\n  removeParentReferenceAll(parent: LiveObject): void {\r\n    this._parentReferences.delete(parent);\r\n  }\r\n\r\n  /**\r\n   * Clears all parent references for this object.\r\n   *\r\n   * @internal\r\n   */\r\n  clearParentReferences(): void {\r\n    this._parentReferences.clear();\r\n  }\r\n\r\n  /**\r\n   * Calculates and returns all possible paths to this object from the root object by traversing up the parent hierarchy.\r\n   * Uses iterative DFS with an explicit stack. Each path is represented as an array of keys from root to this object.\r\n   *\r\n   * @internal\r\n   */\r\n  getFullPaths(): string[][] {\r\n    const paths: string[][] = [];\r\n\r\n    const stack: { obj: LiveObject; currentPath: string[]; visited: Set<LiveObject> }[] = [\r\n      { obj: this, currentPath: [], visited: new Set() },\r\n    ];\r\n\r\n    while (stack.length > 0) {\r\n      const { obj, currentPath, visited } = stack.pop()!;\r\n\r\n      // Check for cyclic references\r\n      if (visited.has(obj)) {\r\n        continue; // Skip this path to prevent infinite loops\r\n      }\r\n\r\n      // Create new visited set for this path\r\n      const newVisited = new Set(visited);\r\n      newVisited.add(obj);\r\n\r\n      if (obj.getObjectId() === ROOT_OBJECT_ID) {\r\n        // Reached the root object, add the current path\r\n        paths.push(currentPath);\r\n        continue;\r\n      }\r\n\r\n      // Otherwise, add work items for each parent-key combination to the stack\r\n      for (const [parent, keys] of obj._parentReferences) {\r\n        for (const key of keys) {\r\n          stack.push({\r\n            obj: parent,\r\n            currentPath: [key, ...currentPath],\r\n            visited: newVisited,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return paths;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the given serial indicates that the operation to which it belongs should be applied to the object.\r\n   *\r\n   * An operation should be applied if its serial is strictly greater than the serial in the `siteTimeserials` map for the same site.\r\n   * If `siteTimeserials` map does not contain a serial for the same site, the operation should be applied.\r\n   */\r\n  protected _canApplyOperation(opSerial: string | undefined, opSiteCode: string | undefined): boolean {\r\n    if (!opSerial) {\r\n      throw new this._client.ErrorInfo(`Invalid serial: ${opSerial}`, 92000, 500);\r\n    }\r\n\r\n    if (!opSiteCode) {\r\n      throw new this._client.ErrorInfo(`Invalid site code: ${opSiteCode}`, 92000, 500);\r\n    }\r\n\r\n    const siteSerial = this._siteTimeserials[opSiteCode];\r\n    return !siteSerial || opSerial > siteSerial;\r\n  }\r\n\r\n  protected _applyObjectDelete(objectMessage: ObjectMessage): TUpdate {\r\n    return this.tombstone(objectMessage);\r\n  }\r\n\r\n  private _notifyInstanceSubscriptions(update: TUpdate): void {\r\n    const event: InstanceEvent = {\r\n      // Do not expose object sync messages as they do not represent a single operation on an object\r\n      message: update.objectMessage?.isOperationMessage() ? update.objectMessage : undefined,\r\n    };\r\n    this._subscriptions.emit(LiveObjectSubscriptionEvent.updated, event);\r\n  }\r\n\r\n  /**\r\n   * Notifies path-based subscriptions about changes to this object.\r\n   * For LiveMapUpdate events, also creates non-bubbling events for each updated key.\r\n   */\r\n  private _notifyPathSubscriptions(update: TUpdate): void {\r\n    const paths = this.getFullPaths();\r\n\r\n    if (paths.length === 0) {\r\n      // No paths to this object, skip notification\r\n      return;\r\n    }\r\n\r\n    // Do not expose object sync messages as they do not represent a single operation on an object\r\n    const operationObjectMessage = update.objectMessage?.isOperationMessage() ? update.objectMessage : undefined;\r\n    const pathEvents: PathEvent[] = paths.map((path) => ({\r\n      path,\r\n      message: operationObjectMessage,\r\n      bubbles: true,\r\n    }));\r\n\r\n    // For LiveMapUpdate, also create non-bubbling events for each updated key\r\n    if (update._type === 'LiveMapUpdate') {\r\n      const updatedKeys = Object.keys(update.update);\r\n\r\n      for (const key of updatedKeys) {\r\n        for (const basePath of paths) {\r\n          pathEvents.push({\r\n            path: [...basePath, key],\r\n            message: operationObjectMessage,\r\n            bubbles: false,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    this._realtimeObject.getPathObjectSubscriptionRegister().notifyPathEvents(pathEvents);\r\n  }\r\n\r\n  private _isNoopUpdate(update: TUpdate | LiveObjectUpdateNoop): update is LiveObjectUpdateNoop {\r\n    return (update as LiveObjectUpdateNoop).noop === true;\r\n  }\r\n\r\n  /**\r\n   * Apply object operation message on this LiveObject.\r\n   *\r\n   * @internal\r\n   */\r\n  abstract applyOperation(op: ObjectOperation<ObjectData>, msg: ObjectMessage): void;\r\n  /**\r\n   * Overrides internal data for this LiveObject with object state from the given object message.\r\n   * Provided object state should hold a valid data for current LiveObject, e.g. counter data for LiveCounter, map data for LiveMap.\r\n   *\r\n   * Object states are received during sync sequence, and sync sequence is a source of truth for the current state of the objects,\r\n   * so we can use the data received from the sync sequence directly and override any data values or site serials this LiveObject has\r\n   * without the need to merge them.\r\n   *\r\n   * Returns an update object that describes the changes applied based on the object's previous value.\r\n   *\r\n   * @internal\r\n   */\r\n  abstract overrideWithObjectState(objectMessage: ObjectMessage): TUpdate | LiveObjectUpdateNoop;\r\n  /**\r\n   * @internal\r\n   */\r\n  abstract onGCInterval(): void;\r\n\r\n  protected abstract _getZeroValueData(): TData;\r\n  /**\r\n   * Calculate the update object based on the current LiveObject data and incoming new data.\r\n   */\r\n  protected abstract _updateFromDataDiff(prevDataRef: TData, newDataRef: TData): TUpdate;\r\n  /**\r\n   * Merges the initial data from the create operation into the LiveObject.\r\n   *\r\n   * Client SDKs do not need to keep around the object operation that created the object,\r\n   * so we can merge the initial data the first time we receive it for the object,\r\n   * and work with aggregated value after that.\r\n   *\r\n   * This saves us from needing to merge the initial value with operations applied to\r\n   * the object every time the object is read.\r\n   */\r\n  protected abstract _mergeInitialDataFromCreateOperation(\r\n    objectOperation: ObjectOperation<ObjectData>,\r\n    msg: ObjectMessage,\r\n  ): TUpdate;\r\n}\r\n", "import { __livetype } from '../../../ably';\r\nimport { LiveCounter as PublicLiveCounter } from '../../../liveobjects';\r\nimport { LiveObject, LiveObjectData, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\r\nimport { ObjectData, ObjectMessage, ObjectOperation, ObjectOperationAction, ObjectsCounterOp } from './objectmessage';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\nexport interface LiveCounterData extends LiveObjectData {\r\n  data: number; // RTLC3\r\n}\r\n\r\nexport interface LiveCounterUpdate extends LiveObjectUpdate {\r\n  update: { amount: number };\r\n  _type: 'LiveCounterUpdate';\r\n}\r\n\r\n/** @spec RTLC1, RTLC2 */\r\nexport class LiveCounter extends LiveObject<LiveCounterData, LiveCounterUpdate> implements PublicLiveCounter {\r\n  declare readonly [__livetype]: 'LiveCounter'; // type-only, unique symbol to satisfy branded interfaces, no JS emitted\r\n\r\n  /**\r\n   * Returns a {@link LiveCounter} instance with a 0 value.\r\n   *\r\n   * @internal\r\n   * @spec RTLC4\r\n   */\r\n  static zeroValue(realtimeObject: RealtimeObject, objectId: string): LiveCounter {\r\n    return new LiveCounter(realtimeObject, objectId);\r\n  }\r\n\r\n  /**\r\n   * Returns a {@link LiveCounter} instance based on the provided object state.\r\n   * The provided object state must hold a valid counter object data.\r\n   *\r\n   * @internal\r\n   */\r\n  static fromObjectState(realtimeObject: RealtimeObject, objectMessage: ObjectMessage): LiveCounter {\r\n    const obj = new LiveCounter(realtimeObject, objectMessage.object!.objectId);\r\n    obj.overrideWithObjectState(objectMessage);\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static createCounterIncMessage(realtimeObject: RealtimeObject, objectId: string, amount: number): ObjectMessage {\r\n    const client = realtimeObject.getClient();\r\n\r\n    if (typeof amount !== 'number' || !Number.isFinite(amount)) {\r\n      throw new client.ErrorInfo('Counter value increment should be a valid number', 40003, 400);\r\n    }\r\n\r\n    const msg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          action: ObjectOperationAction.COUNTER_INC,\r\n          objectId,\r\n          counterOp: { amount },\r\n        } as ObjectOperation<ObjectData>,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return msg;\r\n  }\r\n\r\n  /** @spec RTLC5 */\r\n  value(): number {\r\n    return this._dataRef.data; // RTLC5c\r\n  }\r\n\r\n  /**\r\n   * Send a COUNTER_INC operation to the realtime system to increment a value on this LiveCounter object.\r\n   *\r\n   * This does not modify the underlying data of this LiveCounter object. Instead, the change will be applied when\r\n   * the published COUNTER_INC operation is echoed back to the client and applied to the object following the regular\r\n   * operation application procedure.\r\n   *\r\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message.\r\n   */\r\n  async increment(amount: number): Promise<void> {\r\n    const msg = LiveCounter.createCounterIncMessage(this._realtimeObject, this.getObjectId(), amount);\r\n    return this._realtimeObject.publish([msg]);\r\n  }\r\n\r\n  /**\r\n   * An alias for calling {@link LiveCounter.increment | LiveCounter.increment(-amount)}\r\n   */\r\n  async decrement(amount: number): Promise<void> {\r\n    // do an explicit type safety check here before negating the amount value,\r\n    // so we don't unintentionally change the type sent by a user\r\n    if (typeof amount !== 'number' || !Number.isFinite(amount)) {\r\n      throw new this._client.ErrorInfo('Counter value decrement should be a valid number', 40003, 400);\r\n    }\r\n\r\n    return this.increment(-amount);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  applyOperation(op: ObjectOperation<ObjectData>, msg: ObjectMessage): void {\r\n    if (op.objectId !== this.getObjectId()) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot apply object operation with objectId=${op.objectId}, to this LiveCounter with objectId=${this.getObjectId()}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    const opSerial = msg.serial!;\r\n    const opSiteCode = msg.siteCode!;\r\n    if (!this._canApplyOperation(opSerial, opSiteCode)) {\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveCounter.applyOperation()',\r\n        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${this._siteTimeserials[opSiteCode]?.toString()}; objectId=${this.getObjectId()}`,\r\n      );\r\n      return;\r\n    }\r\n    // should update stored site serial immediately. doesn't matter if we successfully apply the op,\r\n    // as it's important to mark that the op was processed by the object\r\n    this._siteTimeserials[opSiteCode] = opSerial;\r\n\r\n    if (this.isTombstoned()) {\r\n      // this object is tombstoned so the operation cannot be applied\r\n      return;\r\n    }\r\n\r\n    let update: LiveCounterUpdate | LiveObjectUpdateNoop;\r\n    switch (op.action) {\r\n      case ObjectOperationAction.COUNTER_CREATE:\r\n        update = this._applyCounterCreate(op, msg);\r\n        break;\r\n\r\n      case ObjectOperationAction.COUNTER_INC:\r\n        if (this._client.Utils.isNil(op.counterOp)) {\r\n          this._throwNoPayloadError(op);\r\n          // leave an explicit return here, so that TS knows that update object is always set after the switch statement.\r\n          return;\r\n        } else {\r\n          update = this._applyCounterInc(op.counterOp, msg);\r\n        }\r\n        break;\r\n\r\n      case ObjectOperationAction.OBJECT_DELETE:\r\n        update = this._applyObjectDelete(msg);\r\n        break;\r\n\r\n      default:\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n    }\r\n\r\n    this.notifyUpdated(update);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * @spec RTLC6\r\n   */\r\n  overrideWithObjectState(objectMessage: ObjectMessage): LiveCounterUpdate | LiveObjectUpdateNoop {\r\n    const objectState = objectMessage.object;\r\n    if (objectState == null) {\r\n      throw new this._client.ErrorInfo(`Missing object state; LiveCounter objectId=${this.getObjectId()}`, 92000, 500);\r\n    }\r\n\r\n    if (objectState.objectId !== this.getObjectId()) {\r\n      throw new this._client.ErrorInfo(\r\n        `Invalid object state: object state objectId=${objectState.objectId}; LiveCounter objectId=${this.getObjectId()}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    if (!this._client.Utils.isNil(objectState.createOp)) {\r\n      // it is expected that create operation can be missing in the object state, so only validate it when it exists\r\n      if (objectState.createOp.objectId !== this.getObjectId()) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp objectId=${objectState.createOp?.objectId}; LiveCounter objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n\r\n      if (objectState.createOp.action !== ObjectOperationAction.COUNTER_CREATE) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp action=${objectState.createOp?.action}; LiveCounter objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n    }\r\n\r\n    // object's site serials are still updated even if it is tombstoned, so always use the site serials received from the operation.\r\n    // should default to empty map if site serials do not exist on the object state, so that any future operation may be applied to this object.\r\n    this._siteTimeserials = objectState.siteTimeserials ?? {}; // RTLC6a\r\n\r\n    if (this.isTombstoned()) {\r\n      // this object is tombstoned. this is a terminal state which can't be overridden. skip the rest of object state message processing\r\n      return { noop: true };\r\n    }\r\n\r\n    const previousDataRef = this._dataRef;\r\n    let update: LiveCounterUpdate;\r\n    if (objectState.tombstone) {\r\n      // tombstone this object and ignore the data from the object state message\r\n      update = this.tombstone(objectMessage);\r\n    } else {\r\n      // otherwise override data for this object with data from the object state\r\n      this._createOperationIsMerged = false; // RTLC6b\r\n      this._dataRef = { data: objectState.counter?.count ?? 0 }; // RTLC6c\r\n      // RTLC6d\r\n      if (!this._client.Utils.isNil(objectState.createOp)) {\r\n        this._mergeInitialDataFromCreateOperation(objectState.createOp, objectMessage);\r\n      }\r\n\r\n      // update will contain the diff between previous value and new value from object state\r\n      update = this._updateFromDataDiff(previousDataRef, this._dataRef);\r\n      update.objectMessage = objectMessage;\r\n    }\r\n\r\n    return update;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  onGCInterval(): void {\r\n    // nothing to GC for a counter object\r\n    return;\r\n  }\r\n\r\n  /** @spec RTLC4 */\r\n  protected _getZeroValueData(): LiveCounterData {\r\n    return { data: 0 };\r\n  }\r\n\r\n  protected _updateFromDataDiff(prevDataRef: LiveCounterData, newDataRef: LiveCounterData): LiveCounterUpdate {\r\n    const counterDiff = newDataRef.data - prevDataRef.data;\r\n    return { update: { amount: counterDiff }, _type: 'LiveCounterUpdate' };\r\n  }\r\n\r\n  protected _mergeInitialDataFromCreateOperation(\r\n    objectOperation: ObjectOperation<ObjectData>,\r\n    msg: ObjectMessage,\r\n  ): LiveCounterUpdate {\r\n    // if a counter object is missing for the COUNTER_CREATE op, the initial value is implicitly 0 in this case.\r\n    // note that it is intentional to SUM the incoming count from the create op.\r\n    // if we got here, it means that current counter instance is missing the initial value in its data reference,\r\n    // which we're going to add now.\r\n    this._dataRef.data += objectOperation.counter?.count ?? 0; // RTLC6d1\r\n    this._createOperationIsMerged = true; // RTLC6d2\r\n\r\n    return {\r\n      update: { amount: objectOperation.counter?.count ?? 0 },\r\n      objectMessage: msg,\r\n      _type: 'LiveCounterUpdate',\r\n    };\r\n  }\r\n\r\n  private _throwNoPayloadError(op: ObjectOperation<ObjectData>): void {\r\n    throw new this._client.ErrorInfo(\r\n      `No payload found for ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,\r\n      92000,\r\n      500,\r\n    );\r\n  }\r\n\r\n  private _applyCounterCreate(\r\n    op: ObjectOperation<ObjectData>,\r\n    msg: ObjectMessage,\r\n  ): LiveCounterUpdate | LiveObjectUpdateNoop {\r\n    if (this._createOperationIsMerged) {\r\n      // There can't be two different create operation for the same object id, because the object id\r\n      // fully encodes that operation. This means we can safely ignore any new incoming create operations\r\n      // if we already merged it once.\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveCounter._applyCounterCreate()',\r\n        `skipping applying COUNTER_CREATE op on a counter instance as it was already applied before; objectId=${this.getObjectId()}`,\r\n      );\r\n      return { noop: true };\r\n    }\r\n\r\n    return this._mergeInitialDataFromCreateOperation(op, msg);\r\n  }\r\n\r\n  private _applyCounterInc(op: ObjectsCounterOp, msg: ObjectMessage): LiveCounterUpdate {\r\n    this._dataRef.data += op.amount;\r\n    return {\r\n      update: { amount: op.amount },\r\n      objectMessage: msg,\r\n      _type: 'LiveCounterUpdate',\r\n    };\r\n  }\r\n}\r\n", "import { dequal } from 'dequal';\r\n\r\nimport { __livetype } from '../../../ably';\r\nimport {\r\n  CompactedJsonValue,\r\n  CompactedValue,\r\n  Primitive,\r\n  LiveMap as PublicLiveMap,\r\n  LiveObject as PublicLiveObject,\r\n  Value,\r\n} from '../../../liveobjects';\r\nimport { LiveCounter } from './livecounter';\r\nimport { LiveCounterValueType } from './livecountervaluetype';\r\nimport { LiveMapValueType } from './livemapvaluetype';\r\nimport { LiveObject, LiveObjectData, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\r\nimport {\r\n  ObjectData,\r\n  ObjectMessage,\r\n  ObjectOperation,\r\n  ObjectOperationAction,\r\n  ObjectsMapEntry,\r\n  ObjectsMapOp,\r\n  ObjectsMapSemantics,\r\n} from './objectmessage';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\nexport interface ObjectIdObjectData {\r\n  /** A reference to another object, used to support composable object structures. */\r\n  objectId: string;\r\n}\r\n\r\nexport interface ValueObjectData {\r\n  /** A decoded leaf value from {@link WireObjectData}. */\r\n  value: Primitive;\r\n}\r\n\r\nexport type LiveMapObjectData = ObjectIdObjectData | ValueObjectData;\r\n\r\nexport interface LiveMapEntry {\r\n  tombstone: boolean;\r\n  tombstonedAt: number | undefined;\r\n  timeserial: string | undefined;\r\n  data: LiveMapObjectData | undefined;\r\n}\r\n\r\nexport interface LiveMapData extends LiveObjectData {\r\n  data: Map<string, LiveMapEntry>; // RTLM3\r\n}\r\n\r\nexport interface LiveMapUpdate<T extends Record<string, Value>> extends LiveObjectUpdate {\r\n  update: { [keyName in keyof T & string]?: 'updated' | 'removed' };\r\n  _type: 'LiveMapUpdate';\r\n}\r\n\r\n/** @spec RTLM1, RTLM2 */\r\nexport class LiveMap<T extends Record<string, Value> = Record<string, Value>>\r\n  extends LiveObject<LiveMapData, LiveMapUpdate<T>>\r\n  implements PublicLiveMap<T>\r\n{\r\n  declare readonly [__livetype]: 'LiveMap'; // type-only, unique symbol to satisfy branded interfaces, no JS emitted\r\n\r\n  constructor(\r\n    realtimeObject: RealtimeObject,\r\n    private _semantics: ObjectsMapSemantics,\r\n    objectId: string,\r\n  ) {\r\n    super(realtimeObject, objectId);\r\n  }\r\n\r\n  /**\r\n   * Returns a {@link LiveMap} instance with an empty map data.\r\n   *\r\n   * @internal\r\n   * @spec RTLM4\r\n   */\r\n  static zeroValue(realtimeObject: RealtimeObject, objectId: string): LiveMap {\r\n    return new LiveMap(realtimeObject, ObjectsMapSemantics.LWW, objectId);\r\n  }\r\n\r\n  /**\r\n   * Returns a {@link LiveMap} instance based on the provided object state.\r\n   * The provided object state must hold a valid map object data.\r\n   *\r\n   * @internal\r\n   */\r\n  static fromObjectState(realtimeObject: RealtimeObject, objectMessage: ObjectMessage): LiveMap {\r\n    const obj = new LiveMap(realtimeObject, objectMessage.object!.map!.semantics!, objectMessage.object!.objectId);\r\n    obj.overrideWithObjectState(objectMessage);\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static async createMapSetMessage(\r\n    realtimeObject: RealtimeObject,\r\n    objectId: string,\r\n    key: string,\r\n    value: Value,\r\n  ): Promise<ObjectMessage[]> {\r\n    const client = realtimeObject.getClient();\r\n\r\n    LiveMap.validateKeyValue(realtimeObject, key, value);\r\n\r\n    let objectData: LiveMapObjectData;\r\n    let createValueTypesMessages: ObjectMessage[] = [];\r\n\r\n    if (LiveCounterValueType.instanceof(value)) {\r\n      const counterCreateMsg = await LiveCounterValueType.createCounterCreateMessage(realtimeObject, value);\r\n      createValueTypesMessages = [counterCreateMsg];\r\n\r\n      const typedObjectData: ObjectIdObjectData = { objectId: counterCreateMsg.operation?.objectId! };\r\n      objectData = typedObjectData;\r\n    } else if (LiveMapValueType.instanceof(value)) {\r\n      const { mapCreateMsg, nestedObjectsCreateMsgs } = await LiveMapValueType.createMapCreateMessage(\r\n        realtimeObject,\r\n        value,\r\n      );\r\n      createValueTypesMessages = [...nestedObjectsCreateMsgs, mapCreateMsg];\r\n\r\n      const typedObjectData: ObjectIdObjectData = { objectId: mapCreateMsg.operation?.objectId! };\r\n      objectData = typedObjectData;\r\n    } else {\r\n      const typedObjectData: ValueObjectData = { value: value as Primitive };\r\n      objectData = typedObjectData;\r\n    }\r\n\r\n    const mapSetMsg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          action: ObjectOperationAction.MAP_SET,\r\n          objectId,\r\n          mapOp: {\r\n            key,\r\n            data: objectData,\r\n          },\r\n        } as ObjectOperation<ObjectData>,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return [...createValueTypesMessages, mapSetMsg];\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static createMapRemoveMessage(realtimeObject: RealtimeObject, objectId: string, key: string): ObjectMessage {\r\n    const client = realtimeObject.getClient();\r\n\r\n    if (typeof key !== 'string') {\r\n      throw new client.ErrorInfo('Map key should be string', 40003, 400);\r\n    }\r\n\r\n    const msg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          action: ObjectOperationAction.MAP_REMOVE,\r\n          objectId,\r\n          mapOp: { key },\r\n        } as ObjectOperation<ObjectData>,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return msg;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static validateKeyValue(realtimeObject: RealtimeObject, key: string, value: Value): void {\r\n    const client = realtimeObject.getClient();\r\n\r\n    if (typeof key !== 'string') {\r\n      throw new client.ErrorInfo('Map key should be string', 40003, 400);\r\n    }\r\n\r\n    if (\r\n      value === null ||\r\n      (typeof value !== 'string' &&\r\n        typeof value !== 'number' &&\r\n        typeof value !== 'boolean' &&\r\n        typeof value !== 'object')\r\n    ) {\r\n      throw new client.ErrorInfo('Map value data type is unsupported', 40013, 400); // OD4a\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the value associated with the specified key in the underlying Map object.\r\n   *\r\n   * - If this map object is tombstoned (deleted), `undefined` is returned.\r\n   * - If no entry is associated with the specified key, `undefined` is returned.\r\n   * - If map entry is tombstoned (deleted), `undefined` is returned.\r\n   * - If the value associated with the provided key is an objectId string of another LiveObject, a reference to that LiveObject\r\n   * is returned, provided it exists in the local pool and is not tombstoned. Otherwise, `undefined` is returned.\r\n   * - If the value is not an objectId, then that value is returned.\r\n   *\r\n   * @spec RTLM5, RTLM5a\r\n   */\r\n  // force the key to be of type string as we only allow strings as key in a map\r\n  get<TKey extends keyof T & string>(key: TKey): T[TKey] | undefined {\r\n    if (this.isTombstoned()) {\r\n      return undefined;\r\n    }\r\n\r\n    const element = this._dataRef.data.get(key);\r\n\r\n    // RTLM5d1\r\n    if (element === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    // RTLM5d2a\r\n    if (element.tombstone === true) {\r\n      return undefined;\r\n    }\r\n\r\n    // data always exists for non-tombstoned elements\r\n    return this._getResolvedValueFromObjectData(element.data!) as T[TKey];\r\n  }\r\n\r\n  size(): number {\r\n    let size = 0;\r\n    for (const value of this._dataRef.data.values()) {\r\n      if (this._isMapEntryTombstoned(value)) {\r\n        // should not count tombstoned entries\r\n        continue;\r\n      }\r\n\r\n      size++;\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  *entries<TKey extends keyof T & string>(): IterableIterator<[TKey, T[TKey]]> {\r\n    for (const [key, entry] of this._dataRef.data.entries()) {\r\n      if (this._isMapEntryTombstoned(entry)) {\r\n        // do not return tombstoned entries\r\n        continue;\r\n      }\r\n\r\n      // data always exists for non-tombstoned elements\r\n      const value = this._getResolvedValueFromObjectData(entry.data!) as T[TKey];\r\n      yield [key as TKey, value];\r\n    }\r\n  }\r\n\r\n  *keys<TKey extends keyof T & string>(): IterableIterator<TKey> {\r\n    for (const [key] of this.entries<TKey>()) {\r\n      yield key;\r\n    }\r\n  }\r\n\r\n  *values<TKey extends keyof T & string>(): IterableIterator<T[TKey]> {\r\n    for (const [_, value] of this.entries<TKey>()) {\r\n      yield value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a MAP_SET operation to the realtime system to set a key on this LiveMap object to a specified value.\r\n   *\r\n   * This does not modify the underlying data of this LiveMap object. Instead, the change will be applied when\r\n   * the published MAP_SET operation is echoed back to the client and applied to the object following the regular\r\n   * operation application procedure.\r\n   *\r\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message.\r\n   */\r\n  async set<TKey extends keyof T & string>(\r\n    key: TKey,\r\n    value: T[TKey] | LiveCounterValueType | LiveMapValueType,\r\n  ): Promise<void> {\r\n    const msgs = await LiveMap.createMapSetMessage(this._realtimeObject, this.getObjectId(), key, value);\r\n    return this._realtimeObject.publish(msgs);\r\n  }\r\n\r\n  /**\r\n   * Send a MAP_REMOVE operation to the realtime system to tombstone a key on this LiveMap object.\r\n   *\r\n   * This does not modify the underlying data of this LiveMap object. Instead, the change will be applied when\r\n   * the published MAP_REMOVE operation is echoed back to the client and applied to the object following the regular\r\n   * operation application procedure.\r\n   *\r\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message.\r\n   */\r\n  async remove<TKey extends keyof T & string>(key: TKey): Promise<void> {\r\n    const msg = LiveMap.createMapRemoveMessage(this._realtimeObject, this.getObjectId(), key);\r\n    return this._realtimeObject.publish([msg]);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  applyOperation(op: ObjectOperation<ObjectData>, msg: ObjectMessage): void {\r\n    if (op.objectId !== this.getObjectId()) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot apply object operation with objectId=${op.objectId}, to this LiveMap with objectId=${this.getObjectId()}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    const opSerial = msg.serial!;\r\n    const opSiteCode = msg.siteCode!;\r\n    if (!this._canApplyOperation(opSerial, opSiteCode)) {\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveMap.applyOperation()',\r\n        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${this._siteTimeserials[opSiteCode]?.toString()}; objectId=${this.getObjectId()}`,\r\n      );\r\n      return;\r\n    }\r\n    // should update stored site serial immediately. doesn't matter if we successfully apply the op,\r\n    // as it's important to mark that the op was processed by the object\r\n    this._siteTimeserials[opSiteCode] = opSerial;\r\n\r\n    if (this.isTombstoned()) {\r\n      // this object is tombstoned so the operation cannot be applied\r\n      return;\r\n    }\r\n\r\n    let update: LiveMapUpdate<T> | LiveObjectUpdateNoop;\r\n    switch (op.action) {\r\n      case ObjectOperationAction.MAP_CREATE:\r\n        update = this._applyMapCreate(op, msg);\r\n        break;\r\n\r\n      case ObjectOperationAction.MAP_SET:\r\n        if (this._client.Utils.isNil(op.mapOp)) {\r\n          this._throwNoPayloadError(op);\r\n          // leave an explicit return here, so that TS knows that update object is always set after the switch statement.\r\n          return;\r\n        } else {\r\n          update = this._applyMapSet(op.mapOp, opSerial, msg);\r\n        }\r\n        break;\r\n\r\n      case ObjectOperationAction.MAP_REMOVE:\r\n        if (this._client.Utils.isNil(op.mapOp)) {\r\n          this._throwNoPayloadError(op);\r\n          // leave an explicit return here, so that TS knows that update object is always set after the switch statement.\r\n          return;\r\n        } else {\r\n          update = this._applyMapRemove(op.mapOp, opSerial, msg.serialTimestamp, msg);\r\n        }\r\n        break;\r\n\r\n      case ObjectOperationAction.OBJECT_DELETE:\r\n        update = this._applyObjectDelete(msg);\r\n        break;\r\n\r\n      default:\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid ${op.action} op for LiveMap objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n    }\r\n\r\n    this.notifyUpdated(update);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * @spec RTLM6\r\n   */\r\n  overrideWithObjectState(objectMessage: ObjectMessage): LiveMapUpdate<T> | LiveObjectUpdateNoop {\r\n    const objectState = objectMessage.object;\r\n    if (objectState == null) {\r\n      throw new this._client.ErrorInfo(`Missing object state; LiveMap objectId=${this.getObjectId()}`, 92000, 500);\r\n    }\r\n\r\n    if (objectState.objectId !== this.getObjectId()) {\r\n      throw new this._client.ErrorInfo(\r\n        `Invalid object state: object state objectId=${objectState.objectId}; LiveMap objectId=${this.getObjectId()}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    if (objectState.map?.semantics !== this._semantics) {\r\n      throw new this._client.ErrorInfo(\r\n        `Invalid object state: object state map semantics=${objectState.map?.semantics}; LiveMap semantics=${this._semantics}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    if (!this._client.Utils.isNil(objectState.createOp)) {\r\n      // it is expected that create operation can be missing in the object state, so only validate it when it exists\r\n      if (objectState.createOp.objectId !== this.getObjectId()) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp objectId=${objectState.createOp?.objectId}; LiveMap objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n\r\n      if (objectState.createOp.action !== ObjectOperationAction.MAP_CREATE) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp action=${objectState.createOp?.action}; LiveMap objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n\r\n      if (objectState.createOp.map?.semantics !== this._semantics) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp map semantics=${objectState.createOp.map?.semantics}; LiveMap semantics=${this._semantics}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n    }\r\n\r\n    // object's site serials are still updated even if it is tombstoned, so always use the site serials received from the op.\r\n    // should default to empty map if site serials do not exist on the object state, so that any future operation may be applied to this object.\r\n    this._siteTimeserials = objectState.siteTimeserials ?? {}; // RTLM6a\r\n\r\n    if (this.isTombstoned()) {\r\n      // this object is tombstoned. this is a terminal state which can't be overridden. skip the rest of object state message processing\r\n      return { noop: true };\r\n    }\r\n\r\n    const previousDataRef = this._dataRef;\r\n    let update: LiveMapUpdate<T>;\r\n    if (objectState.tombstone) {\r\n      // tombstone this object and ignore the data from the object state message\r\n      update = this.tombstone(objectMessage);\r\n    } else {\r\n      // otherwise override data for this object with data from the object state\r\n      this._createOperationIsMerged = false; // RTLM6b\r\n      this._dataRef = this._liveMapDataFromMapEntries(objectState.map?.entries ?? {}); // RTLM6c\r\n      // RTLM6d\r\n      if (!this._client.Utils.isNil(objectState.createOp)) {\r\n        this._mergeInitialDataFromCreateOperation(objectState.createOp, objectMessage);\r\n      }\r\n\r\n      // update will contain the diff between previous value and new value from object state\r\n      update = this._updateFromDataDiff(previousDataRef, this._dataRef);\r\n      update.objectMessage = objectMessage;\r\n    }\r\n\r\n    // Update parent references based on the calculated diff\r\n    this._updateParentReferencesFromUpdate(update, previousDataRef);\r\n\r\n    return update;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  onGCInterval(): void {\r\n    // should remove any tombstoned entries from the underlying map data that have exceeded the GC grace period\r\n\r\n    const keysToDelete: string[] = [];\r\n    for (const [key, value] of this._dataRef.data.entries()) {\r\n      if (value.tombstone === true && Date.now() - value.tombstonedAt! >= this._realtimeObject.gcGracePeriod) {\r\n        keysToDelete.push(key);\r\n      }\r\n    }\r\n\r\n    keysToDelete.forEach((x) => this._dataRef.data.delete(x));\r\n  }\r\n\r\n  /**\r\n   * Override clearData to handle parent reference cleanup when this LiveMap is tombstoned.\r\n   *\r\n   * @internal\r\n   */\r\n  clearData(): LiveMapUpdate<T> {\r\n    // Remove all parent references for objects this map was referencing\r\n    for (const [key, entry] of this._dataRef.data.entries()) {\r\n      if (entry.data && 'objectId' in entry.data) {\r\n        const referencedObject = this._realtimeObject.getPool().get(entry.data.objectId);\r\n        if (referencedObject) {\r\n          referencedObject.removeParentReference(this, key);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Call the parent clearData method\r\n    return super.clearData();\r\n  }\r\n\r\n  /**\r\n   * Returns an in-memory JavaScript object representation of this LiveMap.\r\n   * LiveMap values are recursively compacted using their own compact methods.\r\n   * Compacted LiveMaps are memoized to handle cyclic references (returned as in-memory pointers).\r\n   *\r\n   * Use compactJson() for a JSON-serializable representation.\r\n   *\r\n   * @internal\r\n   */\r\n  compact(visitedObjects?: Map<string, Record<string, any>>): CompactedValue<PublicLiveMap<T>> {\r\n    const visited = visitedObjects ?? new Map<string, Record<string, any>>();\r\n    const result: Record<keyof T, any> = {} as Record<keyof T, any>;\r\n\r\n    // Memoize the compacted result to handle circular references\r\n    visited.set(this.getObjectId(), result);\r\n\r\n    // Use public entries() method to ensure we only include publicly exposed properties\r\n    for (const [key, value] of this.entries()) {\r\n      if (value instanceof LiveMap) {\r\n        if (visited.has(value.getObjectId())) {\r\n          // If the LiveMap has already been visited, just reference it to avoid infinite loops\r\n          result[key] = visited.get(value.getObjectId());\r\n        } else {\r\n          // Otherwise, compact it\r\n          result[key] = value.compact(visited);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (value instanceof LiveCounter) {\r\n        result[key] = value.value();\r\n        continue;\r\n      }\r\n\r\n      // other values are returned as-is\r\n      result[key] = value;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a JSON-serializable representation of this LiveMap.\r\n   * LiveMap values are recursively compacted using their own compactJson methods.\r\n   * Cyclic references are represented as `{ objectId: string }` instead of in-memory pointers.\r\n   * Buffers are converted to base64 strings.\r\n   *\r\n   * Use compact() for an in-memory representation.\r\n   *\r\n   * @internal\r\n   */\r\n  compactJson(visitedObjectIds?: Set<string>): CompactedJsonValue<PublicLiveMap<T>> {\r\n    const visited = visitedObjectIds ?? new Set<string>();\r\n    const result: Record<keyof T, any> = {} as Record<keyof T, any>;\r\n\r\n    // Mark this object ID as visited to handle circular references\r\n    visited.add(this.getObjectId());\r\n\r\n    // Use public entries() method to ensure we only include publicly exposed properties\r\n    for (const [key, value] of this.entries()) {\r\n      if (value instanceof LiveMap) {\r\n        if (visited.has(value.getObjectId())) {\r\n          // If the LiveMap has already been visited, return its objectId to avoid infinite loops\r\n          result[key] = { objectId: value.getObjectId() };\r\n        } else {\r\n          // Otherwise, compact it\r\n          result[key] = value.compactJson(visited);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (value instanceof LiveCounter) {\r\n        result[key] = value.value();\r\n        continue;\r\n      }\r\n\r\n      // Convert buffers to base64 strings\r\n      if (this._client.Platform.BufferUtils.isBuffer(value)) {\r\n        result[key] = this._client.Platform.BufferUtils.base64Encode(value);\r\n        continue;\r\n      }\r\n\r\n      // Other values return as is\r\n      result[key] = value;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /** @spec RTLM4 */\r\n  protected _getZeroValueData(): LiveMapData {\r\n    return { data: new Map<string, LiveMapEntry>() };\r\n  }\r\n\r\n  protected _updateFromDataDiff(prevDataRef: LiveMapData, newDataRef: LiveMapData): LiveMapUpdate<T> {\r\n    const update: LiveMapUpdate<T> = { update: {}, _type: 'LiveMapUpdate' };\r\n\r\n    for (const [key, currentEntry] of prevDataRef.data.entries()) {\r\n      const typedKey: keyof T & string = key;\r\n      // any non-tombstoned properties that exist on a current map, but not in the new data - got removed\r\n      if (currentEntry.tombstone === false && !newDataRef.data.has(typedKey)) {\r\n        update.update[typedKey] = 'removed';\r\n      }\r\n    }\r\n\r\n    for (const [key, newEntry] of newDataRef.data.entries()) {\r\n      const typedKey: keyof T & string = key;\r\n      if (!prevDataRef.data.has(typedKey)) {\r\n        // if property does not exist in the current map, but new data has it as a non-tombstoned property - got updated\r\n        if (newEntry.tombstone === false) {\r\n          update.update[typedKey] = 'updated';\r\n          continue;\r\n        }\r\n\r\n        // otherwise, if new data has this prop tombstoned - do nothing, as property didn't exist anyway\r\n        if (newEntry.tombstone === true) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // properties that exist both in current and new map data need to have their values compared to decide on the update type\r\n      const currentEntry = prevDataRef.data.get(typedKey)!;\r\n\r\n      // compare tombstones first\r\n      if (currentEntry.tombstone === true && newEntry.tombstone === false) {\r\n        // current prop is tombstoned, but new is not. it means prop was updated to a meaningful value\r\n        update.update[typedKey] = 'updated';\r\n        continue;\r\n      }\r\n      if (currentEntry.tombstone === false && newEntry.tombstone === true) {\r\n        // current prop is not tombstoned, but new is. it means prop was removed\r\n        update.update[typedKey] = 'removed';\r\n        continue;\r\n      }\r\n      if (currentEntry.tombstone === true && newEntry.tombstone === true) {\r\n        // both props are tombstoned - treat as noop, as there is no data to compare.\r\n        continue;\r\n      }\r\n\r\n      // both props exist and are not tombstoned, need to compare values with deep equals to see if it was changed\r\n      const valueChanged = !dequal(currentEntry.data, newEntry.data);\r\n      if (valueChanged) {\r\n        update.update[typedKey] = 'updated';\r\n        continue;\r\n      }\r\n    }\r\n\r\n    return update;\r\n  }\r\n\r\n  protected _mergeInitialDataFromCreateOperation(\r\n    objectOperation: ObjectOperation<ObjectData>,\r\n    msg: ObjectMessage,\r\n  ): LiveMapUpdate<T> {\r\n    if (this._client.Utils.isNil(objectOperation.map)) {\r\n      // if a map object is missing for the MAP_CREATE op, the initial value is implicitly an empty map.\r\n      // in this case there is nothing to merge into the current map, so we can just end processing the op.\r\n      return { update: {}, objectMessage: msg, _type: 'LiveMapUpdate' };\r\n    }\r\n\r\n    const aggregatedUpdate: LiveMapUpdate<T> = {\r\n      update: {},\r\n      objectMessage: msg,\r\n      _type: 'LiveMapUpdate',\r\n    };\r\n    // RTLM6d1\r\n    // in order to apply MAP_CREATE op for an existing map, we should merge their underlying entries keys.\r\n    // we can do this by iterating over entries from MAP_CREATE op and apply changes on per-key basis as if we had MAP_SET, MAP_REMOVE operations.\r\n    Object.entries(objectOperation.map.entries ?? {}).forEach(([key, entry]) => {\r\n      // for a MAP_CREATE operation we must use the serial value available on an entry, instead of a serial on a message\r\n      const opSerial = entry.timeserial;\r\n      let update: LiveMapUpdate<T> | LiveObjectUpdateNoop;\r\n      if (entry.tombstone === true) {\r\n        // RTLM6d1b - entry in MAP_CREATE op is removed, try to apply MAP_REMOVE op\r\n        update = this._applyMapRemove({ key }, opSerial, entry.serialTimestamp, msg);\r\n      } else {\r\n        // RTLM6d1a - entry in MAP_CREATE op is not removed, try to set it via MAP_SET op\r\n        update = this._applyMapSet({ key, data: entry.data }, opSerial, msg);\r\n      }\r\n\r\n      // skip noop updates\r\n      if ((update as LiveObjectUpdateNoop).noop) {\r\n        return;\r\n      }\r\n\r\n      // otherwise copy update data to aggregated update\r\n      Object.assign(aggregatedUpdate.update, update.update);\r\n    });\r\n\r\n    this._createOperationIsMerged = true; // RTLM6d2\r\n\r\n    return aggregatedUpdate;\r\n  }\r\n\r\n  private _throwNoPayloadError(op: ObjectOperation<ObjectData>): void {\r\n    throw new this._client.ErrorInfo(\r\n      `No payload found for ${op.action} op for LiveMap objectId=${this.getObjectId()}`,\r\n      92000,\r\n      500,\r\n    );\r\n  }\r\n\r\n  private _applyMapCreate(\r\n    op: ObjectOperation<ObjectData>,\r\n    msg: ObjectMessage,\r\n  ): LiveMapUpdate<T> | LiveObjectUpdateNoop {\r\n    if (this._createOperationIsMerged) {\r\n      // There can't be two different create operation for the same object id, because the object id\r\n      // fully encodes that operation. This means we can safely ignore any new incoming create operations\r\n      // if we already merged it once.\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveMap._applyMapCreate()',\r\n        `skipping applying MAP_CREATE op on a map instance as it was already applied before; objectId=${this.getObjectId()}`,\r\n      );\r\n      return { noop: true };\r\n    }\r\n\r\n    if (this._semantics !== op.map?.semantics) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot apply MAP_CREATE op on LiveMap objectId=${this.getObjectId()}; map's semantics=${this._semantics}, but op expected ${op.map?.semantics}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    return this._mergeInitialDataFromCreateOperation(op, msg);\r\n  }\r\n\r\n  /** @spec RTLM7 */\r\n  private _applyMapSet(\r\n    op: ObjectsMapOp<ObjectData>,\r\n    opSerial: string | undefined,\r\n    msg: ObjectMessage,\r\n  ): LiveMapUpdate<T> | LiveObjectUpdateNoop {\r\n    const { ErrorInfo, Utils } = this._client;\r\n\r\n    const existingEntry = this._dataRef.data.get(op.key);\r\n    // RTLM7a\r\n    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {\r\n      // RTLM7a1 - the operation's serial <= the entry's serial, ignore the operation.\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveMap._applyMapSet()',\r\n        `skipping update for key=\"${op.key}\": op serial ${opSerial?.toString()} <= entry serial ${existingEntry.timeserial?.toString()}; objectId=${this.getObjectId()}`,\r\n      );\r\n      return { noop: true };\r\n    }\r\n\r\n    if (Utils.isNil(op.data) || (Utils.isNil(op.data.objectId) && Utils.isNil(op.data.value))) {\r\n      throw new ErrorInfo(\r\n        `Invalid object data for MAP_SET op on objectId=${this.getObjectId()} on key=\"${op.key}\"`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    let liveData: LiveMapObjectData;\r\n    // RTLM7c\r\n    if (!Utils.isNil(op.data.objectId)) {\r\n      liveData = { objectId: op.data.objectId } as ObjectIdObjectData;\r\n      // this MAP_SET op is setting a key to point to another object via its object id,\r\n      // but it is possible that we don't have the corresponding object in the pool yet (for example, we haven't seen the *_CREATE op for it).\r\n      // we don't want to return undefined from this map's .get() method even if we don't have the object,\r\n      // so instead we create a zero-value object for that object id if it not exists.\r\n      this._realtimeObject.getPool().createZeroValueObjectIfNotExists(op.data.objectId); // RTLM7c1\r\n    } else {\r\n      liveData = { value: op.data.value } as ValueObjectData;\r\n    }\r\n\r\n    if (existingEntry) {\r\n      // If there was an existing entry, we need to handle parent reference changes\r\n      if (existingEntry.data && 'objectId' in existingEntry.data) {\r\n        // Remove parent reference from the old object\r\n        const oldReferencedObject = this._realtimeObject.getPool().get(existingEntry.data.objectId);\r\n        if (oldReferencedObject) {\r\n          oldReferencedObject.removeParentReference(this, op.key);\r\n        }\r\n      }\r\n\r\n      // RTLM7a2\r\n      existingEntry.tombstone = false; // RTLM7a2c\r\n      existingEntry.tombstonedAt = undefined;\r\n      existingEntry.timeserial = opSerial; // RTLM7a2b\r\n      existingEntry.data = liveData; // RTLM7a2a\r\n    } else {\r\n      // RTLM7b, RTLM7b1\r\n      const newEntry: LiveMapEntry = {\r\n        tombstone: false, // RTLM7b2\r\n        tombstonedAt: undefined,\r\n        timeserial: opSerial,\r\n        data: liveData,\r\n      };\r\n      this._dataRef.data.set(op.key, newEntry);\r\n    }\r\n\r\n    // Add parent reference to the new object (if it's an object reference)\r\n    if ('objectId' in liveData) {\r\n      const newReferencedObject = this._realtimeObject.getPool().get(liveData.objectId);\r\n      if (newReferencedObject) {\r\n        newReferencedObject.addParentReference(this, op.key);\r\n      }\r\n    }\r\n\r\n    const update: LiveMapUpdate<T> = {\r\n      update: {},\r\n      objectMessage: msg,\r\n      _type: 'LiveMapUpdate',\r\n    };\r\n    const typedKey: keyof T & string = op.key;\r\n    update.update[typedKey] = 'updated';\r\n\r\n    return update;\r\n  }\r\n\r\n  /** @spec RTLM8 */\r\n  private _applyMapRemove(\r\n    op: ObjectsMapOp<ObjectData>,\r\n    opSerial: string | undefined,\r\n    opTimestamp: number | undefined,\r\n    msg: ObjectMessage,\r\n  ): LiveMapUpdate<T> | LiveObjectUpdateNoop {\r\n    const existingEntry = this._dataRef.data.get(op.key);\r\n    // RTLM8a\r\n    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {\r\n      // RTLM8a1 - the operation's serial <= the entry's serial, ignore the operation.\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveMap._applyMapRemove()',\r\n        `skipping remove for key=\"${op.key}\": op serial ${opSerial?.toString()} <= entry serial ${existingEntry.timeserial?.toString()}; objectId=${this.getObjectId()}`,\r\n      );\r\n      return { noop: true };\r\n    }\r\n\r\n    let tombstonedAt: number;\r\n    if (opTimestamp != null) {\r\n      tombstonedAt = opTimestamp;\r\n    } else {\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MINOR,\r\n        'LiveMap._applyMapRemove()',\r\n        `map key has been removed but no \"serialTimestamp\" found in the message, using local clock instead; key=\"${op.key}\", objectId=${this.getObjectId()}`,\r\n      );\r\n      tombstonedAt = Date.now(); // best-effort estimate since no timestamp provided by the server\r\n    }\r\n\r\n    if (existingEntry) {\r\n      // Handle parent reference removal for object references\r\n      if (existingEntry.data && 'objectId' in existingEntry.data) {\r\n        // Remove parent reference from the object that was being referenced\r\n        const referencedObject = this._realtimeObject.getPool().get(existingEntry.data.objectId);\r\n        if (referencedObject) {\r\n          referencedObject.removeParentReference(this, op.key);\r\n        }\r\n      }\r\n\r\n      // RTLM8a2\r\n      existingEntry.tombstone = true; // RTLM8a2c\r\n      existingEntry.tombstonedAt = tombstonedAt;\r\n      existingEntry.timeserial = opSerial; // RTLM8a2b\r\n      existingEntry.data = undefined; // RTLM8a2a\r\n    } else {\r\n      // RTLM8b, RTLM8b1\r\n      const newEntry: LiveMapEntry = {\r\n        tombstone: true, // RTLM8b2\r\n        tombstonedAt: tombstonedAt,\r\n        timeserial: opSerial,\r\n        data: undefined,\r\n      };\r\n      this._dataRef.data.set(op.key, newEntry);\r\n    }\r\n\r\n    const update: LiveMapUpdate<T> = {\r\n      update: {},\r\n      objectMessage: msg,\r\n      _type: 'LiveMapUpdate',\r\n    };\r\n    const typedKey: keyof T & string = op.key;\r\n    update.update[typedKey] = 'removed';\r\n\r\n    return update;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the serials of the given operation and entry indicate that\r\n   * the operation should be applied to the entry, following the CRDT semantics of this LiveMap.\r\n   * @spec RTLM9\r\n   */\r\n  private _canApplyMapOperation(mapEntrySerial: string | undefined, opSerial: string | undefined): boolean {\r\n    // for LWW CRDT semantics (the only supported LiveMap semantic) an operation\r\n    // should only be applied if its serial is strictly greater (\"after\") than an entry's serial.\r\n\r\n    if (!mapEntrySerial && !opSerial) {\r\n      // RTLM9b - if both serials are nullish or empty strings, we treat them as the \"earliest possible\" serials,\r\n      // in which case they are \"equal\", so the operation should not be applied\r\n      return false;\r\n    }\r\n\r\n    if (!mapEntrySerial) {\r\n      // RTLM9d - any operation serial is greater than non-existing entry serial\r\n      return true;\r\n    }\r\n\r\n    if (!opSerial) {\r\n      // RTLM9c - non-existing operation serial is lower than any entry serial\r\n      return false;\r\n    }\r\n\r\n    // RTLM9e - if both serials exist, compare them lexicographically\r\n    return opSerial > mapEntrySerial;\r\n  }\r\n\r\n  private _liveMapDataFromMapEntries(entries: Record<string, ObjectsMapEntry<ObjectData>>): LiveMapData {\r\n    const liveMapData: LiveMapData = {\r\n      data: new Map<string, LiveMapEntry>(),\r\n    };\r\n\r\n    // need to iterate over entries to correctly process optional parameters\r\n    Object.entries(entries ?? {}).forEach(([key, entry]) => {\r\n      let liveData: LiveMapObjectData | undefined = undefined;\r\n\r\n      if (!this._client.Utils.isNil(entry.data)) {\r\n        if (!this._client.Utils.isNil(entry.data.objectId)) {\r\n          liveData = { objectId: entry.data.objectId } as ObjectIdObjectData;\r\n        } else {\r\n          liveData = { value: entry.data.value } as ValueObjectData;\r\n        }\r\n      }\r\n\r\n      let tombstonedAt: number | undefined;\r\n      if (entry.tombstone === true) {\r\n        if (entry.serialTimestamp != null) {\r\n          tombstonedAt = entry.serialTimestamp;\r\n        } else {\r\n          this._client.Logger.logAction(\r\n            this._client.logger,\r\n            this._client.Logger.LOG_MINOR,\r\n            'LiveMap._liveMapDataFromMapEntries()',\r\n            `map key is removed but no \"serialTimestamp\" found, using local clock instead; key=\"${key}\", objectId=${this.getObjectId()}`,\r\n          );\r\n          tombstonedAt = Date.now(); // best-effort estimate since no timestamp provided by the server\r\n        }\r\n      }\r\n\r\n      const liveDataEntry: LiveMapEntry = {\r\n        timeserial: entry.timeserial,\r\n        data: liveData,\r\n        // consider object as tombstoned only if we received an explicit flag stating that. otherwise it exists\r\n        tombstone: entry.tombstone === true,\r\n        tombstonedAt,\r\n      };\r\n\r\n      liveMapData.data.set(key, liveDataEntry);\r\n    });\r\n\r\n    return liveMapData;\r\n  }\r\n\r\n  /**\r\n   * Returns value as is if object data stores a primitive type, or a reference to another LiveObject from the pool if it stores an objectId.\r\n   */\r\n  private _getResolvedValueFromObjectData(data: LiveMapObjectData): Value | undefined {\r\n    // if object data stores primitive value, just return it as is.\r\n    const primitiveValue = (data as ValueObjectData).value;\r\n    if (primitiveValue != null) {\r\n      return primitiveValue; // RTLM5d2b, RTLM5d2c, RTLM5d2d, RTLM5d2e\r\n    }\r\n\r\n    // RTLM5d2f - otherwise, it has an objectId reference, and we should get the actual object from the pool\r\n    const objectId = (data as ObjectIdObjectData).objectId;\r\n    const refObject: LiveObject | undefined = this._realtimeObject.getPool().get(objectId);\r\n    if (!refObject) {\r\n      return undefined; // RTLM5d2f1\r\n    }\r\n\r\n    if (refObject.isTombstoned()) {\r\n      // tombstoned objects must not be surfaced to the end users\r\n      return undefined;\r\n    }\r\n\r\n    return refObject as unknown as PublicLiveObject; // RTLM5d2f2\r\n  }\r\n\r\n  private _isMapEntryTombstoned(entry: LiveMapEntry): boolean {\r\n    if (entry.tombstone === true) {\r\n      return true;\r\n    }\r\n\r\n    // data always exists for non-tombstoned entries\r\n    const data = entry.data!;\r\n    if ('objectId' in data) {\r\n      const refObject = this._realtimeObject.getPool().get(data.objectId);\r\n\r\n      if (refObject?.isTombstoned()) {\r\n        // entry that points to tombstoned object should be considered tombstoned as well\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Update parent references based on the calculated update diff.\r\n   */\r\n  private _updateParentReferencesFromUpdate(update: LiveMapUpdate<T>, previousDataRef: LiveMapData): void {\r\n    for (const [key, changeType] of Object.entries(update.update)) {\r\n      if (changeType === 'removed') {\r\n        // Key was removed - remove parent reference from the old object if it was referencing one\r\n        const previousEntry = previousDataRef.data.get(key);\r\n        if (previousEntry?.data && 'objectId' in previousEntry.data) {\r\n          const oldReferencedObject = this._realtimeObject.getPool().get(previousEntry.data.objectId);\r\n          if (oldReferencedObject) {\r\n            oldReferencedObject.removeParentReference(this, key);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (changeType === 'updated') {\r\n        // Key was updated - need to handle both removal of old reference and addition of new reference\r\n        const previousEntry = previousDataRef.data.get(key);\r\n        const newEntry = this._dataRef.data.get(key);\r\n\r\n        // Remove old parent reference if there was one\r\n        if (previousEntry?.data && 'objectId' in previousEntry.data) {\r\n          const oldReferencedObject = this._realtimeObject.getPool().get(previousEntry.data.objectId);\r\n          if (oldReferencedObject) {\r\n            oldReferencedObject.removeParentReference(this, key);\r\n          }\r\n        }\r\n\r\n        // Add new parent reference if the new value references an object\r\n        if (newEntry?.data && 'objectId' in newEntry.data) {\r\n          const newReferencedObject = this._realtimeObject.getPool().get(newEntry.data.objectId);\r\n          if (newReferencedObject) {\r\n            newReferencedObject.addParentReference(this, key);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n", "import { __livetype } from '../../../ably';\r\nimport { Primitive, LiveMap as PublicLiveMap, Value } from '../../../liveobjects';\r\nimport { LiveCounterValueType } from './livecountervaluetype';\r\nimport { LiveMap, LiveMapObjectData, ObjectIdObjectData, ValueObjectData } from './livemap';\r\nimport { ObjectId } from './objectid';\r\nimport {\r\n  createInitialValueJSONString,\r\n  ObjectData,\r\n  ObjectMessage,\r\n  ObjectOperation,\r\n  ObjectOperationAction,\r\n  ObjectsMapEntry,\r\n  ObjectsMapSemantics,\r\n} from './objectmessage';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\n/**\r\n * A value type class that serves as a simple container for LiveMap data.\r\n * Contains sufficient information for the client to produce a MAP_CREATE operation\r\n * for the LiveMap object.\r\n *\r\n * Properties of this class are immutable after construction and the instance\r\n * will be frozen to prevent mutation.\r\n *\r\n * Note: We do not deep freeze or deep copy the entries data for the following reasons:\r\n * 1. It adds substantial complexity, especially for handling Buffer/ArrayBuffer values\r\n * 2. Cross-platform buffer copying would require reimplementing BufferUtils logic\r\n *    to handle browser vs Node.js environments and check availability of Buffer/ArrayBuffer\r\n * 3. The protection isn't critical - if users mutate the data after creating the value type,\r\n *    nothing breaks since we create separate live objects each time the value type is used\r\n * 4. This behavior should be documented and it's the user's responsibility to understand\r\n *    how they mutate their data when working with value type classes\r\n */\r\nexport class LiveMapValueType<T extends Record<string, Value> = Record<string, Value>> implements PublicLiveMap<T> {\r\n  declare readonly [__livetype]: 'LiveMap'; // type-only, unique symbol to satisfy branded interfaces, no JS emitted\r\n  private readonly _livetype = 'LiveMap'; // use a runtime property to provide a reliable cross-bundle type identification instead of `instanceof` operator\r\n  private readonly _entries: T | undefined;\r\n\r\n  private constructor(entries: T | undefined) {\r\n    this._entries = entries;\r\n    Object.freeze(this);\r\n  }\r\n\r\n  static create<T extends Record<string, Value>>(\r\n    initialEntries?: T,\r\n  ): PublicLiveMap<T extends Record<string, Value> ? T : {}> {\r\n    // We can't directly import the ErrorInfo class from the core library into the plugin (as this would bloat the plugin size),\r\n    // and, since we're in a user-facing static method, we can't expect a user to pass a client library instance, as this would make the API ugly.\r\n    // Since we can't use ErrorInfo here, we won't do any validation at this step; instead, validation will happen in the mutation methods\r\n    // when we try to create this object.\r\n\r\n    return new LiveMapValueType(initialEntries);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static instanceof(value: unknown): value is LiveMapValueType {\r\n    return typeof value === 'object' && value !== null && (value as LiveMapValueType)._livetype === 'LiveMap';\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static async createMapCreateMessage(\r\n    realtimeObject: RealtimeObject,\r\n    value: LiveMapValueType,\r\n  ): Promise<{ mapCreateMsg: ObjectMessage; nestedObjectsCreateMsgs: ObjectMessage[] }> {\r\n    const client = realtimeObject.getClient();\r\n    const entries = value._entries;\r\n\r\n    if (entries !== undefined && (entries === null || typeof entries !== 'object')) {\r\n      throw new client.ErrorInfo('Map entries should be a key-value object', 40003, 400);\r\n    }\r\n\r\n    Object.entries(entries ?? {}).forEach(([key, value]) => LiveMap.validateKeyValue(realtimeObject, key, value));\r\n\r\n    const { initialValueOperation, nestedObjectsCreateMsgs } = await LiveMapValueType._createInitialValueOperation(\r\n      realtimeObject,\r\n      entries,\r\n    );\r\n    const initialValueJSONString = createInitialValueJSONString(initialValueOperation, client);\r\n    const nonce = client.Utils.cheapRandStr();\r\n    const msTimestamp = await client.getTimestamp(true);\r\n\r\n    const objectId = ObjectId.fromInitialValue(\r\n      client.Platform,\r\n      'map',\r\n      initialValueJSONString,\r\n      nonce,\r\n      msTimestamp,\r\n    ).toString();\r\n\r\n    const mapCreateMsg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          ...initialValueOperation,\r\n          action: ObjectOperationAction.MAP_CREATE,\r\n          objectId,\r\n          nonce,\r\n          initialValue: initialValueJSONString,\r\n        } as ObjectOperation<ObjectData>,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return {\r\n      mapCreateMsg,\r\n      nestedObjectsCreateMsgs,\r\n    };\r\n  }\r\n\r\n  private static async _createInitialValueOperation(\r\n    realtimeObject: RealtimeObject,\r\n    entries?: Record<string, Value>,\r\n  ): Promise<{\r\n    initialValueOperation: Pick<ObjectOperation<ObjectData>, 'map'>;\r\n    nestedObjectsCreateMsgs: ObjectMessage[];\r\n  }> {\r\n    const mapEntries: Record<string, ObjectsMapEntry<ObjectData>> = {};\r\n    const nestedObjectsCreateMsgs: ObjectMessage[] = [];\r\n\r\n    for (const [key, value] of Object.entries(entries ?? {})) {\r\n      let objectData: LiveMapObjectData;\r\n\r\n      if (LiveMapValueType.instanceof(value)) {\r\n        const { mapCreateMsg, nestedObjectsCreateMsgs: childNestedObjs } =\r\n          await LiveMapValueType.createMapCreateMessage(realtimeObject, value);\r\n        nestedObjectsCreateMsgs.push(...childNestedObjs, mapCreateMsg);\r\n        const typedObjectData: ObjectIdObjectData = { objectId: mapCreateMsg.operation?.objectId! };\r\n        objectData = typedObjectData;\r\n      } else if (LiveCounterValueType.instanceof(value)) {\r\n        const counterCreateMsg = await LiveCounterValueType.createCounterCreateMessage(realtimeObject, value);\r\n        nestedObjectsCreateMsgs.push(counterCreateMsg);\r\n        const typedObjectData: ObjectIdObjectData = { objectId: counterCreateMsg.operation?.objectId! };\r\n        objectData = typedObjectData;\r\n      } else {\r\n        // Handle primitive values\r\n        const typedObjectData: ValueObjectData = { value: value as Primitive };\r\n        objectData = typedObjectData;\r\n      }\r\n\r\n      mapEntries[key] = {\r\n        data: objectData,\r\n      };\r\n    }\r\n\r\n    const initialValueOperation = {\r\n      map: {\r\n        semantics: ObjectsMapSemantics.LWW,\r\n        entries: mapEntries,\r\n      },\r\n    };\r\n\r\n    return {\r\n      initialValueOperation,\r\n      nestedObjectsCreateMsgs,\r\n    };\r\n  }\r\n}\r\n", "export const DEFAULTS = {\r\n  gcInterval: 1000 * 60 * 5, // 5 minutes\r\n  /**\r\n   * The SDK will attempt to use the `objectsGCGracePeriod` value provided by the server in the `connectionDetails` object of the `CONNECTED` event.\r\n   * If the server does not provide this value, the SDK will fall back to this default value.\r\n   *\r\n   * Must be > 2 minutes to ensure we keep tombstones long enough to avoid the possibility of receiving an operation\r\n   * with an earlier serial that would not have been applied if the tombstone still existed.\r\n   *\r\n   * Applies both for map entries tombstones and object tombstones.\r\n   */\r\n  gcGracePeriod: 1000 * 60 * 60 * 24, // 24 hours\r\n};\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport { ROOT_OBJECT_ID } from './constants';\r\nimport { DEFAULTS } from './defaults';\r\nimport { LiveCounter } from './livecounter';\r\nimport { LiveMap } from './livemap';\r\nimport { LiveObject } from './liveobject';\r\nimport { ObjectId } from './objectid';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\n/**\r\n * @internal\r\n * @spec RTO3\r\n */\r\nexport class ObjectsPool {\r\n  private _client: BaseClient;\r\n  private _pool: Map<string, LiveObject>; // RTO3a\r\n  private _gcInterval: ReturnType<typeof setInterval>;\r\n\r\n  constructor(private _realtimeObject: RealtimeObject) {\r\n    this._client = this._realtimeObject.getClient();\r\n    this._pool = this._createInitialPool();\r\n    this._gcInterval = setInterval(() => {\r\n      this._onGCInterval();\r\n    }, DEFAULTS.gcInterval);\r\n    // call nodejs's Timeout.unref to not require Node.js event loop to remain active due to this interval. see https://nodejs.org/api/timers.html#timeoutunref\r\n    this._gcInterval.unref?.();\r\n  }\r\n\r\n  get(objectId: string): LiveObject | undefined {\r\n    return this._pool.get(objectId);\r\n  }\r\n\r\n  getRoot(): LiveMap {\r\n    return this._pool.get(ROOT_OBJECT_ID) as LiveMap;\r\n  }\r\n\r\n  /**\r\n   * Returns all objects in the pool as an iterable.\r\n   * Used internally for operations that need to process all objects.\r\n   */\r\n  getAll(): IterableIterator<LiveObject> {\r\n    return this._pool.values();\r\n  }\r\n\r\n  /**\r\n   * Deletes objects from the pool for which object ids are not found in the provided array of ids.\r\n   */\r\n  deleteExtraObjectIds(objectIds: string[]): void {\r\n    const poolObjectIds = [...this._pool.keys()];\r\n    const extraObjectIds = poolObjectIds.filter((x) => !objectIds.includes(x));\r\n\r\n    extraObjectIds.forEach((x) => this._pool.delete(x));\r\n  }\r\n\r\n  set(objectId: string, liveObject: LiveObject): void {\r\n    this._pool.set(objectId, liveObject);\r\n  }\r\n\r\n  /**\r\n   * Removes all objects but root from the pool and clears the data for root.\r\n   * Does not create a new root object, so the reference to the root object remains the same.\r\n   */\r\n  resetToInitialPool(emitUpdateEvents: boolean): void {\r\n    // clear the pool first and keep the root object\r\n    const root = this.getRoot();\r\n    this._pool.clear();\r\n    this._pool.set(root.getObjectId(), root);\r\n\r\n    // clear the data, this will only clear the root object\r\n    this.clearObjectsData(emitUpdateEvents);\r\n  }\r\n\r\n  /**\r\n   * Clears the data stored for all objects in the pool.\r\n   */\r\n  clearObjectsData(emitUpdateEvents: boolean): void {\r\n    for (const object of this._pool.values()) {\r\n      const update = object.clearData();\r\n      if (emitUpdateEvents) {\r\n        object.notifyUpdated(update);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @spec RTO6 */\r\n  createZeroValueObjectIfNotExists(objectId: string): LiveObject {\r\n    const existingObject = this.get(objectId);\r\n    if (existingObject) {\r\n      return existingObject; // RTO6a\r\n    }\r\n\r\n    const parsedObjectId = ObjectId.fromString(this._client, objectId); // RTO6b\r\n    let zeroValueObject: LiveObject;\r\n    switch (parsedObjectId.type) {\r\n      case 'map': {\r\n        zeroValueObject = LiveMap.zeroValue(this._realtimeObject, objectId); // RTO6b2\r\n        break;\r\n      }\r\n\r\n      case 'counter':\r\n        zeroValueObject = LiveCounter.zeroValue(this._realtimeObject, objectId); // RTO6b3\r\n        break;\r\n    }\r\n\r\n    this.set(objectId, zeroValueObject);\r\n    return zeroValueObject;\r\n  }\r\n\r\n  private _createInitialPool(): Map<string, LiveObject> {\r\n    const pool = new Map<string, LiveObject>();\r\n    // RTO3b\r\n    const root = LiveMap.zeroValue(this._realtimeObject, ROOT_OBJECT_ID);\r\n    pool.set(root.getObjectId(), root);\r\n    return pool;\r\n  }\r\n\r\n  private _onGCInterval(): void {\r\n    const toDelete: string[] = [];\r\n    for (const [objectId, obj] of this._pool.entries()) {\r\n      // tombstoned objects should be removed from the pool if they have been tombstoned for longer than grace period.\r\n      // by removing them from the local pool, LiveObjects plugin no longer keeps a reference to those objects, allowing JS's\r\n      // Garbage Collection to eventually free the memory for those objects, provided the user no longer references them either.\r\n      if (obj.isTombstoned() && Date.now() - obj.tombstonedAt()! >= this._realtimeObject.gcGracePeriod) {\r\n        toDelete.push(objectId);\r\n        continue;\r\n      }\r\n\r\n      obj.onGCInterval();\r\n    }\r\n\r\n    toDelete.forEach((x) => this._pool.delete(x));\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type {\r\n  AnyBatchContext,\r\n  BatchContext,\r\n  CompactedJsonValue,\r\n  CompactedValue,\r\n  Instance,\r\n  Primitive,\r\n  Value,\r\n} from '../../../liveobjects';\r\nimport { DefaultInstance } from './instance';\r\nimport { LiveCounter } from './livecounter';\r\nimport { LiveMap } from './livemap';\r\nimport { RealtimeObject } from './realtimeobject';\r\nimport { RootBatchContext } from './rootbatchcontext';\r\n\r\nexport class DefaultBatchContext implements AnyBatchContext {\r\n  protected _client: BaseClient;\r\n\r\n  constructor(\r\n    protected _realtimeObject: RealtimeObject,\r\n    protected _instance: Instance<Value>,\r\n    protected _rootContext: RootBatchContext,\r\n  ) {\r\n    this._client = this._realtimeObject.getClient();\r\n  }\r\n\r\n  get id(): string | undefined {\r\n    this._throwIfClosed();\r\n    return this._instance.id;\r\n  }\r\n\r\n  get<T extends Value = Value>(key: string): BatchContext<T> | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    this._throwIfClosed();\r\n    const instance = this._instance.get(key);\r\n    if (!instance) {\r\n      return undefined;\r\n    }\r\n    return this._rootContext.wrapInstance(instance) as unknown as BatchContext<T>;\r\n  }\r\n\r\n  value<T extends Primitive = Primitive>(): T | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    this._throwIfClosed();\r\n    return this._instance.value();\r\n  }\r\n\r\n  compact<T extends Value = Value>(): CompactedValue<T> | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    this._throwIfClosed();\r\n    return this._instance.compact();\r\n  }\r\n\r\n  compactJson<T extends Value = Value>(): CompactedJsonValue<T> | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    this._throwIfClosed();\r\n    return this._instance.compactJson();\r\n  }\r\n\r\n  *entries<T extends Record<string, Value>>(): IterableIterator<[keyof T, BatchContext<T[keyof T]>]> {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    this._throwIfClosed();\r\n    for (const [key, value] of this._instance.entries()) {\r\n      const ctx = this._rootContext.wrapInstance(value) as unknown as BatchContext<T[keyof T]>;\r\n      yield [key, ctx];\r\n    }\r\n  }\r\n\r\n  *keys<T extends Record<string, Value>>(): IterableIterator<keyof T> {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    this._throwIfClosed();\r\n    yield* this._instance.keys();\r\n  }\r\n\r\n  *values<T extends Record<string, Value>>(): IterableIterator<BatchContext<T[keyof T]>> {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    this._throwIfClosed();\r\n    for (const [_, value] of this.entries<T>()) {\r\n      yield value;\r\n    }\r\n  }\r\n\r\n  size(): number | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    this._throwIfClosed();\r\n    return this._instance.size();\r\n  }\r\n\r\n  set(key: string, value: Value): void {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n    this._throwIfClosed();\r\n    if (!(this._instance as DefaultInstance<Value>).isLiveMap()) {\r\n      throw new this._client.ErrorInfo('Cannot set a key on a non-LiveMap instance', 92007, 400);\r\n    }\r\n    this._rootContext.queueMessages(async () =>\r\n      LiveMap.createMapSetMessage(this._realtimeObject, this._instance.id!, key, value),\r\n    );\r\n  }\r\n\r\n  remove(key: string): void {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n    this._throwIfClosed();\r\n    if (!(this._instance as DefaultInstance<Value>).isLiveMap()) {\r\n      throw new this._client.ErrorInfo('Cannot remove a key from a non-LiveMap instance', 92007, 400);\r\n    }\r\n    this._rootContext.queueMessages(async () => [\r\n      LiveMap.createMapRemoveMessage(this._realtimeObject, this._instance.id!, key),\r\n    ]);\r\n  }\r\n\r\n  increment(amount?: number): void {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n    this._throwIfClosed();\r\n    if (!(this._instance as DefaultInstance<Value>).isLiveCounter()) {\r\n      throw new this._client.ErrorInfo('Cannot increment a non-LiveCounter instance', 92007, 400);\r\n    }\r\n    this._rootContext.queueMessages(async () => [\r\n      LiveCounter.createCounterIncMessage(this._realtimeObject, this._instance.id!, amount ?? 1),\r\n    ]);\r\n  }\r\n\r\n  decrement(amount?: number): void {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n    this._throwIfClosed();\r\n    if (!(this._instance as DefaultInstance<Value>).isLiveCounter()) {\r\n      throw new this._client.ErrorInfo('Cannot decrement a non-LiveCounter instance', 92007, 400);\r\n    }\r\n    this.increment(-(amount ?? 1));\r\n  }\r\n\r\n  private _throwIfClosed(): void {\r\n    if (this._rootContext.isClosed()) {\r\n      throw new this._client.ErrorInfo('Batch is closed', 40000, 400);\r\n    }\r\n  }\r\n}\r\n", "import type { Instance, Value } from '../../../liveobjects';\r\nimport { DefaultBatchContext } from './batchcontext';\r\nimport { ObjectMessage } from './objectmessage';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\nexport class RootBatchContext extends DefaultBatchContext {\r\n  /** Maps object ids to the corresponding batch context wrappers  */\r\n  private _wrappedInstances: Map<string, DefaultBatchContext> = new Map();\r\n  /**\r\n   * Some object messages require asynchronous I/O during construction\r\n   * (for example, generating an objectId for nested value types).\r\n   * Therefore, messages cannot be constructed immediately during\r\n   * synchronous method calls from batch context methods.\r\n   * Instead, message constructors are queued and executed on flush.\r\n   */\r\n  private _queuedMessageConstructors: (() => Promise<ObjectMessage[]>)[] = [];\r\n  private _isClosed = false;\r\n\r\n  constructor(realtimeObject: RealtimeObject, instance: Instance<Value>) {\r\n    // Pass a placeholder null that will be replaced immediately\r\n    super(realtimeObject, instance, null as any);\r\n    // Set the root context to itself\r\n    this._rootContext = this;\r\n  }\r\n\r\n  /** @internal */\r\n  async flush(): Promise<void> {\r\n    try {\r\n      this.close();\r\n\r\n      const msgs = (await Promise.all(this._queuedMessageConstructors.map((x) => x()))).flat();\r\n\r\n      if (msgs.length > 0) {\r\n        await this._realtimeObject.publish(msgs);\r\n      }\r\n    } finally {\r\n      this._wrappedInstances.clear();\r\n      this._queuedMessageConstructors = [];\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  close(): void {\r\n    this._isClosed = true;\r\n  }\r\n\r\n  /** @internal */\r\n  isClosed(): boolean {\r\n    return this._isClosed;\r\n  }\r\n\r\n  /** @internal */\r\n  wrapInstance(instance: Instance<Value>): DefaultBatchContext {\r\n    const objectId = instance.id;\r\n    if (objectId) {\r\n      // memoize liveobject instances by their object ids\r\n      if (this._wrappedInstances.has(objectId)) {\r\n        return this._wrappedInstances.get(objectId)!;\r\n      }\r\n\r\n      let wrappedInstance = new DefaultBatchContext(this._realtimeObject, instance, this);\r\n      this._wrappedInstances.set(objectId, wrappedInstance);\r\n      return wrappedInstance;\r\n    }\r\n\r\n    return new DefaultBatchContext(this._realtimeObject, instance, this);\r\n  }\r\n\r\n  /** @internal */\r\n  queueMessages(msgCtors: () => Promise<ObjectMessage[]>): void {\r\n    this._queuedMessageConstructors.push(msgCtors);\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type { EventCallback, Subscription } from '../../../ably';\r\nimport type {\r\n  AnyInstance,\r\n  BatchContext,\r\n  BatchFunction,\r\n  CompactedJsonValue,\r\n  CompactedValue,\r\n  Instance,\r\n  InstanceSubscriptionEvent,\r\n  LiveObject as LiveObjectType,\r\n  Primitive,\r\n  Value,\r\n} from '../../../liveobjects';\r\nimport { LiveCounter } from './livecounter';\r\nimport { LiveMap } from './livemap';\r\nimport { LiveObject } from './liveobject';\r\nimport { ObjectMessage } from './objectmessage';\r\nimport { RealtimeObject } from './realtimeobject';\r\nimport { RootBatchContext } from './rootbatchcontext';\r\n\r\nexport interface InstanceEvent {\r\n  /** Object message that caused this event */\r\n  message?: ObjectMessage;\r\n}\r\n\r\nexport class DefaultInstance<T extends Value> implements AnyInstance<T> {\r\n  protected _client: BaseClient;\r\n\r\n  constructor(\r\n    private _realtimeObject: RealtimeObject,\r\n    private _value: T,\r\n  ) {\r\n    this._client = this._realtimeObject.getClient();\r\n  }\r\n\r\n  get id(): string | undefined {\r\n    if (!(this._value instanceof LiveObject)) {\r\n      // no id exists for non-LiveObject types\r\n      return undefined;\r\n    }\r\n    return this._value.getObjectId();\r\n  }\r\n\r\n  /**\r\n   * Returns an in-memory JavaScript object representation of this instance.\r\n   * Buffers are returned as-is.\r\n   * For primitive types, this is an alias for calling value().\r\n   *\r\n   * Use compactJson() for a JSON-serializable representation.\r\n   */\r\n  compact<U extends Value = Value>(): CompactedValue<U> | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (this._value instanceof LiveMap) {\r\n      return this._value.compact() as CompactedValue<U>;\r\n    }\r\n\r\n    return this.value() as CompactedValue<U>;\r\n  }\r\n\r\n  /**\r\n   * Returns a JSON-serializable representation of this instance.\r\n   * Buffers are converted to base64 strings.\r\n   *\r\n   * Use compact() for an in-memory representation.\r\n   */\r\n  compactJson<U extends Value = Value>(): CompactedJsonValue<U> | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (this._value instanceof LiveMap) {\r\n      return this._value.compactJson() as CompactedJsonValue<U>;\r\n    }\r\n\r\n    const value = this.value();\r\n\r\n    if (this._client.Platform.BufferUtils.isBuffer(value)) {\r\n      return this._client.Platform.BufferUtils.base64Encode(value) as CompactedJsonValue<U>;\r\n    }\r\n\r\n    return value as CompactedJsonValue<U>;\r\n  }\r\n\r\n  get<U extends Value = Value>(key: string): Instance<U> | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (!(this._value instanceof LiveMap)) {\r\n      // can't get a key from a non-LiveMap type\r\n      return undefined;\r\n    }\r\n\r\n    if (typeof key !== 'string') {\r\n      throw new this._client.ErrorInfo(`Key must be a string: ${key}`, 40003, 400);\r\n    }\r\n\r\n    const value = this._value.get(key);\r\n    if (value === undefined) {\r\n      return undefined;\r\n    }\r\n    return new DefaultInstance<U>(this._realtimeObject, value) as unknown as Instance<U>;\r\n  }\r\n\r\n  value<U extends number | Primitive = number | Primitive>(): U | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (this._value instanceof LiveObject) {\r\n      if (this._value instanceof LiveCounter) {\r\n        return this._value.value() as U;\r\n      }\r\n\r\n      // for other LiveObject types, return undefined\r\n      return undefined;\r\n    } else if (\r\n      this._client.Platform.BufferUtils.isBuffer(this._value) ||\r\n      typeof this._value === 'string' ||\r\n      typeof this._value === 'number' ||\r\n      typeof this._value === 'boolean' ||\r\n      typeof this._value === 'object' ||\r\n      this._value === null\r\n    ) {\r\n      // primitive type - return it\r\n      return this._value as unknown as U;\r\n    } else {\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MAJOR,\r\n        'DefaultInstance.value()',\r\n        `unexpected value type for instance, resolving to undefined; value=${this._value}; type=${typeof this._value}`,\r\n      );\r\n      // unknown type - return undefined\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  *entries<U extends Record<string, Value>>(): IterableIterator<[keyof U, Instance<U[keyof U]>]> {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (!(this._value instanceof LiveMap)) {\r\n      // return empty iterator for non-LiveMap objects\r\n      return;\r\n    }\r\n\r\n    for (const [key, value] of this._value.entries()) {\r\n      const instance = new DefaultInstance<U[keyof U]>(this._realtimeObject, value) as unknown as Instance<U[keyof U]>;\r\n      yield [key, instance];\r\n    }\r\n  }\r\n\r\n  *keys<U extends Record<string, Value>>(): IterableIterator<keyof U> {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (!(this._value instanceof LiveMap)) {\r\n      // return empty iterator for non-LiveMap objects\r\n      return;\r\n    }\r\n\r\n    yield* this._value.keys();\r\n  }\r\n\r\n  *values<U extends Record<string, Value>>(): IterableIterator<Instance<U[keyof U]>> {\r\n    for (const [_, value] of this.entries<U>()) {\r\n      yield value;\r\n    }\r\n  }\r\n\r\n  size(): number | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (!(this._value instanceof LiveMap)) {\r\n      // can't return size for non-LiveMap objects\r\n      return undefined;\r\n    }\r\n    return this._value.size();\r\n  }\r\n\r\n  set<U extends Record<string, Value> = Record<string, Value>>(\r\n    key: keyof U & string,\r\n    value: U[keyof U],\r\n  ): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n    if (!(this._value instanceof LiveMap)) {\r\n      throw new this._client.ErrorInfo('Cannot set a key on a non-LiveMap instance', 92007, 400);\r\n    }\r\n    return this._value.set(key, value);\r\n  }\r\n\r\n  remove<U extends Record<string, Value> = Record<string, Value>>(key: keyof U & string): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n    if (!(this._value instanceof LiveMap)) {\r\n      throw new this._client.ErrorInfo('Cannot remove a key from a non-LiveMap instance', 92007, 400);\r\n    }\r\n    return this._value.remove(key);\r\n  }\r\n\r\n  increment(amount?: number | undefined): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n    if (!(this._value instanceof LiveCounter)) {\r\n      throw new this._client.ErrorInfo('Cannot increment a non-LiveCounter instance', 92007, 400);\r\n    }\r\n    return this._value.increment(amount ?? 1);\r\n  }\r\n\r\n  decrement(amount?: number | undefined): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n    if (!(this._value instanceof LiveCounter)) {\r\n      throw new this._client.ErrorInfo('Cannot decrement a non-LiveCounter instance', 92007, 400);\r\n    }\r\n    return this._value.decrement(amount ?? 1);\r\n  }\r\n\r\n  subscribe(listener: EventCallback<InstanceSubscriptionEvent<T>>): Subscription {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (!(this._value instanceof LiveObject)) {\r\n      throw new this._client.ErrorInfo('Cannot subscribe to a non-LiveObject instance', 92007, 400);\r\n    }\r\n\r\n    return this._value.subscribe((event: InstanceEvent) => {\r\n      listener({\r\n        object: this as unknown as Instance<T>,\r\n        message: event.message?.toUserFacingMessage(this._realtimeObject.getChannel()),\r\n      });\r\n    });\r\n  }\r\n\r\n  subscribeIterator(): AsyncIterableIterator<InstanceSubscriptionEvent<T>> {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (!(this._value instanceof LiveObject)) {\r\n      throw new this._client.ErrorInfo('Cannot subscribe to a non-LiveObject instance', 92007, 400);\r\n    }\r\n\r\n    return this._client.Utils.listenerToAsyncIterator((listener) => {\r\n      const { unsubscribe } = this.subscribe(listener);\r\n      return unsubscribe;\r\n    });\r\n  }\r\n\r\n  async batch<T extends LiveObjectType = LiveObjectType>(fn: BatchFunction<T>): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n\r\n    if (!(this._value instanceof LiveObject)) {\r\n      throw new this._client.ErrorInfo('Cannot batch operations on a non-LiveObject instance', 92007, 400);\r\n    }\r\n\r\n    const ctx = new RootBatchContext(this._realtimeObject, this);\r\n    try {\r\n      fn(ctx as unknown as BatchContext<T>);\r\n      await ctx.flush();\r\n    } finally {\r\n      ctx.close();\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public isLiveMap(): boolean {\r\n    return this._value instanceof LiveMap;\r\n  }\r\n\r\n  /** @internal */\r\n  public isLiveCounter(): boolean {\r\n    return this._value instanceof LiveCounter;\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type { EventCallback, Subscription } from '../../../ably';\r\nimport type {\r\n  AnyPathObject,\r\n  BatchContext,\r\n  BatchFunction,\r\n  CompactedJsonValue,\r\n  CompactedValue,\r\n  Instance,\r\n  LiveObject as LiveObjectType,\r\n  PathObject,\r\n  PathObjectSubscriptionEvent,\r\n  PathObjectSubscriptionOptions,\r\n  Primitive,\r\n  Value,\r\n} from '../../../liveobjects';\r\nimport { DefaultInstance } from './instance';\r\nimport { LiveCounter } from './livecounter';\r\nimport { LiveMap } from './livemap';\r\nimport { LiveObject } from './liveobject';\r\nimport { RealtimeObject } from './realtimeobject';\r\nimport { RootBatchContext } from './rootbatchcontext';\r\n\r\n/**\r\n * Implementation of AnyPathObject interface.\r\n * Provides a generic implementation that can handle any type of PathObject operations.\r\n */\r\nexport class DefaultPathObject implements AnyPathObject {\r\n  private _client: BaseClient;\r\n  private _path: string[];\r\n\r\n  constructor(\r\n    private _realtimeObject: RealtimeObject,\r\n    private _root: LiveMap,\r\n    path: string[],\r\n    parent?: DefaultPathObject,\r\n  ) {\r\n    this._client = this._realtimeObject.getClient();\r\n    // copy parent path array\r\n    this._path = [...(parent?._path ?? []), ...path];\r\n  }\r\n\r\n  /**\r\n   * Returns the fully-qualified string path that this PathObject represents.\r\n   * Path segments with dots in them are escaped with a backslash.\r\n   * For example, a path with segments `['a', 'b.c', 'd']` will be represented as `a.b\\.c.d`.\r\n   */\r\n  path(): string {\r\n    // escape dots in path segments to avoid ambiguity in the joined path\r\n    return this._escapePath(this._path).join('.');\r\n  }\r\n\r\n  /**\r\n   * Returns an in-memory JavaScript object representation of the object at this path.\r\n   * If the path does not resolve to any specific entry, returns `undefined`.\r\n   * Buffers are returned as-is.\r\n   * For primitive types, this is an alias for calling value().\r\n   *\r\n   * Use compactJson() for a JSON-serializable representation.\r\n   */\r\n  compact<U extends Value = Value>(): CompactedValue<U> | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    try {\r\n      const resolved = this._resolvePath(this._path);\r\n\r\n      if (resolved instanceof LiveMap) {\r\n        return resolved.compact() as CompactedValue<U>;\r\n      }\r\n\r\n      return this.value() as CompactedValue<U>;\r\n    } catch (error) {\r\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\r\n        // ignore path resolution errors and return undefined\r\n        return undefined;\r\n      }\r\n      // rethrow everything else\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a JSON-serializable representation of the object at this path.\r\n   * If the path does not resolve to any specific entry, returns `undefined`.\r\n   * Buffers are converted to base64 strings.\r\n   *\r\n   * Use compact() for an in-memory representation.\r\n   */\r\n  compactJson<U extends Value = Value>(): CompactedJsonValue<U> | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    try {\r\n      const resolved = this._resolvePath(this._path);\r\n\r\n      if (resolved instanceof LiveMap) {\r\n        return resolved.compactJson() as CompactedJsonValue<U>;\r\n      }\r\n\r\n      const value = this.value();\r\n\r\n      if (this._client.Platform.BufferUtils.isBuffer(value)) {\r\n        return this._client.Platform.BufferUtils.base64Encode(value) as CompactedJsonValue<U>;\r\n      }\r\n\r\n      return value as CompactedJsonValue<U>;\r\n    } catch (error) {\r\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\r\n        // ignore path resolution errors and return undefined\r\n        return undefined;\r\n      }\r\n      // rethrow everything else\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Navigate to a child path within the collection by obtaining a PathObject for that path.\r\n   * The next path segment in a collection is identified with a string key.\r\n   */\r\n  get<U extends Value = Value>(key: string): PathObject<U> {\r\n    if (typeof key !== 'string') {\r\n      throw new this._client.ErrorInfo(`Path key must be a string: ${key}`, 40003, 400);\r\n    }\r\n    return new DefaultPathObject(this._realtimeObject, this._root, [key], this) as unknown as PathObject<U>;\r\n  }\r\n\r\n  /**\r\n   * Get a PathObject at the specified path relative to this object\r\n   */\r\n  at<U extends Value = Value>(path: string): PathObject<U> {\r\n    if (typeof path !== 'string') {\r\n      throw new this._client.ErrorInfo(`Path must be a string: ${path}`, 40003, 400);\r\n    }\r\n\r\n    // We need to split the path on unescaped dots, i.e. dots not preceded by a backslash.\r\n    // The easy way to do this would be to use \"path.split(/(?<!\\\\)\\./)\" to split on unescaped dots\r\n    // and then call \".replace(/\\\\\\./g, '.')\" on each segment.\r\n    // However, that uses negative lookbehind which is not supported in some browsers we aim to support\r\n    // (based on https://github.com/ably/ably-js/pull/2037/files), like Safari before 16.4.\r\n    // See full list https://caniuse.com/?search=negative%20lookbehind.\r\n    // So instead we do splitting manually.\r\n    const pathAsArray: string[] = [];\r\n    let currentSegment = '';\r\n    let escaping = false;\r\n    for (const char of path) {\r\n      if (escaping) {\r\n        // keep the escape character if not escaping a dot\r\n        // this is to replicate the \".replace(/\\\\\\./g, '.')\" behavior where only escaped dots are unescaped\r\n        if (char !== '.') currentSegment += '\\\\';\r\n        currentSegment += char;\r\n        escaping = false;\r\n        continue;\r\n      }\r\n      if (char === '\\\\') {\r\n        escaping = true;\r\n        continue;\r\n      }\r\n      if (char === '.') {\r\n        pathAsArray.push(currentSegment);\r\n        currentSegment = '';\r\n        continue;\r\n      }\r\n      currentSegment += char;\r\n    }\r\n    if (escaping) {\r\n      currentSegment += '\\\\';\r\n    }\r\n    pathAsArray.push(currentSegment);\r\n\r\n    return new DefaultPathObject(this._realtimeObject, this._root, pathAsArray, this) as unknown as PathObject<U>;\r\n  }\r\n\r\n  /**\r\n   * Get the current value at this path.\r\n   * If the path does not resolve to any specific entry, returns `undefined`.\r\n   */\r\n  value<U extends number | Primitive = number | Primitive>(): U | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    try {\r\n      const resolved = this._resolvePath(this._path);\r\n\r\n      if (resolved instanceof LiveObject) {\r\n        if (resolved instanceof LiveCounter) {\r\n          return resolved.value() as U;\r\n        }\r\n\r\n        // can't resolve value for other live object types\r\n        return undefined;\r\n      } else if (\r\n        this._client.Platform.BufferUtils.isBuffer(resolved) ||\r\n        typeof resolved === 'string' ||\r\n        typeof resolved === 'number' ||\r\n        typeof resolved === 'boolean' ||\r\n        typeof resolved === 'object' ||\r\n        resolved === null\r\n      ) {\r\n        // primitive type - return it\r\n        return resolved as U;\r\n      } else {\r\n        this._client.Logger.logAction(\r\n          this._client.logger,\r\n          this._client.Logger.LOG_MAJOR,\r\n          'PathObject.value()',\r\n          `unexpected value type at path, resolving to undefined; path=${this._escapePath(this._path).join('.')}`,\r\n        );\r\n        // unknown type - return undefined\r\n        return undefined;\r\n      }\r\n    } catch (error) {\r\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\r\n        // ignore path resolution errors and return undefined\r\n        return undefined;\r\n      }\r\n      // rethrow everything else\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  instance<T extends Value = Value>(): Instance<T> | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    try {\r\n      return this._resolveInstance();\r\n    } catch (error) {\r\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\r\n        // ignore path resolution errors and return undefined\r\n        return undefined;\r\n      }\r\n      // rethrow everything else\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an iterator of [key, value] pairs for LiveMap entries\r\n   */\r\n  *entries<U extends Record<string, Value>>(): IterableIterator<[keyof U, PathObject<U[keyof U]>]> {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    try {\r\n      const resolved = this._resolvePath(this._path);\r\n      if (!(resolved instanceof LiveMap)) {\r\n        // return empty iterator for non-LiveMap objects\r\n        return;\r\n      }\r\n\r\n      for (const [key, _] of resolved.entries()) {\r\n        const value = new DefaultPathObject(this._realtimeObject, this._root, [key], this) as unknown as PathObject<\r\n          U[keyof U]\r\n        >;\r\n        yield [key, value];\r\n      }\r\n    } catch (error) {\r\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\r\n        // ignore path resolution errors and return empty iterator\r\n        return;\r\n      }\r\n      // rethrow everything else\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an iterator of keys for LiveMap entries\r\n   */\r\n  *keys<U extends Record<string, Value>>(): IterableIterator<keyof U> {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    try {\r\n      const resolved = this._resolvePath(this._path);\r\n      if (!(resolved instanceof LiveMap)) {\r\n        // return empty iterator for non-LiveMap objects\r\n        return;\r\n      }\r\n\r\n      yield* resolved.keys();\r\n    } catch (error) {\r\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\r\n        // ignore path resolution errors and return empty iterator\r\n        return;\r\n      }\r\n      // rethrow everything else\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an iterator of PathObject values for LiveMap entries\r\n   */\r\n  *values<U extends Record<string, Value>>(): IterableIterator<PathObject<U[keyof U]>> {\r\n    for (const [_, value] of this.entries<U>()) {\r\n      yield value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the size of the collection at this path\r\n   */\r\n  size(): number | undefined {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n\r\n    try {\r\n      const resolved = this._resolvePath(this._path);\r\n      if (!(resolved instanceof LiveMap)) {\r\n        // can't return size for non-LiveMap objects\r\n        return undefined;\r\n      }\r\n\r\n      return resolved.size();\r\n    } catch (error) {\r\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\r\n        // ignore path resolution errors and return undefined\r\n        return undefined;\r\n      }\r\n      // rethrow everything else\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  set<T extends Record<string, Value> = Record<string, Value>>(\r\n    key: keyof T & string,\r\n    value: T[keyof T],\r\n  ): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n\r\n    const resolved = this._resolvePath(this._path);\r\n    if (!(resolved instanceof LiveMap)) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot set a key on a non-LiveMap object at path: ${this._escapePath(this._path).join('.')}`,\r\n        92007,\r\n        400,\r\n      );\r\n    }\r\n\r\n    return resolved.set(key, value);\r\n  }\r\n\r\n  remove<T extends Record<string, Value> = Record<string, Value>>(key: keyof T & string): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n\r\n    const resolved = this._resolvePath(this._path);\r\n    if (!(resolved instanceof LiveMap)) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot remove a key from a non-LiveMap object at path: ${this._escapePath(this._path).join('.')}`,\r\n        92007,\r\n        400,\r\n      );\r\n    }\r\n\r\n    return resolved.remove(key);\r\n  }\r\n\r\n  increment(amount?: number): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n\r\n    const resolved = this._resolvePath(this._path);\r\n    if (!(resolved instanceof LiveCounter)) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot increment a non-LiveCounter object at path: ${this._escapePath(this._path).join('.')}`,\r\n        92007,\r\n        400,\r\n      );\r\n    }\r\n\r\n    return resolved.increment(amount ?? 1);\r\n  }\r\n\r\n  decrement(amount?: number): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n\r\n    const resolved = this._resolvePath(this._path);\r\n    if (!(resolved instanceof LiveCounter)) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot decrement a non-LiveCounter object at path: ${this._escapePath(this._path).join('.')}`,\r\n        92007,\r\n        400,\r\n      );\r\n    }\r\n\r\n    return resolved.decrement(amount ?? 1);\r\n  }\r\n\r\n  /**\r\n   * Subscribes to changes to the object (and, by default, its children) or to a primitive value at this path.\r\n   *\r\n   * PathObject subscriptions rely on LiveObject instances to broadcast updates through a subscription\r\n   * registry for the paths they occupy in the object graph. These updates are then routed to the appropriate\r\n   * PathObject subscriptions based on their paths.\r\n   *\r\n   * When the underlying object or primitive value at this path is changed via an update to its parent\r\n   * collection (for example, if a new LiveCounter instance is set at this path, or a key's value is\r\n   * changed in a parent LiveMap), a subscription to this path will receive a separate **non-bubbling**\r\n   * event indicating the change. This event is not propagated to parent path subscriptions, as they will\r\n   * receive their own event for changes made directly to the object at their respective paths.\r\n   *\r\n   * PathObject subscriptions observe nested changes by default. Optional `depth` parameter can be provided\r\n   * to control this behavior. A subscription depth of `1` means that only direct updates to the underlying\r\n   * object - and changes that overwrite the value at this path (via parent object updates) - will trigger events.\r\n   */\r\n\r\n  subscribe(\r\n    listener: EventCallback<PathObjectSubscriptionEvent>,\r\n    options?: PathObjectSubscriptionOptions,\r\n  ): Subscription {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    return this._realtimeObject.getPathObjectSubscriptionRegister().subscribe(this._path, listener, options ?? {});\r\n  }\r\n\r\n  subscribeIterator(options?: PathObjectSubscriptionOptions): AsyncIterableIterator<PathObjectSubscriptionEvent> {\r\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\r\n    return this._client.Utils.listenerToAsyncIterator((listener) => {\r\n      const { unsubscribe } = this.subscribe(listener, options);\r\n      return unsubscribe;\r\n    });\r\n  }\r\n\r\n  async batch<T extends LiveObjectType = LiveObjectType>(fn: BatchFunction<T>): Promise<void> {\r\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\r\n\r\n    const instance = this._resolveInstance();\r\n    if (!instance) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot batch operations on a non-LiveObject at path: ${this._escapePath(this._path).join('.')}`,\r\n        92007,\r\n        400,\r\n      );\r\n    }\r\n\r\n    const ctx = new RootBatchContext(this._realtimeObject, instance);\r\n    try {\r\n      fn(ctx as unknown as BatchContext<T>);\r\n      await ctx.flush();\r\n    } finally {\r\n      ctx.close();\r\n    }\r\n  }\r\n\r\n  private _resolvePath(path: string[]): Value {\r\n    let current: Value = this._root;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n      const segment = path[i];\r\n\r\n      if (!(current instanceof LiveMap)) {\r\n        throw new this._client.ErrorInfo(\r\n          `Cannot resolve path segment '${segment}' on non-collection type at path: ${this._escapePath(path.slice(0, i)).join('.')}`,\r\n          92005,\r\n          400,\r\n        );\r\n      }\r\n\r\n      const next: Value | undefined = current.get(segment);\r\n\r\n      if (next === undefined) {\r\n        throw new this._client.ErrorInfo(\r\n          `Could not resolve value at path: ${this._escapePath(path.slice(0, i + 1)).join('.')}`,\r\n          92005,\r\n          400,\r\n        );\r\n      }\r\n\r\n      current = next;\r\n    }\r\n\r\n    return current;\r\n  }\r\n\r\n  private _resolveInstance<T extends Value = Value>(): Instance<T> | undefined {\r\n    const value = this._resolvePath(this._path);\r\n\r\n    if (value instanceof LiveObject) {\r\n      // only return an Instance for LiveObject values\r\n      return new DefaultInstance(this._realtimeObject, value) as unknown as Instance<T>;\r\n    }\r\n\r\n    // return undefined for non live objects\r\n    return undefined;\r\n  }\r\n\r\n  private _escapePath(path: string[]): string[] {\r\n    return path.map((x) => x.replace(/\\./g, '\\\\.'));\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type { EventCallback, Subscription } from '../../../ably';\r\nimport type { PathObjectSubscriptionEvent, PathObjectSubscriptionOptions } from '../../../liveobjects';\r\nimport { ObjectMessage } from './objectmessage';\r\nimport { DefaultPathObject } from './pathobject';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\n/**\r\n * Internal subscription entry that tracks a listener and its options\r\n */\r\nexport interface SubscriptionEntry {\r\n  /** The listener function to call when events match */\r\n  listener: EventCallback<PathObjectSubscriptionEvent>;\r\n  /** The subscription options including depth */\r\n  options: PathObjectSubscriptionOptions;\r\n  /** The path this subscription is registered for */\r\n  path: string[];\r\n}\r\n\r\n/**\r\n * Event data that LiveObjects provide when notifying of changes\r\n */\r\nexport interface PathEvent {\r\n  /** The path where the event occurred */\r\n  path: string[];\r\n  /** Object message that caused this event */\r\n  message?: ObjectMessage;\r\n  /** Whether this event should bubble up to parent paths. Defaults to true if not specified. */\r\n  bubbles?: boolean;\r\n}\r\n\r\n/**\r\n * Registry for managing PathObject subscriptions and routing events to appropriate listeners.\r\n * Handles depth-based filtering for subscription matching.\r\n *\r\n * @internal\r\n */\r\nexport class PathObjectSubscriptionRegister {\r\n  private _client: BaseClient;\r\n  private _subscriptions: Map<string, SubscriptionEntry> = new Map();\r\n  private _nextSubscriptionId = 0;\r\n\r\n  constructor(private _realtimeObject: RealtimeObject) {\r\n    this._client = this._realtimeObject.getClient();\r\n  }\r\n\r\n  /**\r\n   * Registers a new subscription for the given path.\r\n   *\r\n   * @param path - Array of keys representing the path to subscribe to\r\n   * @param listener - Function to call when matching events occur\r\n   * @param options - Subscription options including depth parameter\r\n   * @returns Unsubscribe function\r\n   */\r\n  subscribe(\r\n    path: string[],\r\n    listener: EventCallback<PathObjectSubscriptionEvent>,\r\n    options: PathObjectSubscriptionOptions,\r\n  ): Subscription {\r\n    if (options == null || typeof options !== 'object') {\r\n      throw new this._client.ErrorInfo('Subscription options must be an object', 40000, 400);\r\n    }\r\n\r\n    if (options.depth !== undefined && options.depth <= 0) {\r\n      throw new this._client.ErrorInfo(\r\n        'Subscription depth must be greater than 0 or undefined for infinite depth',\r\n        40003,\r\n        400,\r\n      );\r\n    }\r\n\r\n    const subscriptionId = (this._nextSubscriptionId++).toString();\r\n    const entry: SubscriptionEntry = {\r\n      listener,\r\n      options,\r\n      path: [...path], // Make a copy to avoid external mutations\r\n    };\r\n\r\n    this._subscriptions.set(subscriptionId, entry);\r\n\r\n    return {\r\n      unsubscribe: () => {\r\n        this._subscriptions.delete(subscriptionId);\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Notifies all matching subscriptions about an event that occurred at the specified path(s).\r\n   *\r\n   * @param events - Array of path events to process\r\n   */\r\n  notifyPathEvents(events: PathEvent[]): void {\r\n    for (const event of events) {\r\n      this._processEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processes a single path event and calls all matching subscription listeners.\r\n   */\r\n  private _processEvent(event: PathEvent): void {\r\n    for (const subscription of this._subscriptions.values()) {\r\n      if (!this._shouldNotifySubscription(subscription, event)) {\r\n        continue;\r\n      }\r\n\r\n      try {\r\n        const subscriptionEvent: PathObjectSubscriptionEvent = {\r\n          object: new DefaultPathObject(this._realtimeObject, this._realtimeObject.getPool().getRoot(), event.path),\r\n          message: event.message?.toUserFacingMessage(this._realtimeObject.getChannel()),\r\n        };\r\n\r\n        subscription.listener(subscriptionEvent);\r\n      } catch (error) {\r\n        // Log error but don't let one subscription failure affect others\r\n        this._client.Logger.logAction(\r\n          this._client.logger,\r\n          this._client.Logger.LOG_MINOR,\r\n          'PathObjectSubscriptionRegister._processEvent()',\r\n          `Error in PathObject subscription listener; path=${JSON.stringify(event.path)}, error=${error}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determines if a subscription should be notified about an event at the given path.\r\n   * Implements depth-based filtering logic and bubbling control.\r\n   *\r\n   * Depth examples (when event.bubbles is true):\r\n   * - subscription at [\"users\"] with depth=undefined: matches [\"users\"], [\"users\", \"emma\"], [\"users\", \"emma\", \"visits\"], etc.\r\n   * - subscription at [\"users\"] with depth=1: matches [\"users\"] only\r\n   * - subscription at [\"users\"] with depth=2: matches [\"users\"], [\"users\", \"emma\"] only\r\n   * - subscription at [\"users\"] with depth=3: matches [\"users\"], [\"users\", \"emma\"], [\"users\", \"emma\", \"visits\"] only\r\n   *\r\n   * Non-bubbling examples (when event.bubbles is false):\r\n   * - Event at [\"users\", \"emma\"] with bubbles=false:\r\n   *   - subscription at [\"users\"]: NOT triggered (no bubbling to parent)\r\n   *   - subscription at [\"users\", \"emma\"]: triggered (exact path match)\r\n   *\r\n   * The depth calculation is: eventPath.length - subscriptionPath.length + 1\r\n   * This means:\r\n   * - Same level ([\"users\"] -> [\"users\"]): 1 - 1 + 1 = 1 (depth=1)\r\n   * - One level deeper ([\"users\"] -> [\"users\", \"emma\"]): 2 - 1 + 1 = 2 (depth=2)\r\n   * - Two levels deeper ([\"users\"] -> [\"users\", \"emma\", \"visits\"]): 3 - 1 + 1 = 3 (depth=3)\r\n   */\r\n  private _shouldNotifySubscription(subscription: SubscriptionEntry, event: PathEvent): boolean {\r\n    const subPath = subscription.path;\r\n    const eventPath = event.path;\r\n    const depth = subscription.options.depth;\r\n    const bubbles = event.bubbles !== false; // Default to true if not specified\r\n\r\n    // If event doesn't bubble, only match exact paths\r\n    if (!bubbles) {\r\n      return this._pathsAreEqual(eventPath, subPath);\r\n    }\r\n\r\n    // Otherwise check if the event path starts with the subscription path\r\n    if (!this._pathStartsWith(eventPath, subPath)) {\r\n      return false;\r\n    }\r\n\r\n    // If depth is undefined, allow infinite depth\r\n    if (depth === undefined) {\r\n      return true;\r\n    }\r\n\r\n    // Otherwise calculate the relative depth from subscription path to event path\r\n    const relativeDepth = eventPath.length - subPath.length + 1;\r\n\r\n    // Check if the event is within the allowed depth\r\n    return relativeDepth <= depth;\r\n  }\r\n\r\n  /**\r\n   * Checks if eventPath starts with subscriptionPath.\r\n   *\r\n   * @param eventPath - The path where the event occurred\r\n   * @param subscriptionPath - The path that was subscribed to\r\n   * @returns true if eventPath starts with subscriptionPath\r\n   */\r\n  private _pathStartsWith(eventPath: string[], subscriptionPath: string[]): boolean {\r\n    if (subscriptionPath.length > eventPath.length) {\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0; i < subscriptionPath.length; i++) {\r\n      if (eventPath[i] !== subscriptionPath[i]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if two paths are exactly equal.\r\n   *\r\n   * @param path1 - First path to compare\r\n   * @param path2 - Second path to compare\r\n   * @returns true if paths are exactly equal\r\n   */\r\n  private _pathsAreEqual(path1: string[], path2: string[]): boolean {\r\n    return this._client.Utils.arrEquals(path1, path2);\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\r\nimport { ObjectMessage } from './objectmessage';\r\nimport { RealtimeObject } from './realtimeobject';\r\n\r\nexport interface LiveObjectDataEntry {\r\n  objectMessage: ObjectMessage;\r\n  objectType: 'LiveMap' | 'LiveCounter';\r\n}\r\n\r\nexport interface LiveCounterDataEntry extends LiveObjectDataEntry {\r\n  objectType: 'LiveCounter';\r\n}\r\n\r\nexport interface LiveMapDataEntry extends LiveObjectDataEntry {\r\n  objectType: 'LiveMap';\r\n}\r\n\r\nexport type AnyDataEntry = LiveCounterDataEntry | LiveMapDataEntry;\r\n\r\n// TODO: investigate if this class is still needed after changes with createOp. objects are now initialized from the stateObject and this class does minimal processing\r\n/**\r\n * @internal\r\n */\r\nexport class SyncObjectsDataPool {\r\n  private _client: BaseClient;\r\n  private _channel: RealtimeChannel;\r\n  private _pool: Map<string, AnyDataEntry>;\r\n\r\n  constructor(private _realtimeObject: RealtimeObject) {\r\n    this._client = this._realtimeObject.getClient();\r\n    this._channel = this._realtimeObject.getChannel();\r\n    this._pool = new Map<string, AnyDataEntry>();\r\n  }\r\n\r\n  entries() {\r\n    return this._pool.entries();\r\n  }\r\n\r\n  size(): number {\r\n    return this._pool.size;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this._pool.size === 0;\r\n  }\r\n\r\n  clear(): void {\r\n    this._pool.clear();\r\n  }\r\n\r\n  applyObjectSyncMessages(objectMessages: ObjectMessage[]): void {\r\n    for (const objectMessage of objectMessages) {\r\n      if (!objectMessage.object) {\r\n        this._client.Logger.logAction(\r\n          this._client.logger,\r\n          this._client.Logger.LOG_MAJOR,\r\n          'SyncObjectsDataPool.applyObjectSyncMessages()',\r\n          `object message is received during OBJECT_SYNC without 'object' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\r\n        );\r\n        continue;\r\n      }\r\n\r\n      const objectState = objectMessage.object;\r\n\r\n      if (objectState.counter) {\r\n        this._pool.set(objectState.objectId, this._createLiveCounterDataEntry(objectMessage));\r\n      } else if (objectState.map) {\r\n        this._pool.set(objectState.objectId, this._createLiveMapDataEntry(objectMessage));\r\n      } else {\r\n        this._client.Logger.logAction(\r\n          this._client.logger,\r\n          this._client.Logger.LOG_MAJOR,\r\n          'SyncObjectsDataPool.applyObjectSyncMessages()',\r\n          `received unsupported object state message during OBJECT_SYNC, expected 'counter' or 'map' to be present, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private _createLiveCounterDataEntry(objectMessage: ObjectMessage): LiveCounterDataEntry {\r\n    const newEntry: LiveCounterDataEntry = {\r\n      objectMessage,\r\n      objectType: 'LiveCounter',\r\n    };\r\n\r\n    return newEntry;\r\n  }\r\n\r\n  private _createLiveMapDataEntry(objectMessage: ObjectMessage): LiveMapDataEntry {\r\n    const newEntry: LiveMapDataEntry = {\r\n      objectMessage,\r\n      objectType: 'LiveMap',\r\n    };\r\n\r\n    return newEntry;\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\r\nimport type EventEmitter from 'common/lib/util/eventemitter';\r\nimport type { ChannelState, StatusSubscription } from '../../../ably';\r\nimport type * as ObjectsApi from '../../../liveobjects';\r\nimport { DEFAULTS } from './defaults';\r\nimport { LiveCounter } from './livecounter';\r\nimport { LiveMap } from './livemap';\r\nimport { LiveObject, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\r\nimport { ObjectMessage, ObjectOperationAction } from './objectmessage';\r\nimport { ObjectsPool } from './objectspool';\r\nimport { DefaultPathObject } from './pathobject';\r\nimport { PathObjectSubscriptionRegister } from './pathobjectsubscriptionregister';\r\nimport { SyncObjectsDataPool } from './syncobjectsdatapool';\r\n\r\nexport enum ObjectsEvent {\r\n  syncing = 'syncing',\r\n  synced = 'synced',\r\n}\r\n\r\nexport enum ObjectsState {\r\n  initialized = 'initialized',\r\n  syncing = 'syncing',\r\n  synced = 'synced',\r\n}\r\n\r\nconst StateToEventsMap: Record<ObjectsState, ObjectsEvent | undefined> = {\r\n  initialized: undefined,\r\n  syncing: ObjectsEvent.syncing,\r\n  synced: ObjectsEvent.synced,\r\n};\r\n\r\nexport type ObjectsEventCallback = () => void;\r\n\r\nexport class RealtimeObject {\r\n  gcGracePeriod: number;\r\n\r\n  private _client: BaseClient;\r\n  private _channel: RealtimeChannel;\r\n  private _state: ObjectsState;\r\n  // composition over inheritance since we cannot import class directly into plugin code.\r\n  // instead we obtain a class type from the client\r\n  private _eventEmitterInternal: EventEmitter;\r\n  // related to RTC10, should have a separate EventEmitter for users of the library\r\n  private _eventEmitterPublic: EventEmitter;\r\n  private _objectsPool: ObjectsPool; // RTO3\r\n  private _syncObjectsDataPool: SyncObjectsDataPool;\r\n  private _currentSyncId: string | undefined;\r\n  private _currentSyncCursor: string | undefined;\r\n  private _bufferedObjectOperations: ObjectMessage[];\r\n  private _pathObjectSubscriptionRegister: PathObjectSubscriptionRegister;\r\n\r\n  // Used by tests\r\n  static _DEFAULTS = DEFAULTS;\r\n\r\n  constructor(channel: RealtimeChannel) {\r\n    this._channel = channel;\r\n    this._client = channel.client;\r\n    this._state = ObjectsState.initialized;\r\n    this._eventEmitterInternal = new this._client.EventEmitter(this._client.logger);\r\n    this._eventEmitterPublic = new this._client.EventEmitter(this._client.logger);\r\n    this._objectsPool = new ObjectsPool(this);\r\n    this._syncObjectsDataPool = new SyncObjectsDataPool(this);\r\n    this._bufferedObjectOperations = [];\r\n    this._pathObjectSubscriptionRegister = new PathObjectSubscriptionRegister(this);\r\n    // use server-provided objectsGCGracePeriod if available, and subscribe to new connectionDetails that can be emitted as part of the RTN24\r\n    this.gcGracePeriod =\r\n      this._channel.connectionManager.connectionDetails?.objectsGCGracePeriod ?? DEFAULTS.gcGracePeriod;\r\n    this._channel.connectionManager.on('connectiondetails', (details: Record<string, any>) => {\r\n      this.gcGracePeriod = details.objectsGCGracePeriod ?? DEFAULTS.gcGracePeriod;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * When called without a type variable, we return a default root type which is based on globally defined interface for Objects feature.\r\n   * A user can provide an explicit type for the this method to explicitly set the type structure on this particular channel.\r\n   * This is useful when working with multiple channels with different underlying data structure.\r\n   */\r\n  async get<T extends Record<string, ObjectsApi.Value>>(): Promise<ObjectsApi.PathObject<ObjectsApi.LiveMap<T>>> {\r\n    this._throwIfMissingChannelMode('object_subscribe');\r\n\r\n    // implicit attach before proceeding\r\n    await this._channel.ensureAttached();\r\n\r\n    // if we're not synced yet, wait for sync sequence to finish before returning root\r\n    if (this._state !== ObjectsState.synced) {\r\n      await this._eventEmitterInternal.once(ObjectsEvent.synced); // RTO1c\r\n    }\r\n\r\n    const pathObject = new DefaultPathObject(this, this._objectsPool.getRoot(), []);\r\n    return pathObject;\r\n  }\r\n\r\n  on(event: ObjectsEvent, callback: ObjectsEventCallback): StatusSubscription {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n    this._eventEmitterPublic.on(event, callback);\r\n\r\n    const off = () => {\r\n      this._eventEmitterPublic.off(event, callback);\r\n    };\r\n\r\n    return { off };\r\n  }\r\n\r\n  off(event: ObjectsEvent, callback: ObjectsEventCallback): void {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n\r\n    // prevent accidentally calling .off without any arguments on an EventEmitter and removing all callbacks\r\n    if (this._client.Utils.isNil(event) && this._client.Utils.isNil(callback)) {\r\n      return;\r\n    }\r\n\r\n    this._eventEmitterPublic.off(event, callback);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getPool(): ObjectsPool {\r\n    return this._objectsPool;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getChannel(): RealtimeChannel {\r\n    return this._channel;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getClient(): BaseClient {\r\n    return this._client;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getPathObjectSubscriptionRegister(): PathObjectSubscriptionRegister {\r\n    return this._pathObjectSubscriptionRegister;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * @spec RTO5\r\n   */\r\n  handleObjectSyncMessages(objectMessages: ObjectMessage[], syncChannelSerial: string | null | undefined): void {\r\n    const { syncId, syncCursor } = this._parseSyncChannelSerial(syncChannelSerial); // RTO5a\r\n    const newSyncSequence = this._currentSyncId !== syncId;\r\n    if (newSyncSequence) {\r\n      // RTO5a2 - new sync sequence started\r\n      this._startNewSync(syncId, syncCursor); // RTO5a2a\r\n    }\r\n\r\n    // RTO5a3 - continue current sync sequence\r\n    this._syncObjectsDataPool.applyObjectSyncMessages(objectMessages); // RTO5b\r\n\r\n    // RTO5a4 - if this is the last (or only) message in a sequence of sync updates, end the sync\r\n    if (!syncCursor) {\r\n      this._endSync();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  handleObjectMessages(objectMessages: ObjectMessage[]): void {\r\n    if (this._state !== ObjectsState.synced) {\r\n      // The client receives object messages in realtime over the channel concurrently with the sync sequence.\r\n      // Some of the incoming object messages may have already been applied to the objects described in\r\n      // the sync sequence, but others may not; therefore we must buffer these messages so that we can apply\r\n      // them to the objects once the sync is complete.\r\n      this._bufferedObjectOperations.push(...objectMessages);\r\n      return;\r\n    }\r\n\r\n    this._applyObjectMessages(objectMessages);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * @spec RTO4\r\n   */\r\n  onAttached(hasObjects?: boolean): void {\r\n    this._client.Logger.logAction(\r\n      this._client.logger,\r\n      this._client.Logger.LOG_MINOR,\r\n      'RealtimeObject.onAttached()',\r\n      `channel=${this._channel.name}, hasObjects=${hasObjects}`,\r\n    );\r\n\r\n    // RTO4a\r\n    this._startNewSync();\r\n\r\n    // RTO4b\r\n    if (!hasObjects) {\r\n      // if no HAS_OBJECTS flag received on attach, we can end sync sequence immediately and treat it as no objects on a channel.\r\n      // reset the objects pool to its initial state, and emit update events so subscribers to root object get notified about changes.\r\n      this._objectsPool.resetToInitialPool(true); // RTO4b1, RTO4b2\r\n      this._syncObjectsDataPool.clear(); // RTO4b3\r\n      this._endSync(); // RTO4b4\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  actOnChannelState(state: ChannelState, hasObjects?: boolean): void {\r\n    switch (state) {\r\n      case 'attached':\r\n        this.onAttached(hasObjects);\r\n        break;\r\n\r\n      case 'detached':\r\n      case 'failed':\r\n        // do not emit data update events as the actual current state of Objects data is unknown when we're in these channel states\r\n        this._objectsPool.clearObjectsData(false);\r\n        this._syncObjectsDataPool.clear();\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  async publish(objectMessages: ObjectMessage[]): Promise<void> {\r\n    this._channel.throwIfUnpublishableState();\r\n\r\n    const encodedMsgs = objectMessages.map((x) => x.encode(this._client));\r\n    const maxMessageSize = this._client.options.maxMessageSize;\r\n    const size = encodedMsgs.reduce((acc, msg) => acc + msg.getMessageSize(), 0);\r\n    if (size > maxMessageSize) {\r\n      throw new this._client.ErrorInfo(\r\n        `Maximum size of object messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n\r\n    return this._channel.sendState(encodedMsgs);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  throwIfInvalidAccessApiConfiguration(): void {\r\n    this._throwIfMissingChannelMode('object_subscribe');\r\n    this._throwIfInChannelState(['detached', 'failed']);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  throwIfInvalidWriteApiConfiguration(): void {\r\n    this._throwIfMissingChannelMode('object_publish');\r\n    this._throwIfInChannelState(['detached', 'failed', 'suspended']);\r\n    this._throwIfEchoMessagesDisabled();\r\n  }\r\n\r\n  private _startNewSync(syncId?: string, syncCursor?: string): void {\r\n    // need to discard all buffered object operation messages on new sync start\r\n    this._bufferedObjectOperations = [];\r\n    this._syncObjectsDataPool.clear();\r\n    this._currentSyncId = syncId;\r\n    this._currentSyncCursor = syncCursor;\r\n    this._stateChange(ObjectsState.syncing);\r\n  }\r\n\r\n  /** @spec RTO5c */\r\n  private _endSync(): void {\r\n    this._applySync();\r\n    // should apply buffered object operations after we applied the sync.\r\n    // can use regular object messages application logic\r\n    this._applyObjectMessages(this._bufferedObjectOperations);\r\n\r\n    this._bufferedObjectOperations = [];\r\n    this._syncObjectsDataPool.clear(); // RTO5c4\r\n    this._currentSyncId = undefined; // RTO5c3\r\n    this._currentSyncCursor = undefined; // RTO5c3\r\n    this._stateChange(ObjectsState.synced);\r\n  }\r\n\r\n  private _parseSyncChannelSerial(syncChannelSerial: string | null | undefined): {\r\n    syncId: string | undefined;\r\n    syncCursor: string | undefined;\r\n  } {\r\n    let match: RegExpMatchArray | null;\r\n    let syncId: string | undefined = undefined;\r\n    let syncCursor: string | undefined = undefined;\r\n    // RTO5a1 - syncChannelSerial is a two-part identifier: <sequence id>:<cursor value>\r\n    if (syncChannelSerial && (match = syncChannelSerial.match(/^([\\w-]+):(.*)$/))) {\r\n      syncId = match[1];\r\n      syncCursor = match[2];\r\n    }\r\n\r\n    return {\r\n      syncId,\r\n      syncCursor,\r\n    };\r\n  }\r\n\r\n  private _applySync(): void {\r\n    if (this._syncObjectsDataPool.isEmpty()) {\r\n      return;\r\n    }\r\n\r\n    const receivedObjectIds = new Set<string>();\r\n    const existingObjectUpdates: {\r\n      object: LiveObject;\r\n      update: LiveObjectUpdate | LiveObjectUpdateNoop;\r\n    }[] = [];\r\n\r\n    // RTO5c1\r\n    for (const [objectId, entry] of this._syncObjectsDataPool.entries()) {\r\n      receivedObjectIds.add(objectId);\r\n      const existingObject = this._objectsPool.get(objectId);\r\n\r\n      // RTO5c1a\r\n      if (existingObject) {\r\n        const update = existingObject.overrideWithObjectState(entry.objectMessage); // RTO5c1a1\r\n        // store updates to call subscription callbacks for all of them once the sync sequence is completed.\r\n        // this will ensure that clients get notified about the changes only once everything has been applied.\r\n        existingObjectUpdates.push({ object: existingObject, update });\r\n        continue;\r\n      }\r\n\r\n      // RTO5c1b,\r\n      let newObject: LiveObject;\r\n      // assign to a variable so TS doesn't complain about 'never' type in the default case\r\n      const objectType = entry.objectType;\r\n      switch (objectType) {\r\n        case 'LiveCounter':\r\n          newObject = LiveCounter.fromObjectState(this, entry.objectMessage); // RTO5c1b1a\r\n          break;\r\n\r\n        case 'LiveMap':\r\n          newObject = LiveMap.fromObjectState(this, entry.objectMessage); // RTO5c1b1b\r\n          break;\r\n\r\n        default:\r\n          throw new this._client.ErrorInfo(`Unknown LiveObject type: ${objectType}`, 50000, 500); // RTO5c1b1c\r\n      }\r\n\r\n      this._objectsPool.set(objectId, newObject); // RTO5c1b1\r\n    }\r\n\r\n    // RTO5c2 - need to remove LiveObject instances from the ObjectsPool for which objectIds were not received during the sync sequence\r\n    this._objectsPool.deleteExtraObjectIds([...receivedObjectIds]);\r\n\r\n    // Rebuild all parent references after sync to ensure all object-to-object references are properly established\r\n    // This is necessary because objects may reference other objects that weren't in the pool when they were initially created\r\n    this._rebuildAllParentReferences();\r\n\r\n    // call subscription callbacks for all updated existing objects.\r\n    existingObjectUpdates.forEach(({ object, update }) => object.notifyUpdated(update));\r\n  }\r\n\r\n  private _applyObjectMessages(objectMessages: ObjectMessage[]): void {\r\n    for (const objectMessage of objectMessages) {\r\n      if (!objectMessage.operation) {\r\n        this._client.Logger.logAction(\r\n          this._client.logger,\r\n          this._client.Logger.LOG_MAJOR,\r\n          'RealtimeObject._applyObjectMessages()',\r\n          `object operation message is received without 'operation' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\r\n        );\r\n        continue;\r\n      }\r\n\r\n      const objectOperation = objectMessage.operation;\r\n\r\n      switch (objectOperation.action) {\r\n        case ObjectOperationAction.MAP_CREATE:\r\n        case ObjectOperationAction.COUNTER_CREATE:\r\n        case ObjectOperationAction.MAP_SET:\r\n        case ObjectOperationAction.MAP_REMOVE:\r\n        case ObjectOperationAction.COUNTER_INC:\r\n        case ObjectOperationAction.OBJECT_DELETE:\r\n          // we can receive an op for an object id we don't have yet in the pool. instead of buffering such operations,\r\n          // we can create a zero-value object for the provided object id and apply the operation to that zero-value object.\r\n          // this also means that all objects are capable of applying the corresponding *_CREATE ops on themselves,\r\n          // since they need to be able to eventually initialize themselves from that *_CREATE op.\r\n          // so to simplify operations handling, we always try to create a zero-value object in the pool first,\r\n          // and then we can always apply the operation on the existing object in the pool.\r\n          this._objectsPool.createZeroValueObjectIfNotExists(objectOperation.objectId);\r\n          this._objectsPool.get(objectOperation.objectId)!.applyOperation(objectOperation, objectMessage);\r\n          break;\r\n\r\n        default:\r\n          this._client.Logger.logAction(\r\n            this._client.logger,\r\n            this._client.Logger.LOG_MAJOR,\r\n            'RealtimeObject._applyObjectMessages()',\r\n            `received unsupported action in object operation message: ${objectOperation.action}, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\r\n          );\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @spec RTO2 */\r\n  private _throwIfMissingChannelMode(expectedMode: 'object_subscribe' | 'object_publish'): void {\r\n    // RTO2a - channel.modes is only populated on channel attachment, so use it only if it is set\r\n    if (this._channel.modes != null && !this._channel.modes.includes(expectedMode)) {\r\n      throw new this._client.ErrorInfo(`\"${expectedMode}\" channel mode must be set for this operation`, 40024, 400); // RTO2a2\r\n    }\r\n    // RTO2b - otherwise as a best effort use user provided channel options\r\n    if (!this._client.Utils.allToLowerCase(this._channel.channelOptions.modes ?? []).includes(expectedMode)) {\r\n      throw new this._client.ErrorInfo(`\"${expectedMode}\" channel mode must be set for this operation`, 40024, 400); // RTO2b2\r\n    }\r\n  }\r\n\r\n  private _stateChange(state: ObjectsState): void {\r\n    if (this._state === state) {\r\n      return;\r\n    }\r\n\r\n    this._state = state;\r\n    const event = StateToEventsMap[state];\r\n    if (!event) {\r\n      return;\r\n    }\r\n\r\n    this._eventEmitterInternal.emit(event);\r\n    this._eventEmitterPublic.emit(event);\r\n  }\r\n\r\n  /**\r\n   * Rebuilds all parent references in the objects pool.\r\n   * This is necessary after sync operations where objects may reference other objects\r\n   * that weren't available when the initial parent references were established.\r\n   */\r\n  private _rebuildAllParentReferences(): void {\r\n    // First, clear all existing parent references\r\n    for (const object of this._objectsPool.getAll()) {\r\n      object.clearParentReferences();\r\n    }\r\n\r\n    // Then, rebuild parent references by examining all objects and their data\r\n    for (const object of this._objectsPool.getAll()) {\r\n      if (object instanceof LiveMap) {\r\n        // For LiveMaps, iterate through their entries and establish parent references\r\n        for (const [key, value] of object.entries()) {\r\n          if (value instanceof LiveObject) {\r\n            value.addParentReference(object, key);\r\n          }\r\n        }\r\n      }\r\n      // Note: LiveCounter doesn't reference other objects, so no special handling needed\r\n    }\r\n  }\r\n\r\n  private _throwIfInChannelState(channelState: ChannelState[]): void {\r\n    if (channelState.includes(this._channel.state)) {\r\n      throw this._client.ErrorInfo.fromValues(this._channel.invalidStateError());\r\n    }\r\n  }\r\n\r\n  private _throwIfEchoMessagesDisabled(): void {\r\n    if (this._channel.client.options.echoMessages === false) {\r\n      throw new this._channel.client.ErrorInfo(\r\n        `\"echoMessages\" client option must be enabled for this operation`,\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["liveobjects_exports", "__export", "LiveCounterValueType", "LiveMapValueType", "LiveObjects", "ObjectMessage", "RealtimeObject", "WireObjectMessage", "__toCommonJS", "ObjectId", "_ObjectId", "type", "hash", "msTimestamp", "platform", "objectType", "initialValue", "nonce", "valueForHashBuffer", "hashBuffer", "client", "objectId", "rest", "operationActions", "mapSemantics", "encode", "message", "utils", "messageEncoding", "encodeObjectDataFn", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "_j", "_k", "_l", "result", "WireObjectMessage", "copyMsg", "encodeMapEntries", "encodeObjectData", "mapEntries", "encodeFn", "acc", "v", "key", "entry", "encodedData", "__spreadProps", "__spreadValues", "data", "createInitialValueJSONString", "operation", "client", "wireMsg", "ObjectMessage", "encodedOperation", "strMsg", "msg", "className", "attr", "stringifyOperation", "operationActions", "mapSemantics", "_ObjectMessage", "_utils", "_messageEncoding", "values", "x", "encodedObjectData", "channel", "_WireObjectMessage", "format", "error", "__objRest", "size", "obj", "map", "counter", "mapOp", "decodedData", "objectData", "decodedBytes", "decodedJson", "LiveCounterValueType", "_LiveCounterValueType", "count", "initialCount", "value", "realtimeObject", "client", "initialValueOperation", "initialValueJSONString", "createInitialValueJSONString", "nonce", "msTimestamp", "objectId", "ObjectId", "ObjectMessage", "__spreadProps", "__spreadValues", "has", "find", "iter", "tar", "key", "dequal", "foo", "bar", "ctor", "len", "tmp", "ROOT_OBJECT_ID", "LiveObject", "_realtimeObject", "objectId", "listener", "update", "objectMessage", "previousDataRef", "parent", "key", "keys", "paths", "stack", "obj", "currentPath", "visited", "newVisited", "ROOT_OBJECT_ID", "opSerial", "opSiteCode", "siteSerial", "_a", "event", "operationObjectMessage", "pathEvents", "path", "updatedKeys", "basePath", "LiveCounter", "_LiveCounter", "LiveObject", "realtimeObject", "objectId", "objectMessage", "obj", "amount", "client", "ObjectMessage", "msg", "op", "_a", "opSerial", "opSiteCode", "update", "_b", "_c", "_d", "_e", "objectState", "previousDataRef", "prevDataRef", "newDataRef", "objectOperation", "LiveMap", "_LiveMap", "LiveObject", "realtimeObject", "_semantics", "objectId", "objectMessage", "obj", "key", "value", "_a", "_b", "client", "objectData", "createValueTypesMessages", "LiveCounterValueType", "counterCreateMsg", "LiveMapValueType", "mapCreateMsg", "nestedObjectsCreateMsgs", "mapSetMsg", "ObjectMessage", "element", "size", "entry", "_", "msgs", "msg", "op", "opSerial", "opSiteCode", "update", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "objectState", "previousDataRef", "keysToDelete", "x", "referencedObject", "visitedObjects", "visited", "result", "LiveCounter", "visitedObjectIds", "prevDataRef", "newDataRef", "currentEntry", "typedKey", "newEntry", "dequal", "objectOperation", "aggregatedUpdate", "ErrorInfo", "Utils", "existingEntry", "liveData", "oldReferencedObject", "newReferencedObject", "opTimestamp", "tombstonedAt", "mapEntrySerial", "entries", "liveMapData", "liveDataEntry", "data", "primitiveValue", "refObject", "changeType", "previousEntry", "LiveMapValueType", "_LiveMapValueType", "entries", "initialEntries", "value", "realtimeObject", "client", "key", "LiveMap", "initialValueOperation", "nestedObjectsCreateMsgs", "initialValueJSONString", "createInitialValueJSONString", "nonce", "msTimestamp", "objectId", "ObjectId", "ObjectMessage", "__spreadProps", "__spreadValues", "_a", "_b", "mapEntries", "objectData", "mapCreateMsg", "childNestedObjs", "LiveCounterValueType", "counterCreateMsg", "DEFAULTS", "ObjectsPool", "_realtimeObject", "_a", "_b", "DEFAULTS", "objectId", "ROOT_OBJECT_ID", "objectIds", "x", "liveObject", "emitUpdateEvents", "root", "object", "update", "existingObject", "parsedObjectId", "ObjectId", "zeroValueObject", "LiveMap", "LiveCounter", "pool", "toDelete", "obj", "DefaultBatchContext", "_realtimeObject", "_instance", "_rootContext", "key", "instance", "value", "ctx", "__yieldStar", "_", "LiveMap", "amount", "LiveCounter", "RootBatchContext", "DefaultBatchContext", "realtimeObject", "instance", "msgs", "x", "objectId", "wrappedInstance", "msgCtors", "DefaultInstance", "_DefaultInstance", "_realtimeObject", "_value", "LiveObject", "LiveMap", "value", "key", "LiveCounter", "instance", "__yieldStar", "_", "amount", "listener", "event", "_a", "unsubscribe", "fn", "ctx", "RootBatchContext", "DefaultPathObject", "_DefaultPathObject", "_realtimeObject", "_root", "path", "parent", "_a", "resolved", "LiveMap", "error", "value", "key", "pathAsArray", "currentSegment", "escaping", "char", "LiveObject", "LiveCounter", "_", "__yieldStar", "amount", "listener", "options", "unsubscribe", "fn", "instance", "ctx", "RootBatchContext", "current", "segment", "next", "DefaultInstance", "x", "PathObjectSubscriptionRegister", "_realtimeObject", "path", "listener", "options", "subscriptionId", "entry", "events", "event", "_a", "subscription", "subscriptionEvent", "DefaultPathObject", "error", "subPath", "eventPath", "depth", "subscriptionPath", "path1", "path2", "SyncObjectsDataPool", "_realtimeObject", "objectMessages", "objectMessage", "objectState", "StateToEventsMap", "RealtimeObject", "channel", "_a", "_b", "ObjectsPool", "SyncObjectsDataPool", "PathObjectSubscriptionRegister", "DEFAULTS", "details", "DefaultPathObject", "event", "callback", "objectMessages", "syncChannelSerial", "syncId", "syncCursor", "hasObjects", "state", "encodedMsgs", "x", "maxMessageSize", "size", "acc", "msg", "match", "receivedObjectIds", "existingObjectUpdates", "objectId", "entry", "existingObject", "update", "newObject", "objectType", "LiveCounter", "LiveMap", "object", "objectMessage", "objectOperation", "expectedMode", "key", "value", "LiveObject", "channelState", "LiveObjects", "LiveCounterValueType", "LiveMapValueType", "ObjectMessage", "RealtimeObject", "WireObjectMessage"]
}
