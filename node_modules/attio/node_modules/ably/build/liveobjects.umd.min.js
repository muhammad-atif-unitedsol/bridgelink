/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)

Ably JavaScript Library v2.16.0
https://github.com/ably/ably-js

Released under the Apache Licence v2.0*/(function (g, f) {
    if ("object" == typeof exports && "object" == typeof module) {
      module.exports = f();
    } else if ("function" == typeof define && define.amd) {
      define([], f);
    } else if ("object" == typeof exports) {
      exports["AblyLiveObjectsPlugin"] = f();
    } else {
      g["AblyLiveObjectsPlugin"] = f();
    }
  }(this, () => {
var exports = {};
var module = { exports };
"use strict";var V=Object.defineProperty,te=Object.defineProperties,ie=Object.getOwnPropertyDescriptor,ne=Object.getOwnPropertyDescriptors,ae=Object.getOwnPropertyNames,A=Object.getOwnPropertySymbols;var J=Object.prototype.hasOwnProperty,q=Object.prototype.propertyIsEnumerable;var z=(s,e)=>{if(e=Symbol[s])return e;throw Error("Symbol."+s+" is not defined")};var K=(s,e,t)=>e in s?V(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,j=(s,e)=>{for(var t in e||(e={}))J.call(e,t)&&K(s,t,e[t]);if(A)for(var t of A(e))q.call(e,t)&&K(s,t,e[t]);return s},_=(s,e)=>te(s,ne(e));var Z=(s,e)=>{var t={};for(var i in s)J.call(s,i)&&e.indexOf(i)<0&&(t[i]=s[i]);if(s!=null&&A)for(var i of A(s))e.indexOf(i)<0&&q.call(s,i)&&(t[i]=s[i]);return t};var se=(s,e)=>{for(var t in e)V(s,t,{get:e[t],enumerable:!0})},re=(s,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of ae(e))!J.call(s,n)&&n!==t&&V(s,n,{get:()=>e[n],enumerable:!(i=ie(e,n))||i.enumerable});return s};var oe=s=>re(V({},"__esModule",{value:!0}),s);var ce=function(s,e){this[0]=s,this[1]=e};var M=s=>{var e=s[z("asyncIterator")],t=!1,i,n={};return e==null?(e=s[z("iterator")](),i=a=>n[a]=r=>e[a](r)):(e=e.call(s),i=a=>n[a]=r=>{if(t){if(t=!1,a==="throw")throw r;return r}return t=!0,{done:!1,value:new ce(new Promise(o=>{var c=e[a](r);if(!(c instanceof Object))throw TypeError("Object expected");o(c)}),1)}}),n[z("iterator")]=()=>n,i("next"),"throw"in e?i("throw"):n.throw=a=>{throw a},"return"in e&&i("return"),n};var fe={};se(fe,{LiveCounter:()=>g,LiveMap:()=>I,LiveObjects:()=>he,ObjectMessage:()=>m,RealtimeObject:()=>P,WireObjectMessage:()=>C});module.exports=oe(fe);var y=class s{constructor(e,t,i){this.type=e;this.hash=t;this.msTimestamp=i}static fromInitialValue(e,t,i,n,a){let r=e.BufferUtils.concat([e.BufferUtils.utf8Encode(i),e.BufferUtils.utf8Encode(":"),e.BufferUtils.utf8Encode(n)]),o=e.BufferUtils.sha256(r),c=e.BufferUtils.base64UrlEncode(o);return new s(t,c,a)}static fromString(e,t){if(e.Utils.isNil(t))throw new e.ErrorInfo("Invalid object id string",92e3,500);let[i,n]=t.split(":");if(!i||!n)throw new e.ErrorInfo("Invalid object id string",92e3,500);if(!["map","counter"].includes(i))throw new e.ErrorInfo(`Invalid object type in object id: ${t}`,92e3,500);let[a,r]=n.split("@");if(!a||!r)throw new e.ErrorInfo("Invalid object id string",92e3,500);if(!Number.isInteger(Number.parseInt(r)))throw new e.ErrorInfo("Invalid object id string",92e3,500);return new s(i,a,Number.parseInt(r))}toString(){return`${this.type}:${this.hash}@${this.msTimestamp}`}};var le=["map.create","map.set","map.remove","counter.create","counter.inc","object.delete"],pe=["lww"];function Y(s,e,t,i){var a,r,o,c,l,b,d,u,O,v,U,S;let n=Object.assign(new C(e,t),Q(s));return(r=(a=s.object)==null?void 0:a.map)!=null&&r.entries&&(n.object.map.entries=F(s.object.map.entries,i)),(l=(c=(o=s.object)==null?void 0:o.createOp)==null?void 0:c.map)!=null&&l.entries&&(n.object.createOp.map.entries=F(s.object.createOp.map.entries,i)),(u=(d=(b=s.object)==null?void 0:b.createOp)==null?void 0:d.mapOp)!=null&&u.data&&(n.object.createOp.mapOp.data=G(s.object.createOp.mapOp.data,i)),(v=(O=s.operation)==null?void 0:O.map)!=null&&v.entries&&(n.operation.map.entries=F(s.operation.map.entries,i)),(S=(U=s.operation)==null?void 0:U.mapOp)!=null&&S.data&&(n.operation.mapOp.data=G(s.operation.mapOp.data,i)),n}function F(s,e){return Object.entries(s).reduce((t,i)=>{let[n,a]=i,r=a.data?G(a.data,e):void 0;return t[n]=_(j({},a),{data:r}),t},{})}function G(s,e){return e(s)}function x(s,e){let i=m.fromValues({operation:s},e.Utils,e.MessageEncoding).encode(e),{operation:n}=i.encodeForWire(e.Utils.Format.json);return JSON.stringify(n)}function H(s,e){let t="["+e;for(let i in s)s[i]===void 0||i==="_utils"||i==="_messageEncoding"||(i==="operation"||i==="object"||i==="extras"?t+=`; ${i}=${JSON.stringify(s[i])}`:t+=`; ${i}=${s[i]}`);return t+="]",t}function Q(s){let e={id:s.id,clientId:s.clientId,connectionId:s.connectionId,timestamp:s.timestamp,serial:s.serial,serialTimestamp:s.serialTimestamp,siteCode:s.siteCode};return s.operation&&(e.operation=JSON.parse(JSON.stringify(s.operation))),s.object&&(e.object=JSON.parse(JSON.stringify(s.object))),s.extras&&(e.extras=JSON.parse(JSON.stringify(s.extras))),e}function ue(s){return _(j({},s),{action:le[s.action]||"unknown",map:s.map?_(j({},s.map),{semantics:s.map.semantics!=null?pe[s.map.semantics]||"unknown":void 0}):void 0})}var m=class s{constructor(e,t){this._utils=e;this._messageEncoding=t}static fromValues(e,t,i){return Object.assign(new s(t,i),e)}static fromValuesArray(e,t,i){return e.map(n=>s.fromValues(n,t,i))}encode(e){let t=i=>{let n={objectId:i.objectId};return e.Platform.BufferUtils.isBuffer(i.value)?n.bytes=i.value:typeof i.value=="string"?n.string=i.value:typeof i.value=="boolean"?n.boolean=i.value:typeof i.value=="number"?n.number=i.value:typeof i.value=="object"&&i.value!==null&&(n.json=JSON.stringify(i.value)),n};return Y(this,this._utils,this._messageEncoding,t)}toString(){return H(this,"ObjectMessage")}isOperationMessage(){return this.operation!=null}isSyncMessage(){return this.object!=null}toUserFacingMessage(e){return{id:this.id,clientId:this.clientId,connectionId:this.connectionId,timestamp:this.timestamp,channel:e.name,operation:ue(this.operation),serial:this.serial,serialTimestamp:this.serialTimestamp,siteCode:this.siteCode,extras:this.extras}}},C=class s{constructor(e,t){this._utils=e;this._messageEncoding=t}static fromValues(e,t,i){return Object.assign(new s(t,i),e)}static fromValuesArray(e,t,i){return e.map(n=>s.fromValues(n,t,i))}encodeForWire(e){let t=i=>{if(i.bytes!=null){let n=this._messageEncoding.encodeDataForWire(i.bytes,null,e);return _(j({},i),{bytes:n.data})}return j({},i)};return Y(this,this._utils,this._messageEncoding,t)}decode(e,t){var n,a,r,o,c,l,b,d,u,O,v,U;let i=Object.assign(new m(this._utils,this._messageEncoding),Q(this));try{(a=(n=this.object)==null?void 0:n.map)!=null&&a.entries&&(i.object.map.entries=this._decodeMapEntries(this.object.map.entries,e,t)),(c=(o=(r=this.object)==null?void 0:r.createOp)==null?void 0:o.map)!=null&&c.entries&&(i.object.createOp.map.entries=this._decodeMapEntries(this.object.createOp.map.entries,e,t)),(d=(b=(l=this.object)==null?void 0:l.createOp)==null?void 0:b.mapOp)!=null&&d.data&&(i.object.createOp.mapOp.data=this._decodeObjectData(this.object.createOp.mapOp.data,e,t)),(O=(u=this.operation)==null?void 0:u.map)!=null&&O.entries&&(i.operation.map.entries=this._decodeMapEntries(this.operation.map.entries,e,t)),(U=(v=this.operation)==null?void 0:v.mapOp)!=null&&U.data&&(i.operation.mapOp.data=this._decodeObjectData(this.operation.mapOp.data,e,t))}catch(S){e.Logger.logAction(e.logger,e.Logger.LOG_ERROR,"WireObjectMessage.decode()",this._utils.inspectError(S))}return i}toJSON(){let e=arguments.length>0?this._utils.Format.json:this._utils.Format.msgpack,a=this.encodeForWire(e),{_utils:t,_messageEncoding:i}=a;return Z(a,["_utils","_messageEncoding"])}toString(){return H(this,"WireObjectMessage")}getMessageSize(){var t,i;let e=0;return e+=(i=(t=this.clientId)==null?void 0:t.length)!=null?i:0,this.operation&&(e+=this._getObjectOperationSize(this.operation)),this.object&&(e+=this._getObjectStateSize(this.object)),this.extras&&(e+=JSON.stringify(this.extras).length),e}_getObjectOperationSize(e){let t=0;return e.mapOp&&(t+=this._getMapOpSize(e.mapOp)),e.counterOp&&(t+=this._getCounterOpSize(e.counterOp)),e.map&&(t+=this._getObjectMapSize(e.map)),e.counter&&(t+=this._getObjectCounterSize(e.counter)),t}_getObjectStateSize(e){let t=0;return e.map&&(t+=this._getObjectMapSize(e.map)),e.counter&&(t+=this._getObjectCounterSize(e.counter)),e.createOp&&(t+=this._getObjectOperationSize(e.createOp)),t}_getObjectMapSize(e){var i;let t=0;return Object.entries((i=e.entries)!=null?i:{}).forEach(([n,a])=>{var r;t+=(r=n==null?void 0:n.length)!=null?r:0,a&&(t+=this._getMapEntrySize(a))}),t}_getObjectCounterSize(e){return e.count==null?0:8}_getMapEntrySize(e){let t=0;return e.data&&(t+=this._getObjectDataSize(e.data)),t}_getMapOpSize(e){var i,n;let t=0;return t+=(n=(i=e.key)==null?void 0:i.length)!=null?n:0,e.data&&(t+=this._getObjectDataSize(e.data)),t}_getCounterOpSize(e){return e.amount==null?0:8}_getObjectDataSize(e){let t=0;return e.boolean!=null&&(t+=this._utils.dataSizeBytes(e.boolean)),e.bytes!=null&&(t+=this._utils.dataSizeBytes(e.bytes)),e.number!=null&&(t+=this._utils.dataSizeBytes(e.number)),e.string!=null&&(t+=this._utils.dataSizeBytes(e.string)),e.json!=null&&(t+=this._utils.dataSizeBytes(e.json)),t}_decodeMapEntries(e,t,i){return Object.entries(e).reduce((n,a)=>{let[r,o]=a,c=o.data?this._decodeObjectData(o.data,t,i):void 0;return n[r]=_(j({},o),{data:c}),n},{})}_decodeObjectData(e,t,i){var n,a,r;try{if(e.objectId!=null)return{objectId:e.objectId};let o;e.bytes!=null&&(o=i==="msgpack"?e.bytes:t.Platform.BufferUtils.base64Decode(String(e.bytes)));let c;return e.json!=null&&(c=JSON.parse(e.json)),{value:(r=(a=(n=o!=null?o:c)!=null?n:e.boolean)!=null?a:e.number)!=null?r:e.string}}catch(o){return t.Logger.logAction(t.logger,t.Logger.LOG_ERROR,"WireObjectMessage._decodeObjectData()",this._utils.inspectError(o)),j({},e)}}};var g=class s{constructor(e){this._livetype="LiveCounter";this._count=e,Object.freeze(this)}static create(e=0){return new s(e)}static instanceof(e){return typeof e=="object"&&e!==null&&e._livetype==="LiveCounter"}static async createCounterCreateMessage(e,t){let i=e.getClient(),n=t._count;if(n!==void 0&&(typeof n!="number"||!Number.isFinite(n)))throw new i.ErrorInfo("Counter value should be a valid number",40003,400);let a=s.createInitialValueOperation(n),r=x(a,i),o=i.Utils.cheapRandStr(),c=await i.getTimestamp(!0),l=y.fromInitialValue(i.Platform,"counter",r,o,c).toString();return m.fromValues({operation:_(j({},a),{action:3,objectId:l,nonce:o,initialValue:r})},i.Utils,i.MessageEncoding)}static createInitialValueOperation(e){return{counter:{count:e!=null?e:0}}}};var X=Object.prototype.hasOwnProperty;function ee(s,e,t){for(t of s.keys())if(E(t,e))return t}function E(s,e){var t,i,n;if(s===e)return!0;if(s&&e&&(t=s.constructor)===e.constructor){if(t===Date)return s.getTime()===e.getTime();if(t===RegExp)return s.toString()===e.toString();if(t===Array){if((i=s.length)===e.length)for(;i--&&E(s[i],e[i]););return i===-1}if(t===Set){if(s.size!==e.size)return!1;for(i of s)if(n=i,n&&typeof n=="object"&&(n=ee(e,n),!n)||!e.has(n))return!1;return!0}if(t===Map){if(s.size!==e.size)return!1;for(i of s)if(n=i[0],n&&typeof n=="object"&&(n=ee(e,n),!n)||!E(i[1],e.get(n)))return!1;return!0}if(t===ArrayBuffer)s=new Uint8Array(s),e=new Uint8Array(e);else if(t===DataView){if((i=s.byteLength)===e.byteLength)for(;i--&&s.getInt8(i)===e.getInt8(i););return i===-1}if(ArrayBuffer.isView(s)){if((i=s.byteLength)===e.byteLength)for(;i--&&s[i]===e[i];);return i===-1}if(!t||typeof s=="object"){i=0;for(t in s)if(X.call(s,t)&&++i&&!X.call(e,t)||!(t in e)||!E(s[t],e[t]))return!1;return Object.keys(e).length===i}}return s!==s&&e!==e}var R="root";var f=class{constructor(e,t){this._realtimeObject=e;this._client=this._realtimeObject.getClient(),this._subscriptions=new this._client.EventEmitter(this._client.logger),this._objectId=t,this._dataRef=this._getZeroValueData(),this._siteTimeserials={},this._createOperationIsMerged=!1,this._tombstone=!1,this._parentReferences=new Map}subscribe(e){return this._subscriptions.on("updated",e),{unsubscribe:()=>{this._subscriptions.off("updated",e)}}}getObjectId(){return this._objectId}notifyUpdated(e){this._isNoopUpdate(e)||(this._notifyInstanceSubscriptions(e),this._notifyPathSubscriptions(e),e.tombstone&&this._subscriptions.off())}tombstone(e){this._tombstone=!0,e.serialTimestamp!=null?this._tombstonedAt=e.serialTimestamp:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveObject.tombstone()",`object has been tombstoned but no "serialTimestamp" found in the message, using local clock instead; objectId=${this.getObjectId()}`),this._tombstonedAt=Date.now());let t=this.clearData();return t.objectMessage=e,t.tombstone=!0,t}isTombstoned(){return this._tombstone}tombstonedAt(){return this._tombstonedAt}clearData(){let e=this._dataRef;return this._dataRef=this._getZeroValueData(),this._updateFromDataDiff(e,this._dataRef)}addParentReference(e,t){let i=this._parentReferences.get(e);i?i.add(t):this._parentReferences.set(e,new Set([t]))}removeParentReference(e,t){let i=this._parentReferences.get(e);i&&(i.delete(t),i.size===0&&this._parentReferences.delete(e))}removeParentReferenceAll(e){this._parentReferences.delete(e)}clearParentReferences(){this._parentReferences.clear()}getFullPaths(){let e=[],t=[{obj:this,currentPath:[],visited:new Set}];for(;t.length>0;){let{obj:i,currentPath:n,visited:a}=t.pop();if(a.has(i))continue;let r=new Set(a);if(r.add(i),i.getObjectId()===R){e.push(n);continue}for(let[o,c]of i._parentReferences)for(let l of c)t.push({obj:o,currentPath:[l,...n],visited:r})}return e}_canApplyOperation(e,t){if(!e)throw new this._client.ErrorInfo(`Invalid serial: ${e}`,92e3,500);if(!t)throw new this._client.ErrorInfo(`Invalid site code: ${t}`,92e3,500);let i=this._siteTimeserials[t];return!i||e>i}_applyObjectDelete(e){return this.tombstone(e)}_notifyInstanceSubscriptions(e){var i;let t={message:(i=e.objectMessage)!=null&&i.isOperationMessage()?e.objectMessage:void 0};this._subscriptions.emit("updated",t)}_notifyPathSubscriptions(e){var a;let t=this.getFullPaths();if(t.length===0)return;let i=(a=e.objectMessage)!=null&&a.isOperationMessage()?e.objectMessage:void 0,n=t.map(r=>({path:r,message:i,bubbles:!0}));if(e._type==="LiveMapUpdate"){let r=Object.keys(e.update);for(let o of r)for(let c of t)n.push({path:[...c,o],message:i,bubbles:!1})}this._realtimeObject.getPathObjectSubscriptionRegister().notifyPathEvents(n)}_isNoopUpdate(e){return e.noop===!0}};var h=class s extends f{static zeroValue(e,t){return new s(e,t)}static fromObjectState(e,t){let i=new s(e,t.object.objectId);return i.overrideWithObjectState(t),i}static createCounterIncMessage(e,t,i){let n=e.getClient();if(typeof i!="number"||!Number.isFinite(i))throw new n.ErrorInfo("Counter value increment should be a valid number",40003,400);return m.fromValues({operation:{action:4,objectId:t,counterOp:{amount:i}}},n.Utils,n.MessageEncoding)}value(){return this._dataRef.data}async increment(e){let t=s.createCounterIncMessage(this._realtimeObject,this.getObjectId(),e);return this._realtimeObject.publish([t])}async decrement(e){if(typeof e!="number"||!Number.isFinite(e))throw new this._client.ErrorInfo("Counter value decrement should be a valid number",40003,400);return this.increment(-e)}applyOperation(e,t){var r;if(e.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Cannot apply object operation with objectId=${e.objectId}, to this LiveCounter with objectId=${this.getObjectId()}`,92e3,500);let i=t.serial,n=t.siteCode;if(!this._canApplyOperation(i,n)){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveCounter.applyOperation()",`skipping ${e.action} op: op serial ${i.toString()} <= site serial ${(r=this._siteTimeserials[n])==null?void 0:r.toString()}; objectId=${this.getObjectId()}`);return}if(this._siteTimeserials[n]=i,this.isTombstoned())return;let a;switch(e.action){case 3:a=this._applyCounterCreate(e,t);break;case 4:if(this._client.Utils.isNil(e.counterOp)){this._throwNoPayloadError(e);return}else a=this._applyCounterInc(e.counterOp,t);break;case 5:a=this._applyObjectDelete(t);break;default:throw new this._client.ErrorInfo(`Invalid ${e.action} op for LiveCounter objectId=${this.getObjectId()}`,92e3,500)}this.notifyUpdated(a)}overrideWithObjectState(e){var a,r,o,c,l;let t=e.object;if(t==null)throw new this._client.ErrorInfo(`Missing object state; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(t.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state objectId=${t.objectId}; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(!this._client.Utils.isNil(t.createOp)){if(t.createOp.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state createOp objectId=${(a=t.createOp)==null?void 0:a.objectId}; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(t.createOp.action!==3)throw new this._client.ErrorInfo(`Invalid object state: object state createOp action=${(r=t.createOp)==null?void 0:r.action}; LiveCounter objectId=${this.getObjectId()}`,92e3,500)}if(this._siteTimeserials=(o=t.siteTimeserials)!=null?o:{},this.isTombstoned())return{noop:!0};let i=this._dataRef,n;return t.tombstone?n=this.tombstone(e):(this._createOperationIsMerged=!1,this._dataRef={data:(l=(c=t.counter)==null?void 0:c.count)!=null?l:0},this._client.Utils.isNil(t.createOp)||this._mergeInitialDataFromCreateOperation(t.createOp,e),n=this._updateFromDataDiff(i,this._dataRef),n.objectMessage=e),n}onGCInterval(){}_getZeroValueData(){return{data:0}}_updateFromDataDiff(e,t){return{update:{amount:t.data-e.data},_type:"LiveCounterUpdate"}}_mergeInitialDataFromCreateOperation(e,t){var i,n,a,r;return this._dataRef.data+=(n=(i=e.counter)==null?void 0:i.count)!=null?n:0,this._createOperationIsMerged=!0,{update:{amount:(r=(a=e.counter)==null?void 0:a.count)!=null?r:0},objectMessage:t,_type:"LiveCounterUpdate"}}_throwNoPayloadError(e){throw new this._client.ErrorInfo(`No payload found for ${e.action} op for LiveCounter objectId=${this.getObjectId()}`,92e3,500)}_applyCounterCreate(e,t){return this._createOperationIsMerged?(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveCounter._applyCounterCreate()",`skipping applying COUNTER_CREATE op on a counter instance as it was already applied before; objectId=${this.getObjectId()}`),{noop:!0}):this._mergeInitialDataFromCreateOperation(e,t)}_applyCounterInc(e,t){return this._dataRef.data+=e.amount,{update:{amount:e.amount},objectMessage:t,_type:"LiveCounterUpdate"}}};var p=class s extends f{constructor(t,i,n){super(t,n);this._semantics=i}static zeroValue(t,i){return new s(t,0,i)}static fromObjectState(t,i){let n=new s(t,i.object.map.semantics,i.object.objectId);return n.overrideWithObjectState(i),n}static async createMapSetMessage(t,i,n,a){var b,d;let r=t.getClient();s.validateKeyValue(t,n,a);let o,c=[];if(g.instanceof(a)){let u=await g.createCounterCreateMessage(t,a);c=[u],o={objectId:(b=u.operation)==null?void 0:b.objectId}}else if(I.instanceof(a)){let{mapCreateMsg:u,nestedObjectsCreateMsgs:O}=await I.createMapCreateMessage(t,a);c=[...O,u],o={objectId:(d=u.operation)==null?void 0:d.objectId}}else o={value:a};let l=m.fromValues({operation:{action:1,objectId:i,mapOp:{key:n,data:o}}},r.Utils,r.MessageEncoding);return[...c,l]}static createMapRemoveMessage(t,i,n){let a=t.getClient();if(typeof n!="string")throw new a.ErrorInfo("Map key should be string",40003,400);return m.fromValues({operation:{action:2,objectId:i,mapOp:{key:n}}},a.Utils,a.MessageEncoding)}static validateKeyValue(t,i,n){let a=t.getClient();if(typeof i!="string")throw new a.ErrorInfo("Map key should be string",40003,400);if(n===null||typeof n!="string"&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="object")throw new a.ErrorInfo("Map value data type is unsupported",40013,400)}get(t){if(this.isTombstoned())return;let i=this._dataRef.data.get(t);if(i!==void 0&&i.tombstone!==!0)return this._getResolvedValueFromObjectData(i.data)}size(){let t=0;for(let i of this._dataRef.data.values())this._isMapEntryTombstoned(i)||t++;return t}*entries(){for(let[t,i]of this._dataRef.data.entries()){if(this._isMapEntryTombstoned(i))continue;let n=this._getResolvedValueFromObjectData(i.data);yield[t,n]}}*keys(){for(let[t]of this.entries())yield t}*values(){for(let[t,i]of this.entries())yield i}async set(t,i){let n=await s.createMapSetMessage(this._realtimeObject,this.getObjectId(),t,i);return this._realtimeObject.publish(n)}async remove(t){let i=s.createMapRemoveMessage(this._realtimeObject,this.getObjectId(),t);return this._realtimeObject.publish([i])}applyOperation(t,i){var o;if(t.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Cannot apply object operation with objectId=${t.objectId}, to this LiveMap with objectId=${this.getObjectId()}`,92e3,500);let n=i.serial,a=i.siteCode;if(!this._canApplyOperation(n,a)){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap.applyOperation()",`skipping ${t.action} op: op serial ${n.toString()} <= site serial ${(o=this._siteTimeserials[a])==null?void 0:o.toString()}; objectId=${this.getObjectId()}`);return}if(this._siteTimeserials[a]=n,this.isTombstoned())return;let r;switch(t.action){case 0:r=this._applyMapCreate(t,i);break;case 1:if(this._client.Utils.isNil(t.mapOp)){this._throwNoPayloadError(t);return}else r=this._applyMapSet(t.mapOp,n,i);break;case 2:if(this._client.Utils.isNil(t.mapOp)){this._throwNoPayloadError(t);return}else r=this._applyMapRemove(t.mapOp,n,i.serialTimestamp,i);break;case 5:r=this._applyObjectDelete(i);break;default:throw new this._client.ErrorInfo(`Invalid ${t.action} op for LiveMap objectId=${this.getObjectId()}`,92e3,500)}this.notifyUpdated(r)}overrideWithObjectState(t){var r,o,c,l,b,d,u,O,v;let i=t.object;if(i==null)throw new this._client.ErrorInfo(`Missing object state; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(i.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state objectId=${i.objectId}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(((r=i.map)==null?void 0:r.semantics)!==this._semantics)throw new this._client.ErrorInfo(`Invalid object state: object state map semantics=${(o=i.map)==null?void 0:o.semantics}; LiveMap semantics=${this._semantics}`,92e3,500);if(!this._client.Utils.isNil(i.createOp)){if(i.createOp.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state createOp objectId=${(c=i.createOp)==null?void 0:c.objectId}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(i.createOp.action!==0)throw new this._client.ErrorInfo(`Invalid object state: object state createOp action=${(l=i.createOp)==null?void 0:l.action}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(((b=i.createOp.map)==null?void 0:b.semantics)!==this._semantics)throw new this._client.ErrorInfo(`Invalid object state: object state createOp map semantics=${(d=i.createOp.map)==null?void 0:d.semantics}; LiveMap semantics=${this._semantics}`,92e3,500)}if(this._siteTimeserials=(u=i.siteTimeserials)!=null?u:{},this.isTombstoned())return{noop:!0};let n=this._dataRef,a;return i.tombstone?a=this.tombstone(t):(this._createOperationIsMerged=!1,this._dataRef=this._liveMapDataFromMapEntries((v=(O=i.map)==null?void 0:O.entries)!=null?v:{}),this._client.Utils.isNil(i.createOp)||this._mergeInitialDataFromCreateOperation(i.createOp,t),a=this._updateFromDataDiff(n,this._dataRef),a.objectMessage=t),this._updateParentReferencesFromUpdate(a,n),a}onGCInterval(){let t=[];for(let[i,n]of this._dataRef.data.entries())n.tombstone===!0&&Date.now()-n.tombstonedAt>=this._realtimeObject.gcGracePeriod&&t.push(i);t.forEach(i=>this._dataRef.data.delete(i))}clearData(){for(let[t,i]of this._dataRef.data.entries())if(i.data&&"objectId"in i.data){let n=this._realtimeObject.getPool().get(i.data.objectId);n&&n.removeParentReference(this,t)}return super.clearData()}compact(t){let i=t!=null?t:new Map,n={};i.set(this.getObjectId(),n);for(let[a,r]of this.entries()){if(r instanceof s){i.has(r.getObjectId())?n[a]=i.get(r.getObjectId()):n[a]=r.compact(i);continue}if(r instanceof h){n[a]=r.value();continue}n[a]=r}return n}compactJson(t){let i=t!=null?t:new Set,n={};i.add(this.getObjectId());for(let[a,r]of this.entries()){if(r instanceof s){i.has(r.getObjectId())?n[a]={objectId:r.getObjectId()}:n[a]=r.compactJson(i);continue}if(r instanceof h){n[a]=r.value();continue}if(this._client.Platform.BufferUtils.isBuffer(r)){n[a]=this._client.Platform.BufferUtils.base64Encode(r);continue}n[a]=r}return n}_getZeroValueData(){return{data:new Map}}_updateFromDataDiff(t,i){let n={update:{},_type:"LiveMapUpdate"};for(let[a,r]of t.data.entries()){let o=a;r.tombstone===!1&&!i.data.has(o)&&(n.update[o]="removed")}for(let[a,r]of i.data.entries()){let o=a;if(!t.data.has(o)){if(r.tombstone===!1){n.update[o]="updated";continue}if(r.tombstone===!0)continue}let c=t.data.get(o);if(c.tombstone===!0&&r.tombstone===!1){n.update[o]="updated";continue}if(c.tombstone===!1&&r.tombstone===!0){n.update[o]="removed";continue}if(c.tombstone===!0&&r.tombstone===!0)continue;if(!E(c.data,r.data)){n.update[o]="updated";continue}}return n}_mergeInitialDataFromCreateOperation(t,i){var a;if(this._client.Utils.isNil(t.map))return{update:{},objectMessage:i,_type:"LiveMapUpdate"};let n={update:{},objectMessage:i,_type:"LiveMapUpdate"};return Object.entries((a=t.map.entries)!=null?a:{}).forEach(([r,o])=>{let c=o.timeserial,l;o.tombstone===!0?l=this._applyMapRemove({key:r},c,o.serialTimestamp,i):l=this._applyMapSet({key:r,data:o.data},c,i),!l.noop&&Object.assign(n.update,l.update)}),this._createOperationIsMerged=!0,n}_throwNoPayloadError(t){throw new this._client.ErrorInfo(`No payload found for ${t.action} op for LiveMap objectId=${this.getObjectId()}`,92e3,500)}_applyMapCreate(t,i){var n,a;if(this._createOperationIsMerged)return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapCreate()",`skipping applying MAP_CREATE op on a map instance as it was already applied before; objectId=${this.getObjectId()}`),{noop:!0};if(this._semantics!==((n=t.map)==null?void 0:n.semantics))throw new this._client.ErrorInfo(`Cannot apply MAP_CREATE op on LiveMap objectId=${this.getObjectId()}; map's semantics=${this._semantics}, but op expected ${(a=t.map)==null?void 0:a.semantics}`,92e3,500);return this._mergeInitialDataFromCreateOperation(t,i)}_applyMapSet(t,i,n){var d;let{ErrorInfo:a,Utils:r}=this._client,o=this._dataRef.data.get(t.key);if(o&&!this._canApplyMapOperation(o.timeserial,i))return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapSet()",`skipping update for key="${t.key}": op serial ${i==null?void 0:i.toString()} <= entry serial ${(d=o.timeserial)==null?void 0:d.toString()}; objectId=${this.getObjectId()}`),{noop:!0};if(r.isNil(t.data)||r.isNil(t.data.objectId)&&r.isNil(t.data.value))throw new a(`Invalid object data for MAP_SET op on objectId=${this.getObjectId()} on key="${t.key}"`,92e3,500);let c;if(r.isNil(t.data.objectId)?c={value:t.data.value}:(c={objectId:t.data.objectId},this._realtimeObject.getPool().createZeroValueObjectIfNotExists(t.data.objectId)),o){if(o.data&&"objectId"in o.data){let u=this._realtimeObject.getPool().get(o.data.objectId);u&&u.removeParentReference(this,t.key)}o.tombstone=!1,o.tombstonedAt=void 0,o.timeserial=i,o.data=c}else{let u={tombstone:!1,tombstonedAt:void 0,timeserial:i,data:c};this._dataRef.data.set(t.key,u)}if("objectId"in c){let u=this._realtimeObject.getPool().get(c.objectId);u&&u.addParentReference(this,t.key)}let l={update:{},objectMessage:n,_type:"LiveMapUpdate"},b=t.key;return l.update[b]="updated",l}_applyMapRemove(t,i,n,a){var b;let r=this._dataRef.data.get(t.key);if(r&&!this._canApplyMapOperation(r.timeserial,i))return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapRemove()",`skipping remove for key="${t.key}": op serial ${i==null?void 0:i.toString()} <= entry serial ${(b=r.timeserial)==null?void 0:b.toString()}; objectId=${this.getObjectId()}`),{noop:!0};let o;if(n!=null?o=n:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveMap._applyMapRemove()",`map key has been removed but no "serialTimestamp" found in the message, using local clock instead; key="${t.key}", objectId=${this.getObjectId()}`),o=Date.now()),r){if(r.data&&"objectId"in r.data){let d=this._realtimeObject.getPool().get(r.data.objectId);d&&d.removeParentReference(this,t.key)}r.tombstone=!0,r.tombstonedAt=o,r.timeserial=i,r.data=void 0}else{let d={tombstone:!0,tombstonedAt:o,timeserial:i,data:void 0};this._dataRef.data.set(t.key,d)}let c={update:{},objectMessage:a,_type:"LiveMapUpdate"},l=t.key;return c.update[l]="removed",c}_canApplyMapOperation(t,i){return!t&&!i?!1:t?i?i>t:!1:!0}_liveMapDataFromMapEntries(t){let i={data:new Map};return Object.entries(t!=null?t:{}).forEach(([n,a])=>{let r;this._client.Utils.isNil(a.data)||(this._client.Utils.isNil(a.data.objectId)?r={value:a.data.value}:r={objectId:a.data.objectId});let o;a.tombstone===!0&&(a.serialTimestamp!=null?o=a.serialTimestamp:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveMap._liveMapDataFromMapEntries()",`map key is removed but no "serialTimestamp" found, using local clock instead; key="${n}", objectId=${this.getObjectId()}`),o=Date.now()));let c={timeserial:a.timeserial,data:r,tombstone:a.tombstone===!0,tombstonedAt:o};i.data.set(n,c)}),i}_getResolvedValueFromObjectData(t){let i=t.value;if(i!=null)return i;let n=t.objectId,a=this._realtimeObject.getPool().get(n);if(a&&!a.isTombstoned())return a}_isMapEntryTombstoned(t){if(t.tombstone===!0)return!0;let i=t.data;if("objectId"in i){let n=this._realtimeObject.getPool().get(i.objectId);if(n!=null&&n.isTombstoned())return!0}return!1}_updateParentReferencesFromUpdate(t,i){for(let[n,a]of Object.entries(t.update)){if(a==="removed"){let r=i.data.get(n);if(r!=null&&r.data&&"objectId"in r.data){let o=this._realtimeObject.getPool().get(r.data.objectId);o&&o.removeParentReference(this,n)}}if(a==="updated"){let r=i.data.get(n),o=this._dataRef.data.get(n);if(r!=null&&r.data&&"objectId"in r.data){let c=this._realtimeObject.getPool().get(r.data.objectId);c&&c.removeParentReference(this,n)}if(o!=null&&o.data&&"objectId"in o.data){let c=this._realtimeObject.getPool().get(o.data.objectId);c&&c.addParentReference(this,n)}}}}};var I=class s{constructor(e){this._livetype="LiveMap";this._entries=e,Object.freeze(this)}static create(e){return new s(e)}static instanceof(e){return typeof e=="object"&&e!==null&&e._livetype==="LiveMap"}static async createMapCreateMessage(e,t){let i=e.getClient(),n=t._entries;if(n!==void 0&&(n===null||typeof n!="object"))throw new i.ErrorInfo("Map entries should be a key-value object",40003,400);Object.entries(n!=null?n:{}).forEach(([u,O])=>p.validateKeyValue(e,u,O));let{initialValueOperation:a,nestedObjectsCreateMsgs:r}=await s._createInitialValueOperation(e,n),o=x(a,i),c=i.Utils.cheapRandStr(),l=await i.getTimestamp(!0),b=y.fromInitialValue(i.Platform,"map",o,c,l).toString();return{mapCreateMsg:m.fromValues({operation:_(j({},a),{action:0,objectId:b,nonce:c,initialValue:o})},i.Utils,i.MessageEncoding),nestedObjectsCreateMsgs:r}}static async _createInitialValueOperation(e,t){var r,o;let i={},n=[];for(let[c,l]of Object.entries(t!=null?t:{})){let b;if(s.instanceof(l)){let{mapCreateMsg:d,nestedObjectsCreateMsgs:u}=await s.createMapCreateMessage(e,l);n.push(...u,d),b={objectId:(r=d.operation)==null?void 0:r.objectId}}else if(g.instanceof(l)){let d=await g.createCounterCreateMessage(e,l);n.push(d),b={objectId:(o=d.operation)==null?void 0:o.objectId}}else b={value:l};i[c]={data:b}}return{initialValueOperation:{map:{semantics:0,entries:i}},nestedObjectsCreateMsgs:n}}};var L={gcInterval:3e5,gcGracePeriod:864e5};var N=class{constructor(e){this._realtimeObject=e;var t,i;this._client=this._realtimeObject.getClient(),this._pool=this._createInitialPool(),this._gcInterval=setInterval(()=>{this._onGCInterval()},L.gcInterval),(i=(t=this._gcInterval).unref)==null||i.call(t)}get(e){return this._pool.get(e)}getRoot(){return this._pool.get(R)}getAll(){return this._pool.values()}deleteExtraObjectIds(e){[...this._pool.keys()].filter(n=>!e.includes(n)).forEach(n=>this._pool.delete(n))}set(e,t){this._pool.set(e,t)}resetToInitialPool(e){let t=this.getRoot();this._pool.clear(),this._pool.set(t.getObjectId(),t),this.clearObjectsData(e)}clearObjectsData(e){for(let t of this._pool.values()){let i=t.clearData();e&&t.notifyUpdated(i)}}createZeroValueObjectIfNotExists(e){let t=this.get(e);if(t)return t;let i=y.fromString(this._client,e),n;switch(i.type){case"map":{n=p.zeroValue(this._realtimeObject,e);break}case"counter":n=h.zeroValue(this._realtimeObject,e);break}return this.set(e,n),n}_createInitialPool(){let e=new Map,t=p.zeroValue(this._realtimeObject,R);return e.set(t.getObjectId(),t),e}_onGCInterval(){let e=[];for(let[t,i]of this._pool.entries()){if(i.isTombstoned()&&Date.now()-i.tombstonedAt()>=this._realtimeObject.gcGracePeriod){e.push(t);continue}i.onGCInterval()}e.forEach(t=>this._pool.delete(t))}};var w=class{constructor(e,t,i){this._realtimeObject=e;this._instance=t;this._rootContext=i;this._client=this._realtimeObject.getClient()}get id(){return this._throwIfClosed(),this._instance.id}get(e){this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._throwIfClosed();let t=this._instance.get(e);if(t)return this._rootContext.wrapInstance(t)}value(){return this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._throwIfClosed(),this._instance.value()}compact(){return this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._throwIfClosed(),this._instance.compact()}compactJson(){return this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._throwIfClosed(),this._instance.compactJson()}*entries(){this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._throwIfClosed();for(let[e,t]of this._instance.entries()){let i=this._rootContext.wrapInstance(t);yield[e,i]}}*keys(){this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._throwIfClosed(),yield*M(this._instance.keys())}*values(){this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._throwIfClosed();for(let[e,t]of this.entries())yield t}size(){return this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._throwIfClosed(),this._instance.size()}set(e,t){if(this._realtimeObject.throwIfInvalidWriteApiConfiguration(),this._throwIfClosed(),!this._instance.isLiveMap())throw new this._client.ErrorInfo("Cannot set a key on a non-LiveMap instance",92007,400);this._rootContext.queueMessages(async()=>p.createMapSetMessage(this._realtimeObject,this._instance.id,e,t))}remove(e){if(this._realtimeObject.throwIfInvalidWriteApiConfiguration(),this._throwIfClosed(),!this._instance.isLiveMap())throw new this._client.ErrorInfo("Cannot remove a key from a non-LiveMap instance",92007,400);this._rootContext.queueMessages(async()=>[p.createMapRemoveMessage(this._realtimeObject,this._instance.id,e)])}increment(e){if(this._realtimeObject.throwIfInvalidWriteApiConfiguration(),this._throwIfClosed(),!this._instance.isLiveCounter())throw new this._client.ErrorInfo("Cannot increment a non-LiveCounter instance",92007,400);this._rootContext.queueMessages(async()=>[h.createCounterIncMessage(this._realtimeObject,this._instance.id,e!=null?e:1)])}decrement(e){if(this._realtimeObject.throwIfInvalidWriteApiConfiguration(),this._throwIfClosed(),!this._instance.isLiveCounter())throw new this._client.ErrorInfo("Cannot decrement a non-LiveCounter instance",92007,400);this.increment(-(e!=null?e:1))}_throwIfClosed(){if(this._rootContext.isClosed())throw new this._client.ErrorInfo("Batch is closed",4e4,400)}};var T=class extends w{constructor(t,i){super(t,i,null);this._wrappedInstances=new Map;this._queuedMessageConstructors=[];this._isClosed=!1;this._rootContext=this}async flush(){try{this.close();let t=(await Promise.all(this._queuedMessageConstructors.map(i=>i()))).flat();t.length>0&&await this._realtimeObject.publish(t)}finally{this._wrappedInstances.clear(),this._queuedMessageConstructors=[]}}close(){this._isClosed=!0}isClosed(){return this._isClosed}wrapInstance(t){let i=t.id;if(i){if(this._wrappedInstances.has(i))return this._wrappedInstances.get(i);let n=new w(this._realtimeObject,t,this);return this._wrappedInstances.set(i,n),n}return new w(this._realtimeObject,t,this)}queueMessages(t){this._queuedMessageConstructors.push(t)}};var $=class s{constructor(e,t){this._realtimeObject=e;this._value=t;this._client=this._realtimeObject.getClient()}get id(){if(this._value instanceof f)return this._value.getObjectId()}compact(){return this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._value instanceof p?this._value.compact():this.value()}compactJson(){if(this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._value instanceof p)return this._value.compactJson();let e=this.value();return this._client.Platform.BufferUtils.isBuffer(e)?this._client.Platform.BufferUtils.base64Encode(e):e}get(e){if(this._realtimeObject.throwIfInvalidAccessApiConfiguration(),!(this._value instanceof p))return;if(typeof e!="string")throw new this._client.ErrorInfo(`Key must be a string: ${e}`,40003,400);let t=this._value.get(e);if(t!==void 0)return new s(this._realtimeObject,t)}value(){if(this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._value instanceof f)return this._value instanceof h?this._value.value():void 0;if(this._client.Platform.BufferUtils.isBuffer(this._value)||typeof this._value=="string"||typeof this._value=="number"||typeof this._value=="boolean"||typeof this._value=="object"||this._value===null)return this._value;this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"DefaultInstance.value()",`unexpected value type for instance, resolving to undefined; value=${this._value}; type=${typeof this._value}`)}*entries(){if(this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._value instanceof p)for(let[e,t]of this._value.entries()){let i=new s(this._realtimeObject,t);yield[e,i]}}*keys(){this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._value instanceof p&&(yield*M(this._value.keys()))}*values(){for(let[e,t]of this.entries())yield t}size(){if(this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._value instanceof p)return this._value.size()}set(e,t){if(this._realtimeObject.throwIfInvalidWriteApiConfiguration(),!(this._value instanceof p))throw new this._client.ErrorInfo("Cannot set a key on a non-LiveMap instance",92007,400);return this._value.set(e,t)}remove(e){if(this._realtimeObject.throwIfInvalidWriteApiConfiguration(),!(this._value instanceof p))throw new this._client.ErrorInfo("Cannot remove a key from a non-LiveMap instance",92007,400);return this._value.remove(e)}increment(e){if(this._realtimeObject.throwIfInvalidWriteApiConfiguration(),!(this._value instanceof h))throw new this._client.ErrorInfo("Cannot increment a non-LiveCounter instance",92007,400);return this._value.increment(e!=null?e:1)}decrement(e){if(this._realtimeObject.throwIfInvalidWriteApiConfiguration(),!(this._value instanceof h))throw new this._client.ErrorInfo("Cannot decrement a non-LiveCounter instance",92007,400);return this._value.decrement(e!=null?e:1)}subscribe(e){if(this._realtimeObject.throwIfInvalidAccessApiConfiguration(),!(this._value instanceof f))throw new this._client.ErrorInfo("Cannot subscribe to a non-LiveObject instance",92007,400);return this._value.subscribe(t=>{var i;e({object:this,message:(i=t.message)==null?void 0:i.toUserFacingMessage(this._realtimeObject.getChannel())})})}subscribeIterator(){if(this._realtimeObject.throwIfInvalidAccessApiConfiguration(),!(this._value instanceof f))throw new this._client.ErrorInfo("Cannot subscribe to a non-LiveObject instance",92007,400);return this._client.Utils.listenerToAsyncIterator(e=>{let{unsubscribe:t}=this.subscribe(e);return t})}async batch(e){if(this._realtimeObject.throwIfInvalidWriteApiConfiguration(),!(this._value instanceof f))throw new this._client.ErrorInfo("Cannot batch operations on a non-LiveObject instance",92007,400);let t=new T(this._realtimeObject,this);try{e(t),await t.flush()}finally{t.close()}}isLiveMap(){return this._value instanceof p}isLiveCounter(){return this._value instanceof h}};var D=class s{constructor(e,t,i,n){this._realtimeObject=e;this._root=t;var a;this._client=this._realtimeObject.getClient(),this._path=[...(a=n==null?void 0:n._path)!=null?a:[],...i]}path(){return this._escapePath(this._path).join(".")}compact(){this._realtimeObject.throwIfInvalidAccessApiConfiguration();try{let e=this._resolvePath(this._path);return e instanceof p?e.compact():this.value()}catch(e){if(this._client.Utils.isErrorInfoOrPartialErrorInfo(e)&&e.code===92005)return;throw e}}compactJson(){this._realtimeObject.throwIfInvalidAccessApiConfiguration();try{let e=this._resolvePath(this._path);if(e instanceof p)return e.compactJson();let t=this.value();return this._client.Platform.BufferUtils.isBuffer(t)?this._client.Platform.BufferUtils.base64Encode(t):t}catch(e){if(this._client.Utils.isErrorInfoOrPartialErrorInfo(e)&&e.code===92005)return;throw e}}get(e){if(typeof e!="string")throw new this._client.ErrorInfo(`Path key must be a string: ${e}`,40003,400);return new s(this._realtimeObject,this._root,[e],this)}at(e){if(typeof e!="string")throw new this._client.ErrorInfo(`Path must be a string: ${e}`,40003,400);let t=[],i="",n=!1;for(let a of e){if(n){a!=="."&&(i+="\\"),i+=a,n=!1;continue}if(a==="\\"){n=!0;continue}if(a==="."){t.push(i),i="";continue}i+=a}return n&&(i+="\\"),t.push(i),new s(this._realtimeObject,this._root,t,this)}value(){this._realtimeObject.throwIfInvalidAccessApiConfiguration();try{let e=this._resolvePath(this._path);if(e instanceof f)return e instanceof h?e.value():void 0;if(this._client.Platform.BufferUtils.isBuffer(e)||typeof e=="string"||typeof e=="number"||typeof e=="boolean"||typeof e=="object"||e===null)return e;this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"PathObject.value()",`unexpected value type at path, resolving to undefined; path=${this._escapePath(this._path).join(".")}`);return}catch(e){if(this._client.Utils.isErrorInfoOrPartialErrorInfo(e)&&e.code===92005)return;throw e}}instance(){this._realtimeObject.throwIfInvalidAccessApiConfiguration();try{return this._resolveInstance()}catch(e){if(this._client.Utils.isErrorInfoOrPartialErrorInfo(e)&&e.code===92005)return;throw e}}*entries(){this._realtimeObject.throwIfInvalidAccessApiConfiguration();try{let e=this._resolvePath(this._path);if(!(e instanceof p))return;for(let[t,i]of e.entries()){let n=new s(this._realtimeObject,this._root,[t],this);yield[t,n]}}catch(e){if(this._client.Utils.isErrorInfoOrPartialErrorInfo(e)&&e.code===92005)return;throw e}}*keys(){this._realtimeObject.throwIfInvalidAccessApiConfiguration();try{let e=this._resolvePath(this._path);if(!(e instanceof p))return;yield*M(e.keys())}catch(e){if(this._client.Utils.isErrorInfoOrPartialErrorInfo(e)&&e.code===92005)return;throw e}}*values(){for(let[e,t]of this.entries())yield t}size(){this._realtimeObject.throwIfInvalidAccessApiConfiguration();try{let e=this._resolvePath(this._path);return e instanceof p?e.size():void 0}catch(e){if(this._client.Utils.isErrorInfoOrPartialErrorInfo(e)&&e.code===92005)return;throw e}}set(e,t){this._realtimeObject.throwIfInvalidWriteApiConfiguration();let i=this._resolvePath(this._path);if(!(i instanceof p))throw new this._client.ErrorInfo(`Cannot set a key on a non-LiveMap object at path: ${this._escapePath(this._path).join(".")}`,92007,400);return i.set(e,t)}remove(e){this._realtimeObject.throwIfInvalidWriteApiConfiguration();let t=this._resolvePath(this._path);if(!(t instanceof p))throw new this._client.ErrorInfo(`Cannot remove a key from a non-LiveMap object at path: ${this._escapePath(this._path).join(".")}`,92007,400);return t.remove(e)}increment(e){this._realtimeObject.throwIfInvalidWriteApiConfiguration();let t=this._resolvePath(this._path);if(!(t instanceof h))throw new this._client.ErrorInfo(`Cannot increment a non-LiveCounter object at path: ${this._escapePath(this._path).join(".")}`,92007,400);return t.increment(e!=null?e:1)}decrement(e){this._realtimeObject.throwIfInvalidWriteApiConfiguration();let t=this._resolvePath(this._path);if(!(t instanceof h))throw new this._client.ErrorInfo(`Cannot decrement a non-LiveCounter object at path: ${this._escapePath(this._path).join(".")}`,92007,400);return t.decrement(e!=null?e:1)}subscribe(e,t){return this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._realtimeObject.getPathObjectSubscriptionRegister().subscribe(this._path,e,t!=null?t:{})}subscribeIterator(e){return this._realtimeObject.throwIfInvalidAccessApiConfiguration(),this._client.Utils.listenerToAsyncIterator(t=>{let{unsubscribe:i}=this.subscribe(t,e);return i})}async batch(e){this._realtimeObject.throwIfInvalidWriteApiConfiguration();let t=this._resolveInstance();if(!t)throw new this._client.ErrorInfo(`Cannot batch operations on a non-LiveObject at path: ${this._escapePath(this._path).join(".")}`,92007,400);let i=new T(this._realtimeObject,t);try{e(i),await i.flush()}finally{i.close()}}_resolvePath(e){let t=this._root;for(let i=0;i<e.length;i++){let n=e[i];if(!(t instanceof p))throw new this._client.ErrorInfo(`Cannot resolve path segment '${n}' on non-collection type at path: ${this._escapePath(e.slice(0,i)).join(".")}`,92005,400);let a=t.get(n);if(a===void 0)throw new this._client.ErrorInfo(`Could not resolve value at path: ${this._escapePath(e.slice(0,i+1)).join(".")}`,92005,400);t=a}return t}_resolveInstance(){let e=this._resolvePath(this._path);if(e instanceof f)return new $(this._realtimeObject,e)}_escapePath(e){return e.map(t=>t.replace(/\./g,"\\."))}};var B=class{constructor(e){this._realtimeObject=e;this._subscriptions=new Map;this._nextSubscriptionId=0;this._client=this._realtimeObject.getClient()}subscribe(e,t,i){if(i==null||typeof i!="object")throw new this._client.ErrorInfo("Subscription options must be an object",4e4,400);if(i.depth!==void 0&&i.depth<=0)throw new this._client.ErrorInfo("Subscription depth must be greater than 0 or undefined for infinite depth",40003,400);let n=(this._nextSubscriptionId++).toString(),a={listener:t,options:i,path:[...e]};return this._subscriptions.set(n,a),{unsubscribe:()=>{this._subscriptions.delete(n)}}}notifyPathEvents(e){for(let t of e)this._processEvent(t)}_processEvent(e){var t;for(let i of this._subscriptions.values())if(this._shouldNotifySubscription(i,e))try{let n={object:new D(this._realtimeObject,this._realtimeObject.getPool().getRoot(),e.path),message:(t=e.message)==null?void 0:t.toUserFacingMessage(this._realtimeObject.getChannel())};i.listener(n)}catch(n){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"PathObjectSubscriptionRegister._processEvent()",`Error in PathObject subscription listener; path=${JSON.stringify(e.path)}, error=${n}`)}}_shouldNotifySubscription(e,t){let i=e.path,n=t.path,a=e.options.depth;return t.bubbles!==!1?this._pathStartsWith(n,i)?a===void 0?!0:n.length-i.length+1<=a:!1:this._pathsAreEqual(n,i)}_pathStartsWith(e,t){if(t.length>e.length)return!1;for(let i=0;i<t.length;i++)if(e[i]!==t[i])return!1;return!0}_pathsAreEqual(e,t){return this._client.Utils.arrEquals(e,t)}};var W=class{constructor(e){this._realtimeObject=e;this._client=this._realtimeObject.getClient(),this._channel=this._realtimeObject.getChannel(),this._pool=new Map}entries(){return this._pool.entries()}size(){return this._pool.size}isEmpty(){return this._pool.size===0}clear(){this._pool.clear()}applyObjectSyncMessages(e){for(let t of e){if(!t.object){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"SyncObjectsDataPool.applyObjectSyncMessages()",`object message is received during OBJECT_SYNC without 'object' field, skipping message; message id: ${t.id}, channel: ${this._channel.name}`);continue}let i=t.object;i.counter?this._pool.set(i.objectId,this._createLiveCounterDataEntry(t)):i.map?this._pool.set(i.objectId,this._createLiveMapDataEntry(t)):this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"SyncObjectsDataPool.applyObjectSyncMessages()",`received unsupported object state message during OBJECT_SYNC, expected 'counter' or 'map' to be present, skipping message; message id: ${t.id}, channel: ${this._channel.name}`)}}_createLiveCounterDataEntry(e){return{objectMessage:e,objectType:"LiveCounter"}}_createLiveMapDataEntry(e){return{objectMessage:e,objectType:"LiveMap"}}};var be={initialized:void 0,syncing:"syncing",synced:"synced"},P=class{constructor(e){var t,i;this._channel=e,this._client=e.client,this._state="initialized",this._eventEmitterInternal=new this._client.EventEmitter(this._client.logger),this._eventEmitterPublic=new this._client.EventEmitter(this._client.logger),this._objectsPool=new N(this),this._syncObjectsDataPool=new W(this),this._bufferedObjectOperations=[],this._pathObjectSubscriptionRegister=new B(this),this.gcGracePeriod=(i=(t=this._channel.connectionManager.connectionDetails)==null?void 0:t.objectsGCGracePeriod)!=null?i:L.gcGracePeriod,this._channel.connectionManager.on("connectiondetails",n=>{var a;this.gcGracePeriod=(a=n.objectsGCGracePeriod)!=null?a:L.gcGracePeriod})}async get(){return this._throwIfMissingChannelMode("object_subscribe"),await this._channel.ensureAttached(),this._state!=="synced"&&await this._eventEmitterInternal.once("synced"),new D(this,this._objectsPool.getRoot(),[])}on(e,t){return this._eventEmitterPublic.on(e,t),{off:()=>{this._eventEmitterPublic.off(e,t)}}}off(e,t){this._client.Utils.isNil(e)&&this._client.Utils.isNil(t)||this._eventEmitterPublic.off(e,t)}getPool(){return this._objectsPool}getChannel(){return this._channel}getClient(){return this._client}getPathObjectSubscriptionRegister(){return this._pathObjectSubscriptionRegister}handleObjectSyncMessages(e,t){let{syncId:i,syncCursor:n}=this._parseSyncChannelSerial(t);this._currentSyncId!==i&&this._startNewSync(i,n),this._syncObjectsDataPool.applyObjectSyncMessages(e),n||this._endSync()}handleObjectMessages(e){if(this._state!=="synced"){this._bufferedObjectOperations.push(...e);return}this._applyObjectMessages(e)}onAttached(e){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"RealtimeObject.onAttached()",`channel=${this._channel.name}, hasObjects=${e}`),this._startNewSync(),e||(this._objectsPool.resetToInitialPool(!0),this._syncObjectsDataPool.clear(),this._endSync())}actOnChannelState(e,t){switch(e){case"attached":this.onAttached(t);break;case"detached":case"failed":this._objectsPool.clearObjectsData(!1),this._syncObjectsDataPool.clear();break}}async publish(e){this._channel.throwIfUnpublishableState();let t=e.map(a=>a.encode(this._client)),i=this._client.options.maxMessageSize,n=t.reduce((a,r)=>a+r.getMessageSize(),0);if(n>i)throw new this._client.ErrorInfo(`Maximum size of object messages that can be published at once exceeded (was ${n} bytes; limit is ${i} bytes)`,40009,400);return this._channel.sendState(t)}throwIfInvalidAccessApiConfiguration(){this._throwIfMissingChannelMode("object_subscribe"),this._throwIfInChannelState(["detached","failed"])}throwIfInvalidWriteApiConfiguration(){this._throwIfMissingChannelMode("object_publish"),this._throwIfInChannelState(["detached","failed","suspended"]),this._throwIfEchoMessagesDisabled()}_startNewSync(e,t){this._bufferedObjectOperations=[],this._syncObjectsDataPool.clear(),this._currentSyncId=e,this._currentSyncCursor=t,this._stateChange("syncing")}_endSync(){this._applySync(),this._applyObjectMessages(this._bufferedObjectOperations),this._bufferedObjectOperations=[],this._syncObjectsDataPool.clear(),this._currentSyncId=void 0,this._currentSyncCursor=void 0,this._stateChange("synced")}_parseSyncChannelSerial(e){let t,i,n;return e&&(t=e.match(/^([\w-]+):(.*)$/))&&(i=t[1],n=t[2]),{syncId:i,syncCursor:n}}_applySync(){if(this._syncObjectsDataPool.isEmpty())return;let e=new Set,t=[];for(let[i,n]of this._syncObjectsDataPool.entries()){e.add(i);let a=this._objectsPool.get(i);if(a){let c=a.overrideWithObjectState(n.objectMessage);t.push({object:a,update:c});continue}let r,o=n.objectType;switch(o){case"LiveCounter":r=h.fromObjectState(this,n.objectMessage);break;case"LiveMap":r=p.fromObjectState(this,n.objectMessage);break;default:throw new this._client.ErrorInfo(`Unknown LiveObject type: ${o}`,5e4,500)}this._objectsPool.set(i,r)}this._objectsPool.deleteExtraObjectIds([...e]),this._rebuildAllParentReferences(),t.forEach(({object:i,update:n})=>i.notifyUpdated(n))}_applyObjectMessages(e){for(let t of e){if(!t.operation){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"RealtimeObject._applyObjectMessages()",`object operation message is received without 'operation' field, skipping message; message id: ${t.id}, channel: ${this._channel.name}`);continue}let i=t.operation;switch(i.action){case 0:case 3:case 1:case 2:case 4:case 5:this._objectsPool.createZeroValueObjectIfNotExists(i.objectId),this._objectsPool.get(i.objectId).applyOperation(i,t);break;default:this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"RealtimeObject._applyObjectMessages()",`received unsupported action in object operation message: ${i.action}, skipping message; message id: ${t.id}, channel: ${this._channel.name}`)}}}_throwIfMissingChannelMode(e){var t;if(this._channel.modes!=null&&!this._channel.modes.includes(e))throw new this._client.ErrorInfo(`"${e}" channel mode must be set for this operation`,40024,400);if(!this._client.Utils.allToLowerCase((t=this._channel.channelOptions.modes)!=null?t:[]).includes(e))throw new this._client.ErrorInfo(`"${e}" channel mode must be set for this operation`,40024,400)}_stateChange(e){if(this._state===e)return;this._state=e;let t=be[e];t&&(this._eventEmitterInternal.emit(t),this._eventEmitterPublic.emit(t))}_rebuildAllParentReferences(){for(let e of this._objectsPool.getAll())e.clearParentReferences();for(let e of this._objectsPool.getAll())if(e instanceof p)for(let[t,i]of e.entries())i instanceof f&&i.addParentReference(e,t)}_throwIfInChannelState(e){if(e.includes(this._channel.state))throw this._client.ErrorInfo.fromValues(this._channel.invalidStateError())}_throwIfEchoMessagesDisabled(){if(this._channel.client.options.echoMessages===!1)throw new this._channel.client.ErrorInfo('"echoMessages" client option must be enabled for this operation',4e4,400)}};P._DEFAULTS=L;var he={LiveCounter:g,LiveMap:I,ObjectMessage:m,RealtimeObject:P,WireObjectMessage:C};
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
//# sourceMappingURL=liveobjects.umd.min.js.map
