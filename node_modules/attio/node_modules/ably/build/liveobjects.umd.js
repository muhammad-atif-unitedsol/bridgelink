/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)

Ably JavaScript Library v2.16.0
https://github.com/ably/ably-js

Released under the Apache Licence v2.0*/(function (g, f) {
    if ("object" == typeof exports && "object" == typeof module) {
      module.exports = f();
    } else if ("function" == typeof define && define.amd) {
      define([], f);
    } else if ("object" == typeof exports) {
      exports["AblyLiveObjectsPlugin"] = f();
    } else {
      g["AblyLiveObjectsPlugin"] = f();
    }
  }(this, () => {
var exports = {};
var module = { exports };
"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => {
  if (symbol = Symbol[name])
    return symbol;
  throw Error("Symbol." + name + " is not defined");
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

// src/plugins/liveobjects/index.ts
var liveobjects_exports = {};
__export(liveobjects_exports, {
  LiveCounter: () => LiveCounterValueType,
  LiveMap: () => LiveMapValueType,
  LiveObjects: () => LiveObjects,
  ObjectMessage: () => ObjectMessage,
  RealtimeObject: () => RealtimeObject,
  WireObjectMessage: () => WireObjectMessage
});
module.exports = __toCommonJS(liveobjects_exports);

// src/plugins/liveobjects/objectid.ts
var ObjectId = class _ObjectId {
  constructor(type, hash, msTimestamp) {
    this.type = type;
    this.hash = hash;
    this.msTimestamp = msTimestamp;
  }
  static fromInitialValue(platform, objectType, initialValue, nonce, msTimestamp) {
    const valueForHashBuffer = platform.BufferUtils.concat([
      platform.BufferUtils.utf8Encode(initialValue),
      platform.BufferUtils.utf8Encode(":"),
      platform.BufferUtils.utf8Encode(nonce)
    ]);
    const hashBuffer = platform.BufferUtils.sha256(valueForHashBuffer);
    const hash = platform.BufferUtils.base64UrlEncode(hashBuffer);
    return new _ObjectId(objectType, hash, msTimestamp);
  }
  /**
   * Create ObjectId instance from hashed object id string.
   */
  static fromString(client, objectId) {
    if (client.Utils.isNil(objectId)) {
      throw new client.ErrorInfo("Invalid object id string", 92e3, 500);
    }
    const [type, rest] = objectId.split(":");
    if (!type || !rest) {
      throw new client.ErrorInfo("Invalid object id string", 92e3, 500);
    }
    if (!["map", "counter"].includes(type)) {
      throw new client.ErrorInfo(`Invalid object type in object id: ${objectId}`, 92e3, 500);
    }
    const [hash, msTimestamp] = rest.split("@");
    if (!hash || !msTimestamp) {
      throw new client.ErrorInfo("Invalid object id string", 92e3, 500);
    }
    if (!Number.isInteger(Number.parseInt(msTimestamp))) {
      throw new client.ErrorInfo("Invalid object id string", 92e3, 500);
    }
    return new _ObjectId(type, hash, Number.parseInt(msTimestamp));
  }
  toString() {
    return `${this.type}:${this.hash}@${this.msTimestamp}`;
  }
};

// src/plugins/liveobjects/objectmessage.ts
var operationActions = [
  "map.create",
  "map.set",
  "map.remove",
  "counter.create",
  "counter.inc",
  "object.delete"
];
var mapSemantics = ["lww"];
function encode(message, utils, messageEncoding, encodeObjectDataFn) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const result = Object.assign(new WireObjectMessage(utils, messageEncoding), copyMsg(message));
  if ((_b = (_a = message.object) == null ? void 0 : _a.map) == null ? void 0 : _b.entries) {
    result.object.map.entries = encodeMapEntries(message.object.map.entries, encodeObjectDataFn);
  }
  if ((_e = (_d = (_c = message.object) == null ? void 0 : _c.createOp) == null ? void 0 : _d.map) == null ? void 0 : _e.entries) {
    result.object.createOp.map.entries = encodeMapEntries(message.object.createOp.map.entries, encodeObjectDataFn);
  }
  if ((_h = (_g = (_f = message.object) == null ? void 0 : _f.createOp) == null ? void 0 : _g.mapOp) == null ? void 0 : _h.data) {
    result.object.createOp.mapOp.data = encodeObjectData(message.object.createOp.mapOp.data, encodeObjectDataFn);
  }
  if ((_j = (_i = message.operation) == null ? void 0 : _i.map) == null ? void 0 : _j.entries) {
    result.operation.map.entries = encodeMapEntries(message.operation.map.entries, encodeObjectDataFn);
  }
  if ((_l = (_k = message.operation) == null ? void 0 : _k.mapOp) == null ? void 0 : _l.data) {
    result.operation.mapOp.data = encodeObjectData(message.operation.mapOp.data, encodeObjectDataFn);
  }
  return result;
}
function encodeMapEntries(mapEntries, encodeFn) {
  return Object.entries(mapEntries).reduce(
    (acc, v) => {
      const [key, entry] = v;
      const encodedData = entry.data ? encodeObjectData(entry.data, encodeFn) : void 0;
      acc[key] = __spreadProps(__spreadValues({}, entry), {
        data: encodedData
      });
      return acc;
    },
    {}
  );
}
function encodeObjectData(data, encodeFn) {
  const encodedData = encodeFn(data);
  return encodedData;
}
function createInitialValueJSONString(operation, client) {
  const msg = ObjectMessage.fromValues(
    // cast initialValue to ObjectOperation here, even though it may lack some properties
    // that are usually present on ObjectOperation.
    // this ObjectMessage instance is only used to get the encoded body,
    // so it's ok for the operation field to be incomplete in this context.
    // doing the type assertion here avoids the need to define a separate ObjectMessage
    // type that supports a fully optional ObjectOperation.
    { operation },
    client.Utils,
    client.MessageEncoding
  );
  const wireMsg = msg.encode(client);
  const { operation: encodedOperation } = wireMsg.encodeForWire(client.Utils.Format.json);
  return JSON.stringify(encodedOperation);
}
function strMsg(msg, className) {
  let result = "[" + className;
  for (const attr in msg) {
    if (msg[attr] === void 0 || attr === "_utils" || attr === "_messageEncoding") {
      continue;
    }
    if (attr === "operation" || attr === "object" || attr === "extras") {
      result += `; ${attr}=${JSON.stringify(msg[attr])}`;
    } else {
      result += `; ${attr}=${msg[attr]}`;
    }
  }
  result += "]";
  return result;
}
function copyMsg(msg) {
  const result = {
    id: msg.id,
    clientId: msg.clientId,
    connectionId: msg.connectionId,
    timestamp: msg.timestamp,
    serial: msg.serial,
    serialTimestamp: msg.serialTimestamp,
    siteCode: msg.siteCode
  };
  if (msg.operation) {
    result.operation = JSON.parse(JSON.stringify(msg.operation));
  }
  if (msg.object) {
    result.object = JSON.parse(JSON.stringify(msg.object));
  }
  if (msg.extras) {
    result.extras = JSON.parse(JSON.stringify(msg.extras));
  }
  return result;
}
function stringifyOperation(operation) {
  return __spreadProps(__spreadValues({}, operation), {
    action: operationActions[operation.action] || "unknown",
    map: operation.map ? __spreadProps(__spreadValues({}, operation.map), {
      semantics: operation.map.semantics != null ? mapSemantics[operation.map.semantics] || "unknown" : void 0
    }) : void 0
  });
}
var ObjectMessage = class _ObjectMessage {
  // OM2i
  constructor(_utils, _messageEncoding) {
    this._utils = _utils;
    this._messageEncoding = _messageEncoding;
  }
  static fromValues(values, utils, messageEncoding) {
    return Object.assign(new _ObjectMessage(utils, messageEncoding), values);
  }
  static fromValuesArray(values, utils, messageEncoding) {
    return values.map((x) => _ObjectMessage.fromValues(x, utils, messageEncoding));
  }
  /**
   * Protocol agnostic encoding of this ObjectMessage. Returns a new {@link WireObjectMessage} instance.
   *
   * Uses encoding functions from regular `Message` processing.
   *
   * @spec OM4
   */
  encode(client) {
    const encodeObjectDataFn = (data) => {
      const encodedObjectData = { objectId: data.objectId };
      if (client.Platform.BufferUtils.isBuffer(data.value)) {
        encodedObjectData.bytes = data.value;
      } else if (typeof data.value === "string") {
        encodedObjectData.string = data.value;
      } else if (typeof data.value === "boolean") {
        encodedObjectData.boolean = data.value;
      } else if (typeof data.value === "number") {
        encodedObjectData.number = data.value;
      } else if (typeof data.value === "object" && data.value !== null) {
        encodedObjectData.json = JSON.stringify(data.value);
      }
      return encodedObjectData;
    };
    return encode(this, this._utils, this._messageEncoding, encodeObjectDataFn);
  }
  toString() {
    return strMsg(this, "ObjectMessage");
  }
  isOperationMessage() {
    return this.operation != null;
  }
  isSyncMessage() {
    return this.object != null;
  }
  toUserFacingMessage(channel) {
    return {
      id: this.id,
      clientId: this.clientId,
      connectionId: this.connectionId,
      timestamp: this.timestamp,
      channel: channel.name,
      // we expose only operation messages to users, so operation field is always present
      operation: stringifyOperation(this.operation),
      serial: this.serial,
      serialTimestamp: this.serialTimestamp,
      siteCode: this.siteCode,
      extras: this.extras
    };
  }
};
var WireObjectMessage = class _WireObjectMessage {
  // OM2i
  constructor(_utils, _messageEncoding) {
    this._utils = _utils;
    this._messageEncoding = _messageEncoding;
  }
  static fromValues(values, utils, messageEncoding) {
    return Object.assign(new _WireObjectMessage(utils, messageEncoding), values);
  }
  static fromValuesArray(values, utils, messageEncoding) {
    return values.map((x) => _WireObjectMessage.fromValues(x, utils, messageEncoding));
  }
  /**
   * Encodes WireObjectMessage for wire transmission. Does not mutate the provided WireObjectMessage.
   *
   * Uses encoding functions from regular `Message` processing.
   */
  encodeForWire(format) {
    const encodeObjectDataFn = (data) => {
      if (data.bytes != null) {
        const result = this._messageEncoding.encodeDataForWire(data.bytes, null, format);
        return __spreadProps(__spreadValues({}, data), { bytes: result.data });
      }
      return __spreadValues({}, data);
    };
    return encode(this, this._utils, this._messageEncoding, encodeObjectDataFn);
  }
  /**
   * Decodes this WireObjectMessage and returns a new {@link ObjectMessage} instance.
   *
   * Format is used to decode the bytes value as it's implicitly encoded depending on the protocol used:
   * - json: bytes are Base64-encoded string
   * - msgpack: bytes have a binary representation and don't need to be decoded
   *
   * @spec OM5
   */
  decode(client, format) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const result = Object.assign(new ObjectMessage(this._utils, this._messageEncoding), copyMsg(this));
    try {
      if ((_b = (_a = this.object) == null ? void 0 : _a.map) == null ? void 0 : _b.entries) {
        result.object.map.entries = this._decodeMapEntries(this.object.map.entries, client, format);
      }
      if ((_e = (_d = (_c = this.object) == null ? void 0 : _c.createOp) == null ? void 0 : _d.map) == null ? void 0 : _e.entries) {
        result.object.createOp.map.entries = this._decodeMapEntries(
          this.object.createOp.map.entries,
          client,
          format
        );
      }
      if ((_h = (_g = (_f = this.object) == null ? void 0 : _f.createOp) == null ? void 0 : _g.mapOp) == null ? void 0 : _h.data) {
        result.object.createOp.mapOp.data = this._decodeObjectData(this.object.createOp.mapOp.data, client, format);
      }
      if ((_j = (_i = this.operation) == null ? void 0 : _i.map) == null ? void 0 : _j.entries) {
        result.operation.map.entries = this._decodeMapEntries(this.operation.map.entries, client, format);
      }
      if ((_l = (_k = this.operation) == null ? void 0 : _k.mapOp) == null ? void 0 : _l.data) {
        result.operation.mapOp.data = this._decodeObjectData(this.operation.mapOp.data, client, format);
      }
    } catch (error) {
      client.Logger.logAction(
        client.logger,
        client.Logger.LOG_ERROR,
        "WireObjectMessage.decode()",
        this._utils.inspectError(error)
      );
    }
    return result;
  }
  /**
   * Overload toJSON() to intercept JSON.stringify().
   *
   * This will prepare the message to be transmitted over the wire to Ably.
   * It will encode the data payload according to the wire protocol used on the client.
   */
  toJSON() {
    const format = arguments.length > 0 ? this._utils.Format.json : this._utils.Format.msgpack;
    const _a = this.encodeForWire(format), { _utils, _messageEncoding } = _a, publicProps = __objRest(_a, ["_utils", "_messageEncoding"]);
    return publicProps;
  }
  toString() {
    return strMsg(this, "WireObjectMessage");
  }
  /** @spec OM3 */
  getMessageSize() {
    var _a, _b;
    let size = 0;
    size += (_b = (_a = this.clientId) == null ? void 0 : _a.length) != null ? _b : 0;
    if (this.operation) {
      size += this._getObjectOperationSize(this.operation);
    }
    if (this.object) {
      size += this._getObjectStateSize(this.object);
    }
    if (this.extras) {
      size += JSON.stringify(this.extras).length;
    }
    return size;
  }
  /** @spec OOP4 */
  _getObjectOperationSize(operation) {
    let size = 0;
    if (operation.mapOp) {
      size += this._getMapOpSize(operation.mapOp);
    }
    if (operation.counterOp) {
      size += this._getCounterOpSize(operation.counterOp);
    }
    if (operation.map) {
      size += this._getObjectMapSize(operation.map);
    }
    if (operation.counter) {
      size += this._getObjectCounterSize(operation.counter);
    }
    return size;
  }
  /** @spec OST3 */
  _getObjectStateSize(obj) {
    let size = 0;
    if (obj.map) {
      size += this._getObjectMapSize(obj.map);
    }
    if (obj.counter) {
      size += this._getObjectCounterSize(obj.counter);
    }
    if (obj.createOp) {
      size += this._getObjectOperationSize(obj.createOp);
    }
    return size;
  }
  /** @spec OMP4 */
  _getObjectMapSize(map) {
    var _a;
    let size = 0;
    Object.entries((_a = map.entries) != null ? _a : {}).forEach(([key, entry]) => {
      var _a2;
      size += (_a2 = key == null ? void 0 : key.length) != null ? _a2 : 0;
      if (entry) {
        size += this._getMapEntrySize(entry);
      }
    });
    return size;
  }
  /** @spec OCN3 */
  _getObjectCounterSize(counter) {
    if (counter.count == null) {
      return 0;
    }
    return 8;
  }
  /** @spec OME3 */
  _getMapEntrySize(entry) {
    let size = 0;
    if (entry.data) {
      size += this._getObjectDataSize(entry.data);
    }
    return size;
  }
  /** @spec OMO3 */
  _getMapOpSize(mapOp) {
    var _a, _b;
    let size = 0;
    size += (_b = (_a = mapOp.key) == null ? void 0 : _a.length) != null ? _b : 0;
    if (mapOp.data) {
      size += this._getObjectDataSize(mapOp.data);
    }
    return size;
  }
  /** @spec OCO3 */
  _getCounterOpSize(operation) {
    if (operation.amount == null) {
      return 0;
    }
    return 8;
  }
  /** @spec OD3 */
  _getObjectDataSize(data) {
    let size = 0;
    if (data.boolean != null) {
      size += this._utils.dataSizeBytes(data.boolean);
    }
    if (data.bytes != null) {
      size += this._utils.dataSizeBytes(data.bytes);
    }
    if (data.number != null) {
      size += this._utils.dataSizeBytes(data.number);
    }
    if (data.string != null) {
      size += this._utils.dataSizeBytes(data.string);
    }
    if (data.json != null) {
      size += this._utils.dataSizeBytes(data.json);
    }
    return size;
  }
  _decodeMapEntries(mapEntries, client, format) {
    return Object.entries(mapEntries).reduce(
      (acc, v) => {
        const [key, entry] = v;
        const decodedData = entry.data ? this._decodeObjectData(entry.data, client, format) : void 0;
        acc[key] = __spreadProps(__spreadValues({}, entry), {
          data: decodedData
        });
        return acc;
      },
      {}
    );
  }
  /** @spec OD5 */
  _decodeObjectData(objectData, client, format) {
    var _a, _b, _c;
    try {
      if (objectData.objectId != null) {
        return {
          objectId: objectData.objectId
        };
      }
      let decodedBytes;
      if (objectData.bytes != null) {
        decodedBytes = format === "msgpack" ? (
          // OD5a1 - connection is using msgpack protocol, bytes are already a buffer
          objectData.bytes
        ) : (
          // OD5b2 - connection is using JSON protocol, Base64-decode bytes value
          client.Platform.BufferUtils.base64Decode(String(objectData.bytes))
        );
      }
      let decodedJson;
      if (objectData.json != null) {
        decodedJson = JSON.parse(objectData.json);
      }
      return {
        value: (_c = (_b = (_a = decodedBytes != null ? decodedBytes : decodedJson) != null ? _a : objectData.boolean) != null ? _b : objectData.number) != null ? _c : objectData.string
      };
    } catch (error) {
      client.Logger.logAction(
        client.logger,
        client.Logger.LOG_ERROR,
        "WireObjectMessage._decodeObjectData()",
        this._utils.inspectError(error)
      );
      return __spreadValues({}, objectData);
    }
  }
};

// src/plugins/liveobjects/livecountervaluetype.ts
var LiveCounterValueType = class _LiveCounterValueType {
  constructor(count) {
    // type-only, unique symbol to satisfy branded interfaces, no JS emitted
    this._livetype = "LiveCounter";
    this._count = count;
    Object.freeze(this);
  }
  static create(initialCount = 0) {
    return new _LiveCounterValueType(initialCount);
  }
  /**
   * @internal
   */
  static instanceof(value) {
    return typeof value === "object" && value !== null && value._livetype === "LiveCounter";
  }
  /**
   * @internal
   */
  static async createCounterCreateMessage(realtimeObject, value) {
    const client = realtimeObject.getClient();
    const count = value._count;
    if (count !== void 0 && (typeof count !== "number" || !Number.isFinite(count))) {
      throw new client.ErrorInfo("Counter value should be a valid number", 40003, 400);
    }
    const initialValueOperation = _LiveCounterValueType.createInitialValueOperation(count);
    const initialValueJSONString = createInitialValueJSONString(initialValueOperation, client);
    const nonce = client.Utils.cheapRandStr();
    const msTimestamp = await client.getTimestamp(true);
    const objectId = ObjectId.fromInitialValue(
      client.Platform,
      "counter",
      initialValueJSONString,
      nonce,
      msTimestamp
    ).toString();
    const msg = ObjectMessage.fromValues(
      {
        operation: __spreadProps(__spreadValues({}, initialValueOperation), {
          action: 3 /* COUNTER_CREATE */,
          objectId,
          nonce,
          initialValue: initialValueJSONString
        })
      },
      client.Utils,
      client.MessageEncoding
    );
    return msg;
  }
  static createInitialValueOperation(count) {
    return {
      counter: {
        count: count != null ? count : 0
      }
    };
  }
};

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// src/plugins/liveobjects/constants.ts
var ROOT_OBJECT_ID = "root";

// src/plugins/liveobjects/liveobject.ts
var LiveObject = class {
  constructor(_realtimeObject, objectId) {
    this._realtimeObject = _realtimeObject;
    this._client = this._realtimeObject.getClient();
    this._subscriptions = new this._client.EventEmitter(this._client.logger);
    this._objectId = objectId;
    this._dataRef = this._getZeroValueData();
    this._siteTimeserials = {};
    this._createOperationIsMerged = false;
    this._tombstone = false;
    this._parentReferences = /* @__PURE__ */ new Map();
  }
  subscribe(listener) {
    this._subscriptions.on("updated" /* updated */, listener);
    const unsubscribe = () => {
      this._subscriptions.off("updated" /* updated */, listener);
    };
    return { unsubscribe };
  }
  /**
   * @internal
   */
  getObjectId() {
    return this._objectId;
  }
  /**
   * Emits the {@link LiveObjectSubscriptionEvent.updated} event with provided update object if it isn't a noop.
   * Also notifies the path object subscriptions about path-based events.
   *
   * @internal
   */
  notifyUpdated(update) {
    if (this._isNoopUpdate(update)) {
      return;
    }
    this._notifyInstanceSubscriptions(update);
    this._notifyPathSubscriptions(update);
    if (update.tombstone) {
      this._subscriptions.off();
    }
  }
  /**
   * Clears the object's data, cancels any buffered operations and sets the tombstone flag to `true`.
   *
   * @internal
   */
  tombstone(objectMessage) {
    this._tombstone = true;
    if (objectMessage.serialTimestamp != null) {
      this._tombstonedAt = objectMessage.serialTimestamp;
    } else {
      this._client.Logger.logAction(
        this._client.logger,
        this._client.Logger.LOG_MINOR,
        "LiveObject.tombstone()",
        `object has been tombstoned but no "serialTimestamp" found in the message, using local clock instead; objectId=${this.getObjectId()}`
      );
      this._tombstonedAt = Date.now();
    }
    const update = this.clearData();
    update.objectMessage = objectMessage;
    update.tombstone = true;
    return update;
  }
  /**
   * @internal
   */
  isTombstoned() {
    return this._tombstone;
  }
  /**
   * @internal
   */
  tombstonedAt() {
    return this._tombstonedAt;
  }
  /**
   * @internal
   */
  clearData() {
    const previousDataRef = this._dataRef;
    this._dataRef = this._getZeroValueData();
    return this._updateFromDataDiff(previousDataRef, this._dataRef);
  }
  /**
   * Add a parent reference indicating that this object is referenced by the given parent LiveMap at the specified key.
   *
   * @internal
   */
  addParentReference(parent, key) {
    const keys = this._parentReferences.get(parent);
    if (keys) {
      keys.add(key);
    } else {
      this._parentReferences.set(parent, /* @__PURE__ */ new Set([key]));
    }
  }
  /**
   * Remove a parent reference indicating that this object is no longer referenced by the given parent LiveMap at the specified key.
   *
   * @internal
   */
  removeParentReference(parent, key) {
    const keys = this._parentReferences.get(parent);
    if (keys) {
      keys.delete(key);
      if (keys.size === 0) {
        this._parentReferences.delete(parent);
      }
    }
  }
  /**
   * Remove all parent references for a specific parent (when parent is being deleted or cleared).
   *
   * @internal
   */
  removeParentReferenceAll(parent) {
    this._parentReferences.delete(parent);
  }
  /**
   * Clears all parent references for this object.
   *
   * @internal
   */
  clearParentReferences() {
    this._parentReferences.clear();
  }
  /**
   * Calculates and returns all possible paths to this object from the root object by traversing up the parent hierarchy.
   * Uses iterative DFS with an explicit stack. Each path is represented as an array of keys from root to this object.
   *
   * @internal
   */
  getFullPaths() {
    const paths = [];
    const stack = [
      { obj: this, currentPath: [], visited: /* @__PURE__ */ new Set() }
    ];
    while (stack.length > 0) {
      const { obj, currentPath, visited } = stack.pop();
      if (visited.has(obj)) {
        continue;
      }
      const newVisited = new Set(visited);
      newVisited.add(obj);
      if (obj.getObjectId() === ROOT_OBJECT_ID) {
        paths.push(currentPath);
        continue;
      }
      for (const [parent, keys] of obj._parentReferences) {
        for (const key of keys) {
          stack.push({
            obj: parent,
            currentPath: [key, ...currentPath],
            visited: newVisited
          });
        }
      }
    }
    return paths;
  }
  /**
   * Returns true if the given serial indicates that the operation to which it belongs should be applied to the object.
   *
   * An operation should be applied if its serial is strictly greater than the serial in the `siteTimeserials` map for the same site.
   * If `siteTimeserials` map does not contain a serial for the same site, the operation should be applied.
   */
  _canApplyOperation(opSerial, opSiteCode) {
    if (!opSerial) {
      throw new this._client.ErrorInfo(`Invalid serial: ${opSerial}`, 92e3, 500);
    }
    if (!opSiteCode) {
      throw new this._client.ErrorInfo(`Invalid site code: ${opSiteCode}`, 92e3, 500);
    }
    const siteSerial = this._siteTimeserials[opSiteCode];
    return !siteSerial || opSerial > siteSerial;
  }
  _applyObjectDelete(objectMessage) {
    return this.tombstone(objectMessage);
  }
  _notifyInstanceSubscriptions(update) {
    var _a;
    const event = {
      // Do not expose object sync messages as they do not represent a single operation on an object
      message: ((_a = update.objectMessage) == null ? void 0 : _a.isOperationMessage()) ? update.objectMessage : void 0
    };
    this._subscriptions.emit("updated" /* updated */, event);
  }
  /**
   * Notifies path-based subscriptions about changes to this object.
   * For LiveMapUpdate events, also creates non-bubbling events for each updated key.
   */
  _notifyPathSubscriptions(update) {
    var _a;
    const paths = this.getFullPaths();
    if (paths.length === 0) {
      return;
    }
    const operationObjectMessage = ((_a = update.objectMessage) == null ? void 0 : _a.isOperationMessage()) ? update.objectMessage : void 0;
    const pathEvents = paths.map((path) => ({
      path,
      message: operationObjectMessage,
      bubbles: true
    }));
    if (update._type === "LiveMapUpdate") {
      const updatedKeys = Object.keys(update.update);
      for (const key of updatedKeys) {
        for (const basePath of paths) {
          pathEvents.push({
            path: [...basePath, key],
            message: operationObjectMessage,
            bubbles: false
          });
        }
      }
    }
    this._realtimeObject.getPathObjectSubscriptionRegister().notifyPathEvents(pathEvents);
  }
  _isNoopUpdate(update) {
    return update.noop === true;
  }
};

// src/plugins/liveobjects/livecounter.ts
var LiveCounter = class _LiveCounter extends LiveObject {
  // type-only, unique symbol to satisfy branded interfaces, no JS emitted
  /**
   * Returns a {@link LiveCounter} instance with a 0 value.
   *
   * @internal
   * @spec RTLC4
   */
  static zeroValue(realtimeObject, objectId) {
    return new _LiveCounter(realtimeObject, objectId);
  }
  /**
   * Returns a {@link LiveCounter} instance based on the provided object state.
   * The provided object state must hold a valid counter object data.
   *
   * @internal
   */
  static fromObjectState(realtimeObject, objectMessage) {
    const obj = new _LiveCounter(realtimeObject, objectMessage.object.objectId);
    obj.overrideWithObjectState(objectMessage);
    return obj;
  }
  /**
   * @internal
   */
  static createCounterIncMessage(realtimeObject, objectId, amount) {
    const client = realtimeObject.getClient();
    if (typeof amount !== "number" || !Number.isFinite(amount)) {
      throw new client.ErrorInfo("Counter value increment should be a valid number", 40003, 400);
    }
    const msg = ObjectMessage.fromValues(
      {
        operation: {
          action: 4 /* COUNTER_INC */,
          objectId,
          counterOp: { amount }
        }
      },
      client.Utils,
      client.MessageEncoding
    );
    return msg;
  }
  /** @spec RTLC5 */
  value() {
    return this._dataRef.data;
  }
  /**
   * Send a COUNTER_INC operation to the realtime system to increment a value on this LiveCounter object.
   *
   * This does not modify the underlying data of this LiveCounter object. Instead, the change will be applied when
   * the published COUNTER_INC operation is echoed back to the client and applied to the object following the regular
   * operation application procedure.
   *
   * @returns A promise which resolves upon receiving the ACK message for the published operation message.
   */
  async increment(amount) {
    const msg = _LiveCounter.createCounterIncMessage(this._realtimeObject, this.getObjectId(), amount);
    return this._realtimeObject.publish([msg]);
  }
  /**
   * An alias for calling {@link LiveCounter.increment | LiveCounter.increment(-amount)}
   */
  async decrement(amount) {
    if (typeof amount !== "number" || !Number.isFinite(amount)) {
      throw new this._client.ErrorInfo("Counter value decrement should be a valid number", 40003, 400);
    }
    return this.increment(-amount);
  }
  /**
   * @internal
   */
  applyOperation(op, msg) {
    var _a;
    if (op.objectId !== this.getObjectId()) {
      throw new this._client.ErrorInfo(
        `Cannot apply object operation with objectId=${op.objectId}, to this LiveCounter with objectId=${this.getObjectId()}`,
        92e3,
        500
      );
    }
    const opSerial = msg.serial;
    const opSiteCode = msg.siteCode;
    if (!this._canApplyOperation(opSerial, opSiteCode)) {
      this._client.Logger.logAction(
        this._client.logger,
        this._client.Logger.LOG_MICRO,
        "LiveCounter.applyOperation()",
        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${(_a = this._siteTimeserials[opSiteCode]) == null ? void 0 : _a.toString()}; objectId=${this.getObjectId()}`
      );
      return;
    }
    this._siteTimeserials[opSiteCode] = opSerial;
    if (this.isTombstoned()) {
      return;
    }
    let update;
    switch (op.action) {
      case 3 /* COUNTER_CREATE */:
        update = this._applyCounterCreate(op, msg);
        break;
      case 4 /* COUNTER_INC */:
        if (this._client.Utils.isNil(op.counterOp)) {
          this._throwNoPayloadError(op);
          return;
        } else {
          update = this._applyCounterInc(op.counterOp, msg);
        }
        break;
      case 5 /* OBJECT_DELETE */:
        update = this._applyObjectDelete(msg);
        break;
      default:
        throw new this._client.ErrorInfo(
          `Invalid ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,
          92e3,
          500
        );
    }
    this.notifyUpdated(update);
  }
  /**
   * @internal
   * @spec RTLC6
   */
  overrideWithObjectState(objectMessage) {
    var _a, _b, _c, _d, _e;
    const objectState = objectMessage.object;
    if (objectState == null) {
      throw new this._client.ErrorInfo(`Missing object state; LiveCounter objectId=${this.getObjectId()}`, 92e3, 500);
    }
    if (objectState.objectId !== this.getObjectId()) {
      throw new this._client.ErrorInfo(
        `Invalid object state: object state objectId=${objectState.objectId}; LiveCounter objectId=${this.getObjectId()}`,
        92e3,
        500
      );
    }
    if (!this._client.Utils.isNil(objectState.createOp)) {
      if (objectState.createOp.objectId !== this.getObjectId()) {
        throw new this._client.ErrorInfo(
          `Invalid object state: object state createOp objectId=${(_a = objectState.createOp) == null ? void 0 : _a.objectId}; LiveCounter objectId=${this.getObjectId()}`,
          92e3,
          500
        );
      }
      if (objectState.createOp.action !== 3 /* COUNTER_CREATE */) {
        throw new this._client.ErrorInfo(
          `Invalid object state: object state createOp action=${(_b = objectState.createOp) == null ? void 0 : _b.action}; LiveCounter objectId=${this.getObjectId()}`,
          92e3,
          500
        );
      }
    }
    this._siteTimeserials = (_c = objectState.siteTimeserials) != null ? _c : {};
    if (this.isTombstoned()) {
      return { noop: true };
    }
    const previousDataRef = this._dataRef;
    let update;
    if (objectState.tombstone) {
      update = this.tombstone(objectMessage);
    } else {
      this._createOperationIsMerged = false;
      this._dataRef = { data: (_e = (_d = objectState.counter) == null ? void 0 : _d.count) != null ? _e : 0 };
      if (!this._client.Utils.isNil(objectState.createOp)) {
        this._mergeInitialDataFromCreateOperation(objectState.createOp, objectMessage);
      }
      update = this._updateFromDataDiff(previousDataRef, this._dataRef);
      update.objectMessage = objectMessage;
    }
    return update;
  }
  /**
   * @internal
   */
  onGCInterval() {
    return;
  }
  /** @spec RTLC4 */
  _getZeroValueData() {
    return { data: 0 };
  }
  _updateFromDataDiff(prevDataRef, newDataRef) {
    const counterDiff = newDataRef.data - prevDataRef.data;
    return { update: { amount: counterDiff }, _type: "LiveCounterUpdate" };
  }
  _mergeInitialDataFromCreateOperation(objectOperation, msg) {
    var _a, _b, _c, _d;
    this._dataRef.data += (_b = (_a = objectOperation.counter) == null ? void 0 : _a.count) != null ? _b : 0;
    this._createOperationIsMerged = true;
    return {
      update: { amount: (_d = (_c = objectOperation.counter) == null ? void 0 : _c.count) != null ? _d : 0 },
      objectMessage: msg,
      _type: "LiveCounterUpdate"
    };
  }
  _throwNoPayloadError(op) {
    throw new this._client.ErrorInfo(
      `No payload found for ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,
      92e3,
      500
    );
  }
  _applyCounterCreate(op, msg) {
    if (this._createOperationIsMerged) {
      this._client.Logger.logAction(
        this._client.logger,
        this._client.Logger.LOG_MICRO,
        "LiveCounter._applyCounterCreate()",
        `skipping applying COUNTER_CREATE op on a counter instance as it was already applied before; objectId=${this.getObjectId()}`
      );
      return { noop: true };
    }
    return this._mergeInitialDataFromCreateOperation(op, msg);
  }
  _applyCounterInc(op, msg) {
    this._dataRef.data += op.amount;
    return {
      update: { amount: op.amount },
      objectMessage: msg,
      _type: "LiveCounterUpdate"
    };
  }
};

// src/plugins/liveobjects/livemap.ts
var LiveMap = class _LiveMap extends LiveObject {
  // type-only, unique symbol to satisfy branded interfaces, no JS emitted
  constructor(realtimeObject, _semantics, objectId) {
    super(realtimeObject, objectId);
    this._semantics = _semantics;
  }
  /**
   * Returns a {@link LiveMap} instance with an empty map data.
   *
   * @internal
   * @spec RTLM4
   */
  static zeroValue(realtimeObject, objectId) {
    return new _LiveMap(realtimeObject, 0 /* LWW */, objectId);
  }
  /**
   * Returns a {@link LiveMap} instance based on the provided object state.
   * The provided object state must hold a valid map object data.
   *
   * @internal
   */
  static fromObjectState(realtimeObject, objectMessage) {
    const obj = new _LiveMap(realtimeObject, objectMessage.object.map.semantics, objectMessage.object.objectId);
    obj.overrideWithObjectState(objectMessage);
    return obj;
  }
  /**
   * @internal
   */
  static async createMapSetMessage(realtimeObject, objectId, key, value) {
    var _a, _b;
    const client = realtimeObject.getClient();
    _LiveMap.validateKeyValue(realtimeObject, key, value);
    let objectData;
    let createValueTypesMessages = [];
    if (LiveCounterValueType.instanceof(value)) {
      const counterCreateMsg = await LiveCounterValueType.createCounterCreateMessage(realtimeObject, value);
      createValueTypesMessages = [counterCreateMsg];
      const typedObjectData = { objectId: (_a = counterCreateMsg.operation) == null ? void 0 : _a.objectId };
      objectData = typedObjectData;
    } else if (LiveMapValueType.instanceof(value)) {
      const { mapCreateMsg, nestedObjectsCreateMsgs } = await LiveMapValueType.createMapCreateMessage(
        realtimeObject,
        value
      );
      createValueTypesMessages = [...nestedObjectsCreateMsgs, mapCreateMsg];
      const typedObjectData = { objectId: (_b = mapCreateMsg.operation) == null ? void 0 : _b.objectId };
      objectData = typedObjectData;
    } else {
      const typedObjectData = { value };
      objectData = typedObjectData;
    }
    const mapSetMsg = ObjectMessage.fromValues(
      {
        operation: {
          action: 1 /* MAP_SET */,
          objectId,
          mapOp: {
            key,
            data: objectData
          }
        }
      },
      client.Utils,
      client.MessageEncoding
    );
    return [...createValueTypesMessages, mapSetMsg];
  }
  /**
   * @internal
   */
  static createMapRemoveMessage(realtimeObject, objectId, key) {
    const client = realtimeObject.getClient();
    if (typeof key !== "string") {
      throw new client.ErrorInfo("Map key should be string", 40003, 400);
    }
    const msg = ObjectMessage.fromValues(
      {
        operation: {
          action: 2 /* MAP_REMOVE */,
          objectId,
          mapOp: { key }
        }
      },
      client.Utils,
      client.MessageEncoding
    );
    return msg;
  }
  /**
   * @internal
   */
  static validateKeyValue(realtimeObject, key, value) {
    const client = realtimeObject.getClient();
    if (typeof key !== "string") {
      throw new client.ErrorInfo("Map key should be string", 40003, 400);
    }
    if (value === null || typeof value !== "string" && typeof value !== "number" && typeof value !== "boolean" && typeof value !== "object") {
      throw new client.ErrorInfo("Map value data type is unsupported", 40013, 400);
    }
  }
  /**
   * Returns the value associated with the specified key in the underlying Map object.
   *
   * - If this map object is tombstoned (deleted), `undefined` is returned.
   * - If no entry is associated with the specified key, `undefined` is returned.
   * - If map entry is tombstoned (deleted), `undefined` is returned.
   * - If the value associated with the provided key is an objectId string of another LiveObject, a reference to that LiveObject
   * is returned, provided it exists in the local pool and is not tombstoned. Otherwise, `undefined` is returned.
   * - If the value is not an objectId, then that value is returned.
   *
   * @spec RTLM5, RTLM5a
   */
  // force the key to be of type string as we only allow strings as key in a map
  get(key) {
    if (this.isTombstoned()) {
      return void 0;
    }
    const element = this._dataRef.data.get(key);
    if (element === void 0) {
      return void 0;
    }
    if (element.tombstone === true) {
      return void 0;
    }
    return this._getResolvedValueFromObjectData(element.data);
  }
  size() {
    let size = 0;
    for (const value of this._dataRef.data.values()) {
      if (this._isMapEntryTombstoned(value)) {
        continue;
      }
      size++;
    }
    return size;
  }
  *entries() {
    for (const [key, entry] of this._dataRef.data.entries()) {
      if (this._isMapEntryTombstoned(entry)) {
        continue;
      }
      const value = this._getResolvedValueFromObjectData(entry.data);
      yield [key, value];
    }
  }
  *keys() {
    for (const [key] of this.entries()) {
      yield key;
    }
  }
  *values() {
    for (const [_, value] of this.entries()) {
      yield value;
    }
  }
  /**
   * Send a MAP_SET operation to the realtime system to set a key on this LiveMap object to a specified value.
   *
   * This does not modify the underlying data of this LiveMap object. Instead, the change will be applied when
   * the published MAP_SET operation is echoed back to the client and applied to the object following the regular
   * operation application procedure.
   *
   * @returns A promise which resolves upon receiving the ACK message for the published operation message.
   */
  async set(key, value) {
    const msgs = await _LiveMap.createMapSetMessage(this._realtimeObject, this.getObjectId(), key, value);
    return this._realtimeObject.publish(msgs);
  }
  /**
   * Send a MAP_REMOVE operation to the realtime system to tombstone a key on this LiveMap object.
   *
   * This does not modify the underlying data of this LiveMap object. Instead, the change will be applied when
   * the published MAP_REMOVE operation is echoed back to the client and applied to the object following the regular
   * operation application procedure.
   *
   * @returns A promise which resolves upon receiving the ACK message for the published operation message.
   */
  async remove(key) {
    const msg = _LiveMap.createMapRemoveMessage(this._realtimeObject, this.getObjectId(), key);
    return this._realtimeObject.publish([msg]);
  }
  /**
   * @internal
   */
  applyOperation(op, msg) {
    var _a;
    if (op.objectId !== this.getObjectId()) {
      throw new this._client.ErrorInfo(
        `Cannot apply object operation with objectId=${op.objectId}, to this LiveMap with objectId=${this.getObjectId()}`,
        92e3,
        500
      );
    }
    const opSerial = msg.serial;
    const opSiteCode = msg.siteCode;
    if (!this._canApplyOperation(opSerial, opSiteCode)) {
      this._client.Logger.logAction(
        this._client.logger,
        this._client.Logger.LOG_MICRO,
        "LiveMap.applyOperation()",
        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${(_a = this._siteTimeserials[opSiteCode]) == null ? void 0 : _a.toString()}; objectId=${this.getObjectId()}`
      );
      return;
    }
    this._siteTimeserials[opSiteCode] = opSerial;
    if (this.isTombstoned()) {
      return;
    }
    let update;
    switch (op.action) {
      case 0 /* MAP_CREATE */:
        update = this._applyMapCreate(op, msg);
        break;
      case 1 /* MAP_SET */:
        if (this._client.Utils.isNil(op.mapOp)) {
          this._throwNoPayloadError(op);
          return;
        } else {
          update = this._applyMapSet(op.mapOp, opSerial, msg);
        }
        break;
      case 2 /* MAP_REMOVE */:
        if (this._client.Utils.isNil(op.mapOp)) {
          this._throwNoPayloadError(op);
          return;
        } else {
          update = this._applyMapRemove(op.mapOp, opSerial, msg.serialTimestamp, msg);
        }
        break;
      case 5 /* OBJECT_DELETE */:
        update = this._applyObjectDelete(msg);
        break;
      default:
        throw new this._client.ErrorInfo(
          `Invalid ${op.action} op for LiveMap objectId=${this.getObjectId()}`,
          92e3,
          500
        );
    }
    this.notifyUpdated(update);
  }
  /**
   * @internal
   * @spec RTLM6
   */
  overrideWithObjectState(objectMessage) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const objectState = objectMessage.object;
    if (objectState == null) {
      throw new this._client.ErrorInfo(`Missing object state; LiveMap objectId=${this.getObjectId()}`, 92e3, 500);
    }
    if (objectState.objectId !== this.getObjectId()) {
      throw new this._client.ErrorInfo(
        `Invalid object state: object state objectId=${objectState.objectId}; LiveMap objectId=${this.getObjectId()}`,
        92e3,
        500
      );
    }
    if (((_a = objectState.map) == null ? void 0 : _a.semantics) !== this._semantics) {
      throw new this._client.ErrorInfo(
        `Invalid object state: object state map semantics=${(_b = objectState.map) == null ? void 0 : _b.semantics}; LiveMap semantics=${this._semantics}`,
        92e3,
        500
      );
    }
    if (!this._client.Utils.isNil(objectState.createOp)) {
      if (objectState.createOp.objectId !== this.getObjectId()) {
        throw new this._client.ErrorInfo(
          `Invalid object state: object state createOp objectId=${(_c = objectState.createOp) == null ? void 0 : _c.objectId}; LiveMap objectId=${this.getObjectId()}`,
          92e3,
          500
        );
      }
      if (objectState.createOp.action !== 0 /* MAP_CREATE */) {
        throw new this._client.ErrorInfo(
          `Invalid object state: object state createOp action=${(_d = objectState.createOp) == null ? void 0 : _d.action}; LiveMap objectId=${this.getObjectId()}`,
          92e3,
          500
        );
      }
      if (((_e = objectState.createOp.map) == null ? void 0 : _e.semantics) !== this._semantics) {
        throw new this._client.ErrorInfo(
          `Invalid object state: object state createOp map semantics=${(_f = objectState.createOp.map) == null ? void 0 : _f.semantics}; LiveMap semantics=${this._semantics}`,
          92e3,
          500
        );
      }
    }
    this._siteTimeserials = (_g = objectState.siteTimeserials) != null ? _g : {};
    if (this.isTombstoned()) {
      return { noop: true };
    }
    const previousDataRef = this._dataRef;
    let update;
    if (objectState.tombstone) {
      update = this.tombstone(objectMessage);
    } else {
      this._createOperationIsMerged = false;
      this._dataRef = this._liveMapDataFromMapEntries((_i = (_h = objectState.map) == null ? void 0 : _h.entries) != null ? _i : {});
      if (!this._client.Utils.isNil(objectState.createOp)) {
        this._mergeInitialDataFromCreateOperation(objectState.createOp, objectMessage);
      }
      update = this._updateFromDataDiff(previousDataRef, this._dataRef);
      update.objectMessage = objectMessage;
    }
    this._updateParentReferencesFromUpdate(update, previousDataRef);
    return update;
  }
  /**
   * @internal
   */
  onGCInterval() {
    const keysToDelete = [];
    for (const [key, value] of this._dataRef.data.entries()) {
      if (value.tombstone === true && Date.now() - value.tombstonedAt >= this._realtimeObject.gcGracePeriod) {
        keysToDelete.push(key);
      }
    }
    keysToDelete.forEach((x) => this._dataRef.data.delete(x));
  }
  /**
   * Override clearData to handle parent reference cleanup when this LiveMap is tombstoned.
   *
   * @internal
   */
  clearData() {
    for (const [key, entry] of this._dataRef.data.entries()) {
      if (entry.data && "objectId" in entry.data) {
        const referencedObject = this._realtimeObject.getPool().get(entry.data.objectId);
        if (referencedObject) {
          referencedObject.removeParentReference(this, key);
        }
      }
    }
    return super.clearData();
  }
  /**
   * Returns an in-memory JavaScript object representation of this LiveMap.
   * LiveMap values are recursively compacted using their own compact methods.
   * Compacted LiveMaps are memoized to handle cyclic references (returned as in-memory pointers).
   *
   * Use compactJson() for a JSON-serializable representation.
   *
   * @internal
   */
  compact(visitedObjects) {
    const visited = visitedObjects != null ? visitedObjects : /* @__PURE__ */ new Map();
    const result = {};
    visited.set(this.getObjectId(), result);
    for (const [key, value] of this.entries()) {
      if (value instanceof _LiveMap) {
        if (visited.has(value.getObjectId())) {
          result[key] = visited.get(value.getObjectId());
        } else {
          result[key] = value.compact(visited);
        }
        continue;
      }
      if (value instanceof LiveCounter) {
        result[key] = value.value();
        continue;
      }
      result[key] = value;
    }
    return result;
  }
  /**
   * Returns a JSON-serializable representation of this LiveMap.
   * LiveMap values are recursively compacted using their own compactJson methods.
   * Cyclic references are represented as `{ objectId: string }` instead of in-memory pointers.
   * Buffers are converted to base64 strings.
   *
   * Use compact() for an in-memory representation.
   *
   * @internal
   */
  compactJson(visitedObjectIds) {
    const visited = visitedObjectIds != null ? visitedObjectIds : /* @__PURE__ */ new Set();
    const result = {};
    visited.add(this.getObjectId());
    for (const [key, value] of this.entries()) {
      if (value instanceof _LiveMap) {
        if (visited.has(value.getObjectId())) {
          result[key] = { objectId: value.getObjectId() };
        } else {
          result[key] = value.compactJson(visited);
        }
        continue;
      }
      if (value instanceof LiveCounter) {
        result[key] = value.value();
        continue;
      }
      if (this._client.Platform.BufferUtils.isBuffer(value)) {
        result[key] = this._client.Platform.BufferUtils.base64Encode(value);
        continue;
      }
      result[key] = value;
    }
    return result;
  }
  /** @spec RTLM4 */
  _getZeroValueData() {
    return { data: /* @__PURE__ */ new Map() };
  }
  _updateFromDataDiff(prevDataRef, newDataRef) {
    const update = { update: {}, _type: "LiveMapUpdate" };
    for (const [key, currentEntry] of prevDataRef.data.entries()) {
      const typedKey = key;
      if (currentEntry.tombstone === false && !newDataRef.data.has(typedKey)) {
        update.update[typedKey] = "removed";
      }
    }
    for (const [key, newEntry] of newDataRef.data.entries()) {
      const typedKey = key;
      if (!prevDataRef.data.has(typedKey)) {
        if (newEntry.tombstone === false) {
          update.update[typedKey] = "updated";
          continue;
        }
        if (newEntry.tombstone === true) {
          continue;
        }
      }
      const currentEntry = prevDataRef.data.get(typedKey);
      if (currentEntry.tombstone === true && newEntry.tombstone === false) {
        update.update[typedKey] = "updated";
        continue;
      }
      if (currentEntry.tombstone === false && newEntry.tombstone === true) {
        update.update[typedKey] = "removed";
        continue;
      }
      if (currentEntry.tombstone === true && newEntry.tombstone === true) {
        continue;
      }
      const valueChanged = !dequal(currentEntry.data, newEntry.data);
      if (valueChanged) {
        update.update[typedKey] = "updated";
        continue;
      }
    }
    return update;
  }
  _mergeInitialDataFromCreateOperation(objectOperation, msg) {
    var _a;
    if (this._client.Utils.isNil(objectOperation.map)) {
      return { update: {}, objectMessage: msg, _type: "LiveMapUpdate" };
    }
    const aggregatedUpdate = {
      update: {},
      objectMessage: msg,
      _type: "LiveMapUpdate"
    };
    Object.entries((_a = objectOperation.map.entries) != null ? _a : {}).forEach(([key, entry]) => {
      const opSerial = entry.timeserial;
      let update;
      if (entry.tombstone === true) {
        update = this._applyMapRemove({ key }, opSerial, entry.serialTimestamp, msg);
      } else {
        update = this._applyMapSet({ key, data: entry.data }, opSerial, msg);
      }
      if (update.noop) {
        return;
      }
      Object.assign(aggregatedUpdate.update, update.update);
    });
    this._createOperationIsMerged = true;
    return aggregatedUpdate;
  }
  _throwNoPayloadError(op) {
    throw new this._client.ErrorInfo(
      `No payload found for ${op.action} op for LiveMap objectId=${this.getObjectId()}`,
      92e3,
      500
    );
  }
  _applyMapCreate(op, msg) {
    var _a, _b;
    if (this._createOperationIsMerged) {
      this._client.Logger.logAction(
        this._client.logger,
        this._client.Logger.LOG_MICRO,
        "LiveMap._applyMapCreate()",
        `skipping applying MAP_CREATE op on a map instance as it was already applied before; objectId=${this.getObjectId()}`
      );
      return { noop: true };
    }
    if (this._semantics !== ((_a = op.map) == null ? void 0 : _a.semantics)) {
      throw new this._client.ErrorInfo(
        `Cannot apply MAP_CREATE op on LiveMap objectId=${this.getObjectId()}; map's semantics=${this._semantics}, but op expected ${(_b = op.map) == null ? void 0 : _b.semantics}`,
        92e3,
        500
      );
    }
    return this._mergeInitialDataFromCreateOperation(op, msg);
  }
  /** @spec RTLM7 */
  _applyMapSet(op, opSerial, msg) {
    var _a;
    const { ErrorInfo, Utils } = this._client;
    const existingEntry = this._dataRef.data.get(op.key);
    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {
      this._client.Logger.logAction(
        this._client.logger,
        this._client.Logger.LOG_MICRO,
        "LiveMap._applyMapSet()",
        `skipping update for key="${op.key}": op serial ${opSerial == null ? void 0 : opSerial.toString()} <= entry serial ${(_a = existingEntry.timeserial) == null ? void 0 : _a.toString()}; objectId=${this.getObjectId()}`
      );
      return { noop: true };
    }
    if (Utils.isNil(op.data) || Utils.isNil(op.data.objectId) && Utils.isNil(op.data.value)) {
      throw new ErrorInfo(
        `Invalid object data for MAP_SET op on objectId=${this.getObjectId()} on key="${op.key}"`,
        92e3,
        500
      );
    }
    let liveData;
    if (!Utils.isNil(op.data.objectId)) {
      liveData = { objectId: op.data.objectId };
      this._realtimeObject.getPool().createZeroValueObjectIfNotExists(op.data.objectId);
    } else {
      liveData = { value: op.data.value };
    }
    if (existingEntry) {
      if (existingEntry.data && "objectId" in existingEntry.data) {
        const oldReferencedObject = this._realtimeObject.getPool().get(existingEntry.data.objectId);
        if (oldReferencedObject) {
          oldReferencedObject.removeParentReference(this, op.key);
        }
      }
      existingEntry.tombstone = false;
      existingEntry.tombstonedAt = void 0;
      existingEntry.timeserial = opSerial;
      existingEntry.data = liveData;
    } else {
      const newEntry = {
        tombstone: false,
        // RTLM7b2
        tombstonedAt: void 0,
        timeserial: opSerial,
        data: liveData
      };
      this._dataRef.data.set(op.key, newEntry);
    }
    if ("objectId" in liveData) {
      const newReferencedObject = this._realtimeObject.getPool().get(liveData.objectId);
      if (newReferencedObject) {
        newReferencedObject.addParentReference(this, op.key);
      }
    }
    const update = {
      update: {},
      objectMessage: msg,
      _type: "LiveMapUpdate"
    };
    const typedKey = op.key;
    update.update[typedKey] = "updated";
    return update;
  }
  /** @spec RTLM8 */
  _applyMapRemove(op, opSerial, opTimestamp, msg) {
    var _a;
    const existingEntry = this._dataRef.data.get(op.key);
    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {
      this._client.Logger.logAction(
        this._client.logger,
        this._client.Logger.LOG_MICRO,
        "LiveMap._applyMapRemove()",
        `skipping remove for key="${op.key}": op serial ${opSerial == null ? void 0 : opSerial.toString()} <= entry serial ${(_a = existingEntry.timeserial) == null ? void 0 : _a.toString()}; objectId=${this.getObjectId()}`
      );
      return { noop: true };
    }
    let tombstonedAt;
    if (opTimestamp != null) {
      tombstonedAt = opTimestamp;
    } else {
      this._client.Logger.logAction(
        this._client.logger,
        this._client.Logger.LOG_MINOR,
        "LiveMap._applyMapRemove()",
        `map key has been removed but no "serialTimestamp" found in the message, using local clock instead; key="${op.key}", objectId=${this.getObjectId()}`
      );
      tombstonedAt = Date.now();
    }
    if (existingEntry) {
      if (existingEntry.data && "objectId" in existingEntry.data) {
        const referencedObject = this._realtimeObject.getPool().get(existingEntry.data.objectId);
        if (referencedObject) {
          referencedObject.removeParentReference(this, op.key);
        }
      }
      existingEntry.tombstone = true;
      existingEntry.tombstonedAt = tombstonedAt;
      existingEntry.timeserial = opSerial;
      existingEntry.data = void 0;
    } else {
      const newEntry = {
        tombstone: true,
        // RTLM8b2
        tombstonedAt,
        timeserial: opSerial,
        data: void 0
      };
      this._dataRef.data.set(op.key, newEntry);
    }
    const update = {
      update: {},
      objectMessage: msg,
      _type: "LiveMapUpdate"
    };
    const typedKey = op.key;
    update.update[typedKey] = "removed";
    return update;
  }
  /**
   * Returns true if the serials of the given operation and entry indicate that
   * the operation should be applied to the entry, following the CRDT semantics of this LiveMap.
   * @spec RTLM9
   */
  _canApplyMapOperation(mapEntrySerial, opSerial) {
    if (!mapEntrySerial && !opSerial) {
      return false;
    }
    if (!mapEntrySerial) {
      return true;
    }
    if (!opSerial) {
      return false;
    }
    return opSerial > mapEntrySerial;
  }
  _liveMapDataFromMapEntries(entries) {
    const liveMapData = {
      data: /* @__PURE__ */ new Map()
    };
    Object.entries(entries != null ? entries : {}).forEach(([key, entry]) => {
      let liveData = void 0;
      if (!this._client.Utils.isNil(entry.data)) {
        if (!this._client.Utils.isNil(entry.data.objectId)) {
          liveData = { objectId: entry.data.objectId };
        } else {
          liveData = { value: entry.data.value };
        }
      }
      let tombstonedAt;
      if (entry.tombstone === true) {
        if (entry.serialTimestamp != null) {
          tombstonedAt = entry.serialTimestamp;
        } else {
          this._client.Logger.logAction(
            this._client.logger,
            this._client.Logger.LOG_MINOR,
            "LiveMap._liveMapDataFromMapEntries()",
            `map key is removed but no "serialTimestamp" found, using local clock instead; key="${key}", objectId=${this.getObjectId()}`
          );
          tombstonedAt = Date.now();
        }
      }
      const liveDataEntry = {
        timeserial: entry.timeserial,
        data: liveData,
        // consider object as tombstoned only if we received an explicit flag stating that. otherwise it exists
        tombstone: entry.tombstone === true,
        tombstonedAt
      };
      liveMapData.data.set(key, liveDataEntry);
    });
    return liveMapData;
  }
  /**
   * Returns value as is if object data stores a primitive type, or a reference to another LiveObject from the pool if it stores an objectId.
   */
  _getResolvedValueFromObjectData(data) {
    const primitiveValue = data.value;
    if (primitiveValue != null) {
      return primitiveValue;
    }
    const objectId = data.objectId;
    const refObject = this._realtimeObject.getPool().get(objectId);
    if (!refObject) {
      return void 0;
    }
    if (refObject.isTombstoned()) {
      return void 0;
    }
    return refObject;
  }
  _isMapEntryTombstoned(entry) {
    if (entry.tombstone === true) {
      return true;
    }
    const data = entry.data;
    if ("objectId" in data) {
      const refObject = this._realtimeObject.getPool().get(data.objectId);
      if (refObject == null ? void 0 : refObject.isTombstoned()) {
        return true;
      }
    }
    return false;
  }
  /**
   * Update parent references based on the calculated update diff.
   */
  _updateParentReferencesFromUpdate(update, previousDataRef) {
    for (const [key, changeType] of Object.entries(update.update)) {
      if (changeType === "removed") {
        const previousEntry = previousDataRef.data.get(key);
        if ((previousEntry == null ? void 0 : previousEntry.data) && "objectId" in previousEntry.data) {
          const oldReferencedObject = this._realtimeObject.getPool().get(previousEntry.data.objectId);
          if (oldReferencedObject) {
            oldReferencedObject.removeParentReference(this, key);
          }
        }
      }
      if (changeType === "updated") {
        const previousEntry = previousDataRef.data.get(key);
        const newEntry = this._dataRef.data.get(key);
        if ((previousEntry == null ? void 0 : previousEntry.data) && "objectId" in previousEntry.data) {
          const oldReferencedObject = this._realtimeObject.getPool().get(previousEntry.data.objectId);
          if (oldReferencedObject) {
            oldReferencedObject.removeParentReference(this, key);
          }
        }
        if ((newEntry == null ? void 0 : newEntry.data) && "objectId" in newEntry.data) {
          const newReferencedObject = this._realtimeObject.getPool().get(newEntry.data.objectId);
          if (newReferencedObject) {
            newReferencedObject.addParentReference(this, key);
          }
        }
      }
    }
  }
};

// src/plugins/liveobjects/livemapvaluetype.ts
var LiveMapValueType = class _LiveMapValueType {
  constructor(entries) {
    // type-only, unique symbol to satisfy branded interfaces, no JS emitted
    this._livetype = "LiveMap";
    this._entries = entries;
    Object.freeze(this);
  }
  static create(initialEntries) {
    return new _LiveMapValueType(initialEntries);
  }
  /**
   * @internal
   */
  static instanceof(value) {
    return typeof value === "object" && value !== null && value._livetype === "LiveMap";
  }
  /**
   * @internal
   */
  static async createMapCreateMessage(realtimeObject, value) {
    const client = realtimeObject.getClient();
    const entries = value._entries;
    if (entries !== void 0 && (entries === null || typeof entries !== "object")) {
      throw new client.ErrorInfo("Map entries should be a key-value object", 40003, 400);
    }
    Object.entries(entries != null ? entries : {}).forEach(([key, value2]) => LiveMap.validateKeyValue(realtimeObject, key, value2));
    const { initialValueOperation, nestedObjectsCreateMsgs } = await _LiveMapValueType._createInitialValueOperation(
      realtimeObject,
      entries
    );
    const initialValueJSONString = createInitialValueJSONString(initialValueOperation, client);
    const nonce = client.Utils.cheapRandStr();
    const msTimestamp = await client.getTimestamp(true);
    const objectId = ObjectId.fromInitialValue(
      client.Platform,
      "map",
      initialValueJSONString,
      nonce,
      msTimestamp
    ).toString();
    const mapCreateMsg = ObjectMessage.fromValues(
      {
        operation: __spreadProps(__spreadValues({}, initialValueOperation), {
          action: 0 /* MAP_CREATE */,
          objectId,
          nonce,
          initialValue: initialValueJSONString
        })
      },
      client.Utils,
      client.MessageEncoding
    );
    return {
      mapCreateMsg,
      nestedObjectsCreateMsgs
    };
  }
  static async _createInitialValueOperation(realtimeObject, entries) {
    var _a, _b;
    const mapEntries = {};
    const nestedObjectsCreateMsgs = [];
    for (const [key, value] of Object.entries(entries != null ? entries : {})) {
      let objectData;
      if (_LiveMapValueType.instanceof(value)) {
        const { mapCreateMsg, nestedObjectsCreateMsgs: childNestedObjs } = await _LiveMapValueType.createMapCreateMessage(realtimeObject, value);
        nestedObjectsCreateMsgs.push(...childNestedObjs, mapCreateMsg);
        const typedObjectData = { objectId: (_a = mapCreateMsg.operation) == null ? void 0 : _a.objectId };
        objectData = typedObjectData;
      } else if (LiveCounterValueType.instanceof(value)) {
        const counterCreateMsg = await LiveCounterValueType.createCounterCreateMessage(realtimeObject, value);
        nestedObjectsCreateMsgs.push(counterCreateMsg);
        const typedObjectData = { objectId: (_b = counterCreateMsg.operation) == null ? void 0 : _b.objectId };
        objectData = typedObjectData;
      } else {
        const typedObjectData = { value };
        objectData = typedObjectData;
      }
      mapEntries[key] = {
        data: objectData
      };
    }
    const initialValueOperation = {
      map: {
        semantics: 0 /* LWW */,
        entries: mapEntries
      }
    };
    return {
      initialValueOperation,
      nestedObjectsCreateMsgs
    };
  }
};

// src/plugins/liveobjects/defaults.ts
var DEFAULTS = {
  gcInterval: 1e3 * 60 * 5,
  // 5 minutes
  /**
   * The SDK will attempt to use the `objectsGCGracePeriod` value provided by the server in the `connectionDetails` object of the `CONNECTED` event.
   * If the server does not provide this value, the SDK will fall back to this default value.
   *
   * Must be > 2 minutes to ensure we keep tombstones long enough to avoid the possibility of receiving an operation
   * with an earlier serial that would not have been applied if the tombstone still existed.
   *
   * Applies both for map entries tombstones and object tombstones.
   */
  gcGracePeriod: 1e3 * 60 * 60 * 24
  // 24 hours
};

// src/plugins/liveobjects/objectspool.ts
var ObjectsPool = class {
  constructor(_realtimeObject) {
    this._realtimeObject = _realtimeObject;
    var _a, _b;
    this._client = this._realtimeObject.getClient();
    this._pool = this._createInitialPool();
    this._gcInterval = setInterval(() => {
      this._onGCInterval();
    }, DEFAULTS.gcInterval);
    (_b = (_a = this._gcInterval).unref) == null ? void 0 : _b.call(_a);
  }
  get(objectId) {
    return this._pool.get(objectId);
  }
  getRoot() {
    return this._pool.get(ROOT_OBJECT_ID);
  }
  /**
   * Returns all objects in the pool as an iterable.
   * Used internally for operations that need to process all objects.
   */
  getAll() {
    return this._pool.values();
  }
  /**
   * Deletes objects from the pool for which object ids are not found in the provided array of ids.
   */
  deleteExtraObjectIds(objectIds) {
    const poolObjectIds = [...this._pool.keys()];
    const extraObjectIds = poolObjectIds.filter((x) => !objectIds.includes(x));
    extraObjectIds.forEach((x) => this._pool.delete(x));
  }
  set(objectId, liveObject) {
    this._pool.set(objectId, liveObject);
  }
  /**
   * Removes all objects but root from the pool and clears the data for root.
   * Does not create a new root object, so the reference to the root object remains the same.
   */
  resetToInitialPool(emitUpdateEvents) {
    const root = this.getRoot();
    this._pool.clear();
    this._pool.set(root.getObjectId(), root);
    this.clearObjectsData(emitUpdateEvents);
  }
  /**
   * Clears the data stored for all objects in the pool.
   */
  clearObjectsData(emitUpdateEvents) {
    for (const object of this._pool.values()) {
      const update = object.clearData();
      if (emitUpdateEvents) {
        object.notifyUpdated(update);
      }
    }
  }
  /** @spec RTO6 */
  createZeroValueObjectIfNotExists(objectId) {
    const existingObject = this.get(objectId);
    if (existingObject) {
      return existingObject;
    }
    const parsedObjectId = ObjectId.fromString(this._client, objectId);
    let zeroValueObject;
    switch (parsedObjectId.type) {
      case "map": {
        zeroValueObject = LiveMap.zeroValue(this._realtimeObject, objectId);
        break;
      }
      case "counter":
        zeroValueObject = LiveCounter.zeroValue(this._realtimeObject, objectId);
        break;
    }
    this.set(objectId, zeroValueObject);
    return zeroValueObject;
  }
  _createInitialPool() {
    const pool = /* @__PURE__ */ new Map();
    const root = LiveMap.zeroValue(this._realtimeObject, ROOT_OBJECT_ID);
    pool.set(root.getObjectId(), root);
    return pool;
  }
  _onGCInterval() {
    const toDelete = [];
    for (const [objectId, obj] of this._pool.entries()) {
      if (obj.isTombstoned() && Date.now() - obj.tombstonedAt() >= this._realtimeObject.gcGracePeriod) {
        toDelete.push(objectId);
        continue;
      }
      obj.onGCInterval();
    }
    toDelete.forEach((x) => this._pool.delete(x));
  }
};

// src/plugins/liveobjects/batchcontext.ts
var DefaultBatchContext = class {
  constructor(_realtimeObject, _instance, _rootContext) {
    this._realtimeObject = _realtimeObject;
    this._instance = _instance;
    this._rootContext = _rootContext;
    this._client = this._realtimeObject.getClient();
  }
  get id() {
    this._throwIfClosed();
    return this._instance.id;
  }
  get(key) {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    this._throwIfClosed();
    const instance = this._instance.get(key);
    if (!instance) {
      return void 0;
    }
    return this._rootContext.wrapInstance(instance);
  }
  value() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    this._throwIfClosed();
    return this._instance.value();
  }
  compact() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    this._throwIfClosed();
    return this._instance.compact();
  }
  compactJson() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    this._throwIfClosed();
    return this._instance.compactJson();
  }
  *entries() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    this._throwIfClosed();
    for (const [key, value] of this._instance.entries()) {
      const ctx = this._rootContext.wrapInstance(value);
      yield [key, ctx];
    }
  }
  *keys() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    this._throwIfClosed();
    yield* __yieldStar(this._instance.keys());
  }
  *values() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    this._throwIfClosed();
    for (const [_, value] of this.entries()) {
      yield value;
    }
  }
  size() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    this._throwIfClosed();
    return this._instance.size();
  }
  set(key, value) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    this._throwIfClosed();
    if (!this._instance.isLiveMap()) {
      throw new this._client.ErrorInfo("Cannot set a key on a non-LiveMap instance", 92007, 400);
    }
    this._rootContext.queueMessages(
      async () => LiveMap.createMapSetMessage(this._realtimeObject, this._instance.id, key, value)
    );
  }
  remove(key) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    this._throwIfClosed();
    if (!this._instance.isLiveMap()) {
      throw new this._client.ErrorInfo("Cannot remove a key from a non-LiveMap instance", 92007, 400);
    }
    this._rootContext.queueMessages(async () => [
      LiveMap.createMapRemoveMessage(this._realtimeObject, this._instance.id, key)
    ]);
  }
  increment(amount) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    this._throwIfClosed();
    if (!this._instance.isLiveCounter()) {
      throw new this._client.ErrorInfo("Cannot increment a non-LiveCounter instance", 92007, 400);
    }
    this._rootContext.queueMessages(async () => [
      LiveCounter.createCounterIncMessage(this._realtimeObject, this._instance.id, amount != null ? amount : 1)
    ]);
  }
  decrement(amount) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    this._throwIfClosed();
    if (!this._instance.isLiveCounter()) {
      throw new this._client.ErrorInfo("Cannot decrement a non-LiveCounter instance", 92007, 400);
    }
    this.increment(-(amount != null ? amount : 1));
  }
  _throwIfClosed() {
    if (this._rootContext.isClosed()) {
      throw new this._client.ErrorInfo("Batch is closed", 4e4, 400);
    }
  }
};

// src/plugins/liveobjects/rootbatchcontext.ts
var RootBatchContext = class extends DefaultBatchContext {
  constructor(realtimeObject, instance) {
    super(realtimeObject, instance, null);
    /** Maps object ids to the corresponding batch context wrappers  */
    this._wrappedInstances = /* @__PURE__ */ new Map();
    /**
     * Some object messages require asynchronous I/O during construction
     * (for example, generating an objectId for nested value types).
     * Therefore, messages cannot be constructed immediately during
     * synchronous method calls from batch context methods.
     * Instead, message constructors are queued and executed on flush.
     */
    this._queuedMessageConstructors = [];
    this._isClosed = false;
    this._rootContext = this;
  }
  /** @internal */
  async flush() {
    try {
      this.close();
      const msgs = (await Promise.all(this._queuedMessageConstructors.map((x) => x()))).flat();
      if (msgs.length > 0) {
        await this._realtimeObject.publish(msgs);
      }
    } finally {
      this._wrappedInstances.clear();
      this._queuedMessageConstructors = [];
    }
  }
  /** @internal */
  close() {
    this._isClosed = true;
  }
  /** @internal */
  isClosed() {
    return this._isClosed;
  }
  /** @internal */
  wrapInstance(instance) {
    const objectId = instance.id;
    if (objectId) {
      if (this._wrappedInstances.has(objectId)) {
        return this._wrappedInstances.get(objectId);
      }
      let wrappedInstance = new DefaultBatchContext(this._realtimeObject, instance, this);
      this._wrappedInstances.set(objectId, wrappedInstance);
      return wrappedInstance;
    }
    return new DefaultBatchContext(this._realtimeObject, instance, this);
  }
  /** @internal */
  queueMessages(msgCtors) {
    this._queuedMessageConstructors.push(msgCtors);
  }
};

// src/plugins/liveobjects/instance.ts
var DefaultInstance = class _DefaultInstance {
  constructor(_realtimeObject, _value) {
    this._realtimeObject = _realtimeObject;
    this._value = _value;
    this._client = this._realtimeObject.getClient();
  }
  get id() {
    if (!(this._value instanceof LiveObject)) {
      return void 0;
    }
    return this._value.getObjectId();
  }
  /**
   * Returns an in-memory JavaScript object representation of this instance.
   * Buffers are returned as-is.
   * For primitive types, this is an alias for calling value().
   *
   * Use compactJson() for a JSON-serializable representation.
   */
  compact() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    if (this._value instanceof LiveMap) {
      return this._value.compact();
    }
    return this.value();
  }
  /**
   * Returns a JSON-serializable representation of this instance.
   * Buffers are converted to base64 strings.
   *
   * Use compact() for an in-memory representation.
   */
  compactJson() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    if (this._value instanceof LiveMap) {
      return this._value.compactJson();
    }
    const value = this.value();
    if (this._client.Platform.BufferUtils.isBuffer(value)) {
      return this._client.Platform.BufferUtils.base64Encode(value);
    }
    return value;
  }
  get(key) {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    if (!(this._value instanceof LiveMap)) {
      return void 0;
    }
    if (typeof key !== "string") {
      throw new this._client.ErrorInfo(`Key must be a string: ${key}`, 40003, 400);
    }
    const value = this._value.get(key);
    if (value === void 0) {
      return void 0;
    }
    return new _DefaultInstance(this._realtimeObject, value);
  }
  value() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    if (this._value instanceof LiveObject) {
      if (this._value instanceof LiveCounter) {
        return this._value.value();
      }
      return void 0;
    } else if (this._client.Platform.BufferUtils.isBuffer(this._value) || typeof this._value === "string" || typeof this._value === "number" || typeof this._value === "boolean" || typeof this._value === "object" || this._value === null) {
      return this._value;
    } else {
      this._client.Logger.logAction(
        this._client.logger,
        this._client.Logger.LOG_MAJOR,
        "DefaultInstance.value()",
        `unexpected value type for instance, resolving to undefined; value=${this._value}; type=${typeof this._value}`
      );
      return void 0;
    }
  }
  *entries() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    if (!(this._value instanceof LiveMap)) {
      return;
    }
    for (const [key, value] of this._value.entries()) {
      const instance = new _DefaultInstance(this._realtimeObject, value);
      yield [key, instance];
    }
  }
  *keys() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    if (!(this._value instanceof LiveMap)) {
      return;
    }
    yield* __yieldStar(this._value.keys());
  }
  *values() {
    for (const [_, value] of this.entries()) {
      yield value;
    }
  }
  size() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    if (!(this._value instanceof LiveMap)) {
      return void 0;
    }
    return this._value.size();
  }
  set(key, value) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    if (!(this._value instanceof LiveMap)) {
      throw new this._client.ErrorInfo("Cannot set a key on a non-LiveMap instance", 92007, 400);
    }
    return this._value.set(key, value);
  }
  remove(key) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    if (!(this._value instanceof LiveMap)) {
      throw new this._client.ErrorInfo("Cannot remove a key from a non-LiveMap instance", 92007, 400);
    }
    return this._value.remove(key);
  }
  increment(amount) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    if (!(this._value instanceof LiveCounter)) {
      throw new this._client.ErrorInfo("Cannot increment a non-LiveCounter instance", 92007, 400);
    }
    return this._value.increment(amount != null ? amount : 1);
  }
  decrement(amount) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    if (!(this._value instanceof LiveCounter)) {
      throw new this._client.ErrorInfo("Cannot decrement a non-LiveCounter instance", 92007, 400);
    }
    return this._value.decrement(amount != null ? amount : 1);
  }
  subscribe(listener) {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    if (!(this._value instanceof LiveObject)) {
      throw new this._client.ErrorInfo("Cannot subscribe to a non-LiveObject instance", 92007, 400);
    }
    return this._value.subscribe((event) => {
      var _a;
      listener({
        object: this,
        message: (_a = event.message) == null ? void 0 : _a.toUserFacingMessage(this._realtimeObject.getChannel())
      });
    });
  }
  subscribeIterator() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    if (!(this._value instanceof LiveObject)) {
      throw new this._client.ErrorInfo("Cannot subscribe to a non-LiveObject instance", 92007, 400);
    }
    return this._client.Utils.listenerToAsyncIterator((listener) => {
      const { unsubscribe } = this.subscribe(listener);
      return unsubscribe;
    });
  }
  async batch(fn) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    if (!(this._value instanceof LiveObject)) {
      throw new this._client.ErrorInfo("Cannot batch operations on a non-LiveObject instance", 92007, 400);
    }
    const ctx = new RootBatchContext(this._realtimeObject, this);
    try {
      fn(ctx);
      await ctx.flush();
    } finally {
      ctx.close();
    }
  }
  /** @internal */
  isLiveMap() {
    return this._value instanceof LiveMap;
  }
  /** @internal */
  isLiveCounter() {
    return this._value instanceof LiveCounter;
  }
};

// src/plugins/liveobjects/pathobject.ts
var DefaultPathObject = class _DefaultPathObject {
  constructor(_realtimeObject, _root, path, parent) {
    this._realtimeObject = _realtimeObject;
    this._root = _root;
    var _a;
    this._client = this._realtimeObject.getClient();
    this._path = [...(_a = parent == null ? void 0 : parent._path) != null ? _a : [], ...path];
  }
  /**
   * Returns the fully-qualified string path that this PathObject represents.
   * Path segments with dots in them are escaped with a backslash.
   * For example, a path with segments `['a', 'b.c', 'd']` will be represented as `a.b\.c.d`.
   */
  path() {
    return this._escapePath(this._path).join(".");
  }
  /**
   * Returns an in-memory JavaScript object representation of the object at this path.
   * If the path does not resolve to any specific entry, returns `undefined`.
   * Buffers are returned as-is.
   * For primitive types, this is an alias for calling value().
   *
   * Use compactJson() for a JSON-serializable representation.
   */
  compact() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    try {
      const resolved = this._resolvePath(this._path);
      if (resolved instanceof LiveMap) {
        return resolved.compact();
      }
      return this.value();
    } catch (error) {
      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {
        return void 0;
      }
      throw error;
    }
  }
  /**
   * Returns a JSON-serializable representation of the object at this path.
   * If the path does not resolve to any specific entry, returns `undefined`.
   * Buffers are converted to base64 strings.
   *
   * Use compact() for an in-memory representation.
   */
  compactJson() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    try {
      const resolved = this._resolvePath(this._path);
      if (resolved instanceof LiveMap) {
        return resolved.compactJson();
      }
      const value = this.value();
      if (this._client.Platform.BufferUtils.isBuffer(value)) {
        return this._client.Platform.BufferUtils.base64Encode(value);
      }
      return value;
    } catch (error) {
      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {
        return void 0;
      }
      throw error;
    }
  }
  /**
   * Navigate to a child path within the collection by obtaining a PathObject for that path.
   * The next path segment in a collection is identified with a string key.
   */
  get(key) {
    if (typeof key !== "string") {
      throw new this._client.ErrorInfo(`Path key must be a string: ${key}`, 40003, 400);
    }
    return new _DefaultPathObject(this._realtimeObject, this._root, [key], this);
  }
  /**
   * Get a PathObject at the specified path relative to this object
   */
  at(path) {
    if (typeof path !== "string") {
      throw new this._client.ErrorInfo(`Path must be a string: ${path}`, 40003, 400);
    }
    const pathAsArray = [];
    let currentSegment = "";
    let escaping = false;
    for (const char of path) {
      if (escaping) {
        if (char !== ".")
          currentSegment += "\\";
        currentSegment += char;
        escaping = false;
        continue;
      }
      if (char === "\\") {
        escaping = true;
        continue;
      }
      if (char === ".") {
        pathAsArray.push(currentSegment);
        currentSegment = "";
        continue;
      }
      currentSegment += char;
    }
    if (escaping) {
      currentSegment += "\\";
    }
    pathAsArray.push(currentSegment);
    return new _DefaultPathObject(this._realtimeObject, this._root, pathAsArray, this);
  }
  /**
   * Get the current value at this path.
   * If the path does not resolve to any specific entry, returns `undefined`.
   */
  value() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    try {
      const resolved = this._resolvePath(this._path);
      if (resolved instanceof LiveObject) {
        if (resolved instanceof LiveCounter) {
          return resolved.value();
        }
        return void 0;
      } else if (this._client.Platform.BufferUtils.isBuffer(resolved) || typeof resolved === "string" || typeof resolved === "number" || typeof resolved === "boolean" || typeof resolved === "object" || resolved === null) {
        return resolved;
      } else {
        this._client.Logger.logAction(
          this._client.logger,
          this._client.Logger.LOG_MAJOR,
          "PathObject.value()",
          `unexpected value type at path, resolving to undefined; path=${this._escapePath(this._path).join(".")}`
        );
        return void 0;
      }
    } catch (error) {
      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {
        return void 0;
      }
      throw error;
    }
  }
  instance() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    try {
      return this._resolveInstance();
    } catch (error) {
      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {
        return void 0;
      }
      throw error;
    }
  }
  /**
   * Returns an iterator of [key, value] pairs for LiveMap entries
   */
  *entries() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    try {
      const resolved = this._resolvePath(this._path);
      if (!(resolved instanceof LiveMap)) {
        return;
      }
      for (const [key, _] of resolved.entries()) {
        const value = new _DefaultPathObject(this._realtimeObject, this._root, [key], this);
        yield [key, value];
      }
    } catch (error) {
      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {
        return;
      }
      throw error;
    }
  }
  /**
   * Returns an iterator of keys for LiveMap entries
   */
  *keys() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    try {
      const resolved = this._resolvePath(this._path);
      if (!(resolved instanceof LiveMap)) {
        return;
      }
      yield* __yieldStar(resolved.keys());
    } catch (error) {
      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {
        return;
      }
      throw error;
    }
  }
  /**
   * Returns an iterator of PathObject values for LiveMap entries
   */
  *values() {
    for (const [_, value] of this.entries()) {
      yield value;
    }
  }
  /**
   * Returns the size of the collection at this path
   */
  size() {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    try {
      const resolved = this._resolvePath(this._path);
      if (!(resolved instanceof LiveMap)) {
        return void 0;
      }
      return resolved.size();
    } catch (error) {
      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {
        return void 0;
      }
      throw error;
    }
  }
  set(key, value) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    const resolved = this._resolvePath(this._path);
    if (!(resolved instanceof LiveMap)) {
      throw new this._client.ErrorInfo(
        `Cannot set a key on a non-LiveMap object at path: ${this._escapePath(this._path).join(".")}`,
        92007,
        400
      );
    }
    return resolved.set(key, value);
  }
  remove(key) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    const resolved = this._resolvePath(this._path);
    if (!(resolved instanceof LiveMap)) {
      throw new this._client.ErrorInfo(
        `Cannot remove a key from a non-LiveMap object at path: ${this._escapePath(this._path).join(".")}`,
        92007,
        400
      );
    }
    return resolved.remove(key);
  }
  increment(amount) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    const resolved = this._resolvePath(this._path);
    if (!(resolved instanceof LiveCounter)) {
      throw new this._client.ErrorInfo(
        `Cannot increment a non-LiveCounter object at path: ${this._escapePath(this._path).join(".")}`,
        92007,
        400
      );
    }
    return resolved.increment(amount != null ? amount : 1);
  }
  decrement(amount) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    const resolved = this._resolvePath(this._path);
    if (!(resolved instanceof LiveCounter)) {
      throw new this._client.ErrorInfo(
        `Cannot decrement a non-LiveCounter object at path: ${this._escapePath(this._path).join(".")}`,
        92007,
        400
      );
    }
    return resolved.decrement(amount != null ? amount : 1);
  }
  /**
   * Subscribes to changes to the object (and, by default, its children) or to a primitive value at this path.
   *
   * PathObject subscriptions rely on LiveObject instances to broadcast updates through a subscription
   * registry for the paths they occupy in the object graph. These updates are then routed to the appropriate
   * PathObject subscriptions based on their paths.
   *
   * When the underlying object or primitive value at this path is changed via an update to its parent
   * collection (for example, if a new LiveCounter instance is set at this path, or a key's value is
   * changed in a parent LiveMap), a subscription to this path will receive a separate **non-bubbling**
   * event indicating the change. This event is not propagated to parent path subscriptions, as they will
   * receive their own event for changes made directly to the object at their respective paths.
   *
   * PathObject subscriptions observe nested changes by default. Optional `depth` parameter can be provided
   * to control this behavior. A subscription depth of `1` means that only direct updates to the underlying
   * object - and changes that overwrite the value at this path (via parent object updates) - will trigger events.
   */
  subscribe(listener, options) {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    return this._realtimeObject.getPathObjectSubscriptionRegister().subscribe(this._path, listener, options != null ? options : {});
  }
  subscribeIterator(options) {
    this._realtimeObject.throwIfInvalidAccessApiConfiguration();
    return this._client.Utils.listenerToAsyncIterator((listener) => {
      const { unsubscribe } = this.subscribe(listener, options);
      return unsubscribe;
    });
  }
  async batch(fn) {
    this._realtimeObject.throwIfInvalidWriteApiConfiguration();
    const instance = this._resolveInstance();
    if (!instance) {
      throw new this._client.ErrorInfo(
        `Cannot batch operations on a non-LiveObject at path: ${this._escapePath(this._path).join(".")}`,
        92007,
        400
      );
    }
    const ctx = new RootBatchContext(this._realtimeObject, instance);
    try {
      fn(ctx);
      await ctx.flush();
    } finally {
      ctx.close();
    }
  }
  _resolvePath(path) {
    let current = this._root;
    for (let i = 0; i < path.length; i++) {
      const segment = path[i];
      if (!(current instanceof LiveMap)) {
        throw new this._client.ErrorInfo(
          `Cannot resolve path segment '${segment}' on non-collection type at path: ${this._escapePath(path.slice(0, i)).join(".")}`,
          92005,
          400
        );
      }
      const next = current.get(segment);
      if (next === void 0) {
        throw new this._client.ErrorInfo(
          `Could not resolve value at path: ${this._escapePath(path.slice(0, i + 1)).join(".")}`,
          92005,
          400
        );
      }
      current = next;
    }
    return current;
  }
  _resolveInstance() {
    const value = this._resolvePath(this._path);
    if (value instanceof LiveObject) {
      return new DefaultInstance(this._realtimeObject, value);
    }
    return void 0;
  }
  _escapePath(path) {
    return path.map((x) => x.replace(/\./g, "\\."));
  }
};

// src/plugins/liveobjects/pathobjectsubscriptionregister.ts
var PathObjectSubscriptionRegister = class {
  constructor(_realtimeObject) {
    this._realtimeObject = _realtimeObject;
    this._subscriptions = /* @__PURE__ */ new Map();
    this._nextSubscriptionId = 0;
    this._client = this._realtimeObject.getClient();
  }
  /**
   * Registers a new subscription for the given path.
   *
   * @param path - Array of keys representing the path to subscribe to
   * @param listener - Function to call when matching events occur
   * @param options - Subscription options including depth parameter
   * @returns Unsubscribe function
   */
  subscribe(path, listener, options) {
    if (options == null || typeof options !== "object") {
      throw new this._client.ErrorInfo("Subscription options must be an object", 4e4, 400);
    }
    if (options.depth !== void 0 && options.depth <= 0) {
      throw new this._client.ErrorInfo(
        "Subscription depth must be greater than 0 or undefined for infinite depth",
        40003,
        400
      );
    }
    const subscriptionId = (this._nextSubscriptionId++).toString();
    const entry = {
      listener,
      options,
      path: [...path]
      // Make a copy to avoid external mutations
    };
    this._subscriptions.set(subscriptionId, entry);
    return {
      unsubscribe: () => {
        this._subscriptions.delete(subscriptionId);
      }
    };
  }
  /**
   * Notifies all matching subscriptions about an event that occurred at the specified path(s).
   *
   * @param events - Array of path events to process
   */
  notifyPathEvents(events) {
    for (const event of events) {
      this._processEvent(event);
    }
  }
  /**
   * Processes a single path event and calls all matching subscription listeners.
   */
  _processEvent(event) {
    var _a;
    for (const subscription of this._subscriptions.values()) {
      if (!this._shouldNotifySubscription(subscription, event)) {
        continue;
      }
      try {
        const subscriptionEvent = {
          object: new DefaultPathObject(this._realtimeObject, this._realtimeObject.getPool().getRoot(), event.path),
          message: (_a = event.message) == null ? void 0 : _a.toUserFacingMessage(this._realtimeObject.getChannel())
        };
        subscription.listener(subscriptionEvent);
      } catch (error) {
        this._client.Logger.logAction(
          this._client.logger,
          this._client.Logger.LOG_MINOR,
          "PathObjectSubscriptionRegister._processEvent()",
          `Error in PathObject subscription listener; path=${JSON.stringify(event.path)}, error=${error}`
        );
      }
    }
  }
  /**
   * Determines if a subscription should be notified about an event at the given path.
   * Implements depth-based filtering logic and bubbling control.
   *
   * Depth examples (when event.bubbles is true):
   * - subscription at ["users"] with depth=undefined: matches ["users"], ["users", "emma"], ["users", "emma", "visits"], etc.
   * - subscription at ["users"] with depth=1: matches ["users"] only
   * - subscription at ["users"] with depth=2: matches ["users"], ["users", "emma"] only
   * - subscription at ["users"] with depth=3: matches ["users"], ["users", "emma"], ["users", "emma", "visits"] only
   *
   * Non-bubbling examples (when event.bubbles is false):
   * - Event at ["users", "emma"] with bubbles=false:
   *   - subscription at ["users"]: NOT triggered (no bubbling to parent)
   *   - subscription at ["users", "emma"]: triggered (exact path match)
   *
   * The depth calculation is: eventPath.length - subscriptionPath.length + 1
   * This means:
   * - Same level (["users"] -> ["users"]): 1 - 1 + 1 = 1 (depth=1)
   * - One level deeper (["users"] -> ["users", "emma"]): 2 - 1 + 1 = 2 (depth=2)
   * - Two levels deeper (["users"] -> ["users", "emma", "visits"]): 3 - 1 + 1 = 3 (depth=3)
   */
  _shouldNotifySubscription(subscription, event) {
    const subPath = subscription.path;
    const eventPath = event.path;
    const depth = subscription.options.depth;
    const bubbles = event.bubbles !== false;
    if (!bubbles) {
      return this._pathsAreEqual(eventPath, subPath);
    }
    if (!this._pathStartsWith(eventPath, subPath)) {
      return false;
    }
    if (depth === void 0) {
      return true;
    }
    const relativeDepth = eventPath.length - subPath.length + 1;
    return relativeDepth <= depth;
  }
  /**
   * Checks if eventPath starts with subscriptionPath.
   *
   * @param eventPath - The path where the event occurred
   * @param subscriptionPath - The path that was subscribed to
   * @returns true if eventPath starts with subscriptionPath
   */
  _pathStartsWith(eventPath, subscriptionPath) {
    if (subscriptionPath.length > eventPath.length) {
      return false;
    }
    for (let i = 0; i < subscriptionPath.length; i++) {
      if (eventPath[i] !== subscriptionPath[i]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks if two paths are exactly equal.
   *
   * @param path1 - First path to compare
   * @param path2 - Second path to compare
   * @returns true if paths are exactly equal
   */
  _pathsAreEqual(path1, path2) {
    return this._client.Utils.arrEquals(path1, path2);
  }
};

// src/plugins/liveobjects/syncobjectsdatapool.ts
var SyncObjectsDataPool = class {
  constructor(_realtimeObject) {
    this._realtimeObject = _realtimeObject;
    this._client = this._realtimeObject.getClient();
    this._channel = this._realtimeObject.getChannel();
    this._pool = /* @__PURE__ */ new Map();
  }
  entries() {
    return this._pool.entries();
  }
  size() {
    return this._pool.size;
  }
  isEmpty() {
    return this._pool.size === 0;
  }
  clear() {
    this._pool.clear();
  }
  applyObjectSyncMessages(objectMessages) {
    for (const objectMessage of objectMessages) {
      if (!objectMessage.object) {
        this._client.Logger.logAction(
          this._client.logger,
          this._client.Logger.LOG_MAJOR,
          "SyncObjectsDataPool.applyObjectSyncMessages()",
          `object message is received during OBJECT_SYNC without 'object' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`
        );
        continue;
      }
      const objectState = objectMessage.object;
      if (objectState.counter) {
        this._pool.set(objectState.objectId, this._createLiveCounterDataEntry(objectMessage));
      } else if (objectState.map) {
        this._pool.set(objectState.objectId, this._createLiveMapDataEntry(objectMessage));
      } else {
        this._client.Logger.logAction(
          this._client.logger,
          this._client.Logger.LOG_MAJOR,
          "SyncObjectsDataPool.applyObjectSyncMessages()",
          `received unsupported object state message during OBJECT_SYNC, expected 'counter' or 'map' to be present, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`
        );
      }
    }
  }
  _createLiveCounterDataEntry(objectMessage) {
    const newEntry = {
      objectMessage,
      objectType: "LiveCounter"
    };
    return newEntry;
  }
  _createLiveMapDataEntry(objectMessage) {
    const newEntry = {
      objectMessage,
      objectType: "LiveMap"
    };
    return newEntry;
  }
};

// src/plugins/liveobjects/realtimeobject.ts
var StateToEventsMap = {
  initialized: void 0,
  syncing: "syncing" /* syncing */,
  synced: "synced" /* synced */
};
var RealtimeObject = class {
  constructor(channel) {
    var _a, _b;
    this._channel = channel;
    this._client = channel.client;
    this._state = "initialized" /* initialized */;
    this._eventEmitterInternal = new this._client.EventEmitter(this._client.logger);
    this._eventEmitterPublic = new this._client.EventEmitter(this._client.logger);
    this._objectsPool = new ObjectsPool(this);
    this._syncObjectsDataPool = new SyncObjectsDataPool(this);
    this._bufferedObjectOperations = [];
    this._pathObjectSubscriptionRegister = new PathObjectSubscriptionRegister(this);
    this.gcGracePeriod = (_b = (_a = this._channel.connectionManager.connectionDetails) == null ? void 0 : _a.objectsGCGracePeriod) != null ? _b : DEFAULTS.gcGracePeriod;
    this._channel.connectionManager.on("connectiondetails", (details) => {
      var _a2;
      this.gcGracePeriod = (_a2 = details.objectsGCGracePeriod) != null ? _a2 : DEFAULTS.gcGracePeriod;
    });
  }
  /**
   * When called without a type variable, we return a default root type which is based on globally defined interface for Objects feature.
   * A user can provide an explicit type for the this method to explicitly set the type structure on this particular channel.
   * This is useful when working with multiple channels with different underlying data structure.
   */
  async get() {
    this._throwIfMissingChannelMode("object_subscribe");
    await this._channel.ensureAttached();
    if (this._state !== "synced" /* synced */) {
      await this._eventEmitterInternal.once("synced" /* synced */);
    }
    const pathObject = new DefaultPathObject(this, this._objectsPool.getRoot(), []);
    return pathObject;
  }
  on(event, callback) {
    this._eventEmitterPublic.on(event, callback);
    const off = () => {
      this._eventEmitterPublic.off(event, callback);
    };
    return { off };
  }
  off(event, callback) {
    if (this._client.Utils.isNil(event) && this._client.Utils.isNil(callback)) {
      return;
    }
    this._eventEmitterPublic.off(event, callback);
  }
  /**
   * @internal
   */
  getPool() {
    return this._objectsPool;
  }
  /**
   * @internal
   */
  getChannel() {
    return this._channel;
  }
  /**
   * @internal
   */
  getClient() {
    return this._client;
  }
  /**
   * @internal
   */
  getPathObjectSubscriptionRegister() {
    return this._pathObjectSubscriptionRegister;
  }
  /**
   * @internal
   * @spec RTO5
   */
  handleObjectSyncMessages(objectMessages, syncChannelSerial) {
    const { syncId, syncCursor } = this._parseSyncChannelSerial(syncChannelSerial);
    const newSyncSequence = this._currentSyncId !== syncId;
    if (newSyncSequence) {
      this._startNewSync(syncId, syncCursor);
    }
    this._syncObjectsDataPool.applyObjectSyncMessages(objectMessages);
    if (!syncCursor) {
      this._endSync();
    }
  }
  /**
   * @internal
   */
  handleObjectMessages(objectMessages) {
    if (this._state !== "synced" /* synced */) {
      this._bufferedObjectOperations.push(...objectMessages);
      return;
    }
    this._applyObjectMessages(objectMessages);
  }
  /**
   * @internal
   * @spec RTO4
   */
  onAttached(hasObjects) {
    this._client.Logger.logAction(
      this._client.logger,
      this._client.Logger.LOG_MINOR,
      "RealtimeObject.onAttached()",
      `channel=${this._channel.name}, hasObjects=${hasObjects}`
    );
    this._startNewSync();
    if (!hasObjects) {
      this._objectsPool.resetToInitialPool(true);
      this._syncObjectsDataPool.clear();
      this._endSync();
    }
  }
  /**
   * @internal
   */
  actOnChannelState(state, hasObjects) {
    switch (state) {
      case "attached":
        this.onAttached(hasObjects);
        break;
      case "detached":
      case "failed":
        this._objectsPool.clearObjectsData(false);
        this._syncObjectsDataPool.clear();
        break;
    }
  }
  /**
   * @internal
   */
  async publish(objectMessages) {
    this._channel.throwIfUnpublishableState();
    const encodedMsgs = objectMessages.map((x) => x.encode(this._client));
    const maxMessageSize = this._client.options.maxMessageSize;
    const size = encodedMsgs.reduce((acc, msg) => acc + msg.getMessageSize(), 0);
    if (size > maxMessageSize) {
      throw new this._client.ErrorInfo(
        `Maximum size of object messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,
        40009,
        400
      );
    }
    return this._channel.sendState(encodedMsgs);
  }
  /**
   * @internal
   */
  throwIfInvalidAccessApiConfiguration() {
    this._throwIfMissingChannelMode("object_subscribe");
    this._throwIfInChannelState(["detached", "failed"]);
  }
  /**
   * @internal
   */
  throwIfInvalidWriteApiConfiguration() {
    this._throwIfMissingChannelMode("object_publish");
    this._throwIfInChannelState(["detached", "failed", "suspended"]);
    this._throwIfEchoMessagesDisabled();
  }
  _startNewSync(syncId, syncCursor) {
    this._bufferedObjectOperations = [];
    this._syncObjectsDataPool.clear();
    this._currentSyncId = syncId;
    this._currentSyncCursor = syncCursor;
    this._stateChange("syncing" /* syncing */);
  }
  /** @spec RTO5c */
  _endSync() {
    this._applySync();
    this._applyObjectMessages(this._bufferedObjectOperations);
    this._bufferedObjectOperations = [];
    this._syncObjectsDataPool.clear();
    this._currentSyncId = void 0;
    this._currentSyncCursor = void 0;
    this._stateChange("synced" /* synced */);
  }
  _parseSyncChannelSerial(syncChannelSerial) {
    let match;
    let syncId = void 0;
    let syncCursor = void 0;
    if (syncChannelSerial && (match = syncChannelSerial.match(/^([\w-]+):(.*)$/))) {
      syncId = match[1];
      syncCursor = match[2];
    }
    return {
      syncId,
      syncCursor
    };
  }
  _applySync() {
    if (this._syncObjectsDataPool.isEmpty()) {
      return;
    }
    const receivedObjectIds = /* @__PURE__ */ new Set();
    const existingObjectUpdates = [];
    for (const [objectId, entry] of this._syncObjectsDataPool.entries()) {
      receivedObjectIds.add(objectId);
      const existingObject = this._objectsPool.get(objectId);
      if (existingObject) {
        const update = existingObject.overrideWithObjectState(entry.objectMessage);
        existingObjectUpdates.push({ object: existingObject, update });
        continue;
      }
      let newObject;
      const objectType = entry.objectType;
      switch (objectType) {
        case "LiveCounter":
          newObject = LiveCounter.fromObjectState(this, entry.objectMessage);
          break;
        case "LiveMap":
          newObject = LiveMap.fromObjectState(this, entry.objectMessage);
          break;
        default:
          throw new this._client.ErrorInfo(`Unknown LiveObject type: ${objectType}`, 5e4, 500);
      }
      this._objectsPool.set(objectId, newObject);
    }
    this._objectsPool.deleteExtraObjectIds([...receivedObjectIds]);
    this._rebuildAllParentReferences();
    existingObjectUpdates.forEach(({ object, update }) => object.notifyUpdated(update));
  }
  _applyObjectMessages(objectMessages) {
    for (const objectMessage of objectMessages) {
      if (!objectMessage.operation) {
        this._client.Logger.logAction(
          this._client.logger,
          this._client.Logger.LOG_MAJOR,
          "RealtimeObject._applyObjectMessages()",
          `object operation message is received without 'operation' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`
        );
        continue;
      }
      const objectOperation = objectMessage.operation;
      switch (objectOperation.action) {
        case 0 /* MAP_CREATE */:
        case 3 /* COUNTER_CREATE */:
        case 1 /* MAP_SET */:
        case 2 /* MAP_REMOVE */:
        case 4 /* COUNTER_INC */:
        case 5 /* OBJECT_DELETE */:
          this._objectsPool.createZeroValueObjectIfNotExists(objectOperation.objectId);
          this._objectsPool.get(objectOperation.objectId).applyOperation(objectOperation, objectMessage);
          break;
        default:
          this._client.Logger.logAction(
            this._client.logger,
            this._client.Logger.LOG_MAJOR,
            "RealtimeObject._applyObjectMessages()",
            `received unsupported action in object operation message: ${objectOperation.action}, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`
          );
      }
    }
  }
  /** @spec RTO2 */
  _throwIfMissingChannelMode(expectedMode) {
    var _a;
    if (this._channel.modes != null && !this._channel.modes.includes(expectedMode)) {
      throw new this._client.ErrorInfo(`"${expectedMode}" channel mode must be set for this operation`, 40024, 400);
    }
    if (!this._client.Utils.allToLowerCase((_a = this._channel.channelOptions.modes) != null ? _a : []).includes(expectedMode)) {
      throw new this._client.ErrorInfo(`"${expectedMode}" channel mode must be set for this operation`, 40024, 400);
    }
  }
  _stateChange(state) {
    if (this._state === state) {
      return;
    }
    this._state = state;
    const event = StateToEventsMap[state];
    if (!event) {
      return;
    }
    this._eventEmitterInternal.emit(event);
    this._eventEmitterPublic.emit(event);
  }
  /**
   * Rebuilds all parent references in the objects pool.
   * This is necessary after sync operations where objects may reference other objects
   * that weren't available when the initial parent references were established.
   */
  _rebuildAllParentReferences() {
    for (const object of this._objectsPool.getAll()) {
      object.clearParentReferences();
    }
    for (const object of this._objectsPool.getAll()) {
      if (object instanceof LiveMap) {
        for (const [key, value] of object.entries()) {
          if (value instanceof LiveObject) {
            value.addParentReference(object, key);
          }
        }
      }
    }
  }
  _throwIfInChannelState(channelState) {
    if (channelState.includes(this._channel.state)) {
      throw this._client.ErrorInfo.fromValues(this._channel.invalidStateError());
    }
  }
  _throwIfEchoMessagesDisabled() {
    if (this._channel.client.options.echoMessages === false) {
      throw new this._channel.client.ErrorInfo(
        `"echoMessages" client option must be enabled for this operation`,
        4e4,
        400
      );
    }
  }
};
// Used by tests
RealtimeObject._DEFAULTS = DEFAULTS;

// src/plugins/liveobjects/index.ts
var LiveObjects = {
  LiveCounter: LiveCounterValueType,
  LiveMap: LiveMapValueType,
  ObjectMessage,
  RealtimeObject,
  WireObjectMessage
};
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
//# sourceMappingURL=liveobjects.umd.js.map
