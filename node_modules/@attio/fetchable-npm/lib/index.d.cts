type CompleteState = "complete";
type ErroredState = "error";
type PendingState = "pending";
interface Pending {
    state: PendingState;
}
interface Errored<TError> {
    state: ErroredState;
    error: TError;
}
interface Complete<TValue> {
    state: CompleteState;
    value: TValue;
}
type Result<TValue, TError> = Errored<TError> | Complete<TValue>;
type AsyncResult<TValue, TError> = Promise<Result<TValue, TError>>;
type Loadable<TValue> = Pending | Complete<TValue>;
type Fetchable<TValue, TError = unknown> = Pending | Errored<TError> | Complete<TValue>;
/**
 * Returns the error type of a fetchable.
 */
type ErrorOf<T> = T extends Errored<infer TError> ? TError : never;
/**
 * Returns the complete type of a fetchable.
 */
type ValueOf<T> = T extends Complete<infer TValue> ? TValue : never;

/**
 * If the fetchable is an error then its value is transformed and returned unwrapped.
 *
 * @example
 * bindError(complete(1), () => complete("oh no")) // Returns complete(1)
 * bindError(errored(1), (error) => complete(error + 1)) // Returns complete(2)
 * bindError(pending(), () => complete("oh no")) // Returns pending()
 */
declare function bindError<TFetchable extends Fetchable<any, any>, TBound>(fetchable: TFetchable, func: (error: ErrorOf<TFetchable>) => TBound): TFetchable extends Errored<any> ? Exclude<TFetchable, Errored<any>> | TBound : TFetchable;

/**
 * If the fetchable is complete then its value is transformed and returned unwrapped.
 *
 * @example
 * bind(complete(1), (value) => complete(value + 1)) // Returns complete(2)
 * bind(complete(1), (value) => errored(value + 1)) // Returns errored(2)
 * bind(errored(1), (value) => complete(value + 1)) // Returns errored(1)
 */
declare function bind<TFetchable extends Fetchable<any, any>, TBound>(fetchable: TFetchable, func: (value: ValueOf<TFetchable>) => TBound): TFetchable extends Complete<any> ? Exclude<TFetchable, Complete<any>> | TBound : TFetchable;

/**
 * Represents a partially combined array.
 *
 * TCombinedHeadValues are the values at the head of the array that we already know are complete.
 * TUncombined are the remaining uncombined values that may not be complete.
 * TCombinedTailValues are the values at the end of the array that we already know are complete.
 *
 * If TUncombined is a tuple then we eat it element by element from the head or tail until we
 * isolate the spread array in the middle of it (if there is one at all).
 */
type PartiallyCombinedArray$1<TCombinedHeadValues extends Array<any>, TUncombined extends Array<any>, TCombinedTailValues extends Array<any>> = TUncombined extends Array<never> ? Complete<[...TCombinedHeadValues, ...TCombinedTailValues]> : TUncombined extends [Promise<infer THead>, ...infer TRest] ? THead extends Complete<infer TValue> ? PartiallyCombinedArray$1<[...TCombinedHeadValues, TValue], TRest, TCombinedTailValues> : THead extends Errored<any> ? THead : never : TUncombined extends [...infer TRest, Promise<infer TTail>] ? TTail extends Complete<infer TValue> ? PartiallyCombinedArray$1<TCombinedHeadValues, TRest, [
    TValue,
    ...TCombinedTailValues
]> : TTail extends Errored<any> ? TTail : never : TUncombined extends Array<Promise<infer TElement>> ? TElement extends Complete<infer TValue> ? Complete<[...TCombinedHeadValues, ...Array<TValue>, ...TCombinedTailValues]> : TElement extends Errored<any> ? TElement : never : never;
type CombinedAsyncArray<TArray extends Array<any>> = PartiallyCombinedArray$1<[], TArray, []>;

/**
 * This type is used instead of `T extends never` because if T is `any` then `T extends never` is
 * both true and false.
 */
type IsNotNever<T> = [T] extends [never] ? false : true;

/**
 * If T is potentially a promise of a complete then this returns its value.
 */
type ExtractValue$2<T> = T extends Promise<infer TPromised> ? TPromised extends Complete<infer TValue> ? TValue : Promise<Complete<any>> extends T ? Extract<TPromised, Complete<any>> extends Complete<infer TValue> ? TValue : never : never : never;
/**
 * If T is potentially not a promise of a complete then this returns its non-complete promised type.
 */
type ExtractNonComplete$2<T> = T extends Promise<infer TPromised> ? Extract<TPromised, Errored<any> | Pending> : never;
/**
 * True if all values in the object are complete.
 */
type AllComplete$1<TRecord extends Record<any, any>> = {
    [TKey in keyof TRecord]: TRecord[TKey] extends Promise<Complete<any>> ? true : false;
}[keyof TRecord] extends true ? true : false;
/**
 * True if all values in the object are potentially complete.
 */
type AllPotentiallyComplete$1<TRecord extends Record<any, any>> = {
    [TKey in keyof TRecord]: IsNotNever<ExtractValue$2<TRecord[TKey]>>;
}[keyof TRecord] extends true ? true : false;
type CombinedAsyncRecord<TRecord extends Record<any, any>> = keyof TRecord extends never ? Complete<{}> : AllComplete$1<TRecord> extends true ? Complete<{
    [TKey in keyof TRecord]: ExtractValue$2<TRecord[TKey]>;
}> : AllPotentiallyComplete$1<TRecord> extends true ? Complete<{
    [TKey in keyof TRecord]: ExtractValue$2<TRecord[TKey]>;
}> | {
    [TKey in keyof TRecord]: ExtractNonComplete$2<TRecord[TKey]>;
}[keyof TRecord] : {
    [TKey in keyof TRecord]: ExtractNonComplete$2<TRecord[TKey]>;
}[keyof TRecord];

/**
 * A Promise.all for AsyncResults.
 *
 * If an array of AsyncResults is passed in then we will return:
 * - A complete array of all the values if all AsyncResults are complete.
 * - The first errored or pending AsyncResult otherwise.
 *
 * If an object with AsyncResults values is passed in then we will return:
 * - A complete object where all the AsyncResults are mapped to their value if all the AsyncResults
 *   are complete.
 * - The first errored or pending AsyncResult otherwise.
 *
 * @example
 * combineAsync([Promise.resolve(complete(1)), Promise.resolve(complete(2))]) // Resolves to complete([1, 2])
 * combineAsync([Promise.resolve(errored(1)), Promise.resolve(complete(2))]) // Resolves to errored(1)
 * combineAsync([]) // Resolves to complete([])
 *
 * combineAsync({a: Promise.resolve(complete(1)), b: Promise.resolve(complete(2))}) // Resolves to complete({a: 1, b: 2})
 * combineAsync({a: Promise.resolve(errored(1)), b: Promise.resolve(complete(2))}) // Resolves to errored(1)
 * combineAsync({}) // Resolves to complete({})
 */
declare function combineAsync<T extends Array<Promise<Result<any, any>>> | Record<any, Promise<Result<any, any>>>>(promises: T): Promise<T extends Array<Promise<Result<any, any>>> ? CombinedAsyncArray<T> : CombinedAsyncRecord<T>>;

/**
 * This type is used instead of `T extends never` because if T is `any` then `T extends never` is
 * both true and false.
 */
type IsNever<T> = [T] extends [never] ? true : false;

/**
 * If T is potentially complete then this returns its value.
 */
type ExtractValue$1<T> = T extends Complete<infer TValue> ? TValue : Complete<any> extends T ? Extract<T, Complete<any>> extends Complete<infer TValue> ? TValue : never : never;
/**
 * If T is potentially not complete then this returns its non-complete type.
 */
type ExtractNonComplete$1<T> = Extract<T, Errored<any> | Pending>;
/**
 * Represents a partially combined array.
 *
 * TCombinedHeadValues are the values at the head of the array that we already know are complete.
 * TUncombined are the remaining uncombined values that may not be complete.
 * TCombinedTailValues are the values at the end of the array that we already know are complete.
 *
 * If TUncombined is a tuple then we eat it element by element from the head or tail until we
 * isolate the spread array in the middle of it (if there is one at all).
 */
type PartiallyCombinedArray<TCombinedHeadValues extends Array<any>, TUncombined extends Array<any>, TCombinedTailValues extends Array<any>> = TUncombined extends Array<never> ? Complete<[...TCombinedHeadValues, ...TCombinedTailValues]> : TUncombined extends [infer THead, ...infer TRest] ? (IsNever<ExtractValue$1<THead>> extends true ? never : PartiallyCombinedArray<[
    ...TCombinedHeadValues,
    ExtractValue$1<THead>
], TRest, TCombinedTailValues>) | (IsNever<ExtractNonComplete$1<THead>> extends true ? never : ExtractNonComplete$1<THead>) : TUncombined extends [...infer TRest, infer TTail] ? (IsNever<ExtractValue$1<TTail>> extends true ? never : PartiallyCombinedArray<TCombinedHeadValues, TRest, [
    ExtractValue$1<TTail>,
    ...TCombinedTailValues
]>) | (IsNever<ExtractNonComplete$1<TTail>> extends true ? never : ExtractNonComplete$1<TTail>) : TUncombined extends Array<infer TElement> ? (IsNever<ExtractValue$1<TElement>> extends true ? never : Complete<[
    ...TCombinedHeadValues,
    ...Array<ExtractValue$1<TElement>>,
    ...TCombinedTailValues
]>) | (IsNever<ExtractNonComplete$1<TElement>> extends true ? never : ExtractNonComplete$1<TElement>) : never;
type CombinedArray<TArray extends Array<any>> = PartiallyCombinedArray<[], TArray, []>;

/**
 * If T is potentially complete then this returns its value.
 */
type ExtractValue<T> = T extends Complete<infer TValue> ? TValue : Complete<any> extends T ? Extract<T, Complete<any>> extends Complete<infer TValue> ? TValue : never : never;
/**
 * If T is potentially not complete then this returns its non-complete type.
 */
type ExtractNonComplete<T> = Extract<T, Errored<any> | Pending>;
/**
 * True if all values in the object are complete.
 */
type AllComplete<TRecord extends Record<any, any>> = {
    [TKey in keyof TRecord]: TRecord[TKey] extends Complete<any> ? true : false;
}[keyof TRecord] extends true ? true : false;
/**
 * True if all values in the object are potentially complete.
 */
type AllPotentiallyComplete<TRecord extends Record<any, any>> = {
    [TKey in keyof TRecord]: IsNotNever<ExtractValue<TRecord[TKey]>>;
}[keyof TRecord] extends true ? true : false;
type CombinedRecord<TRecord extends Record<any, any>> = keyof TRecord extends never ? Complete<{}> : AllComplete<TRecord> extends true ? Complete<{
    [TKey in keyof TRecord]: ExtractValue<TRecord[TKey]>;
}> : AllPotentiallyComplete<TRecord> extends true ? Complete<{
    [TKey in keyof TRecord]: ExtractValue<TRecord[TKey]>;
}> | {
    [TKey in keyof TRecord]: ExtractNonComplete<TRecord[TKey]>;
}[keyof TRecord] : {
    [TKey in keyof TRecord]: ExtractNonComplete<TRecord[TKey]>;
}[keyof TRecord];

/**
 * Combines multiple fetchables into a single fetchable.
 *
 * If an array of fetchables is passed in then we will return:
 * - A complete array of all the values if all fetchables are complete.
 * - The first errored or pending fetchable otherwise.
 *
 * If an object with fetchable values is passed in then we will return:
 * - A complete object where all the fetchables are mapped to their value if all the fetchables are
 *   complete.
 * - The first errored or pending fetchable otherwise.
 *
 * @example
 * combine([complete(1), errored(2), pending()]) // Returns errored(2)
 * combine([complete(1), pending()]) // Returns pending()
 * combine([complete(1), complete(2), complete(3)]) // Returns complete([1, 2, 3])
 * combine([]) // Returns complete([])
 *
 * combine({a: complete(1), b: errored(2), c: pending()]}) // Returns errored(2)
 * combine({a: complete(1), b: pending()]}) // Returns pending()
 * combine({a: complete(1), b: complete(2), c: complete(3)]}) // Returns complete({a: 1, b: 2, c: 3})
 * combine({}) // Returns complete({})
 */
declare function combine<TFetchables extends Array<Fetchable<any, any>> | Record<any, Fetchable<any, any>>>(fetchables: TFetchables): TFetchables extends Array<Fetchable<any, any>> ? CombinedArray<TFetchables> : CombinedRecord<TFetchables>;

/**
 * Creates a new complete fetchable with the given value.
 */
declare function complete<TValue>(value: TValue): Complete<TValue>;

declare function __enableErroredStackTraces(): void;
/**
 * Creates a new errored fetchable with the given error.
 */
declare function errored<TError>(error: TError): Errored<TError>;

/**
 * Turns a promise into a promise of a Result.
 * If the promise resolves then a successful Result is returned.
 * If the promise throws then an errored Result is returned.
 */
declare function fromPromise<TValue, TError = unknown>(promise: Promise<TValue>): AsyncResult<TValue, TError>;

/**
 * Runs the given function and returns a result.
 * If the function doesn't throw then a successful Result with its return value is returned.
 * If the function throws then an errored Result with the thrown error is returned.
 */
declare function fromThrowable<TValue, TError = unknown>(func: () => TValue): Result<TValue, TError>;

declare function isComplete<TFetchable extends Fetchable<any, any>>(fetchable: TFetchable): fetchable is Extract<TFetchable, Complete<any>>;

declare function isErrored<TFetchable extends Fetchable<any, any>>(fetchable: TFetchable): fetchable is Extract<TFetchable, Errored<any>>;

declare function isPending<TFetchable extends Fetchable<any, any>>(fetchable: TFetchable): fetchable is Extract<TFetchable, Pending>;

/**
 * If the fetchable is errored then its error is transformed and returned wrapped in another
 * errored fetchable.
 *
 * @example
 * mapError(complete(1), () => "oh no") // Returns complete(1)
 * mapError(errored(1), (error) => error + 1) // Returns errored(2)
 * mapError(pending(), () => complete("oh no")) // Returns pending()
 */
declare function mapError<TFetchable extends Fetchable<any, any>, TMapped>(fetchable: TFetchable, func: (error: ErrorOf<TFetchable>) => TMapped): TFetchable extends Errored<any> ? Exclude<TFetchable, Errored<any>> | Errored<TMapped> : TFetchable;

/**
 * If the fetchable is complete then its value is transformed and returned wrapped in another
 * complete fetchable.
 *
 * @example
 * map(complete(1), (value) => value + 1) // Returns complete(2)
 * map(errored(1), (value) => value + 1) // Returns errored(1)
 */
declare function map<TFetchable extends Fetchable<any, any>, TMapped>(fetchable: TFetchable, func: (value: ValueOf<TFetchable>) => TMapped): TFetchable extends Complete<any> ? Exclude<TFetchable, Complete<any>> | Complete<TMapped> : TFetchable;

/**
 * Creates a new pending fetchable.
 */
declare function pending(): Pending;

/**
 * If a complete fetchable is passed then its value is returned.
 * Otherwise the fallback value is returned.
 */
declare function valueOrElse<TFetchable extends Fetchable<any, any>, TFallback>(fetchable: TFetchable, fallback: TFallback): TFetchable extends Complete<infer TValue> ? TValue : TFallback;

export { type AsyncResult, type Complete, type CompleteState, type ErrorOf, type Errored, type ErroredState, type Fetchable, type Loadable, type Pending, type PendingState, type Result, type ValueOf, __enableErroredStackTraces, bind, bindError, combine, combineAsync, complete, errored, fromPromise, fromThrowable, isComplete, isErrored, isPending, map, mapError, pending, valueOrElse };
