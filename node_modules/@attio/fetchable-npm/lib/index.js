// src/bind-error.ts
function bindError(fetchable, func) {
  switch (fetchable.state) {
    case "complete":
    case "pending":
      return fetchable;
    case "error":
      return func(fetchable.error);
  }
}

// src/bind.ts
function bind(fetchable, func) {
  switch (fetchable.state) {
    case "error":
    case "pending":
      return fetchable;
    case "complete":
      return func(fetchable.value);
  }
}

// src/complete.ts
function complete(value) {
  return {
    state: "complete",
    value
  };
}

// src/is-errored.ts
function isErrored(fetchable) {
  return fetchable.state === "error";
}

// src/combine-async-array.ts
async function combineAsyncArray(promises) {
  return new Promise((resolve, reject) => {
    const values = [];
    if (promises.length === 0) {
      resolve(complete(values));
      return;
    }
    let completed = 0;
    const target = promises.length;
    let hasSettled = false;
    promises.forEach((promise, index) => {
      promise.then((result) => {
        if (isErrored(result)) {
          if (hasSettled) {
            return;
          }
          hasSettled = true;
          resolve(result);
          return;
        }
        completed++;
        values[index] = result.value;
        if (completed === target && !hasSettled) {
          hasSettled = true;
          resolve(complete(values));
        }
      }).catch((error) => {
        if (hasSettled) {
          return;
        }
        hasSettled = true;
        reject(error);
      });
    });
  });
}

// src/combine-async-record.ts
async function combineAsyncRecord(promises) {
  return new Promise((resolve, reject) => {
    const entries = Object.entries(promises);
    if (entries.length === 0) {
      resolve(complete(promises));
      return;
    }
    const values = {};
    let completed = 0;
    const target = entries.length;
    let hasSettled = false;
    for (const [key, promise] of entries) {
      values[key] = void 0;
      promise.then((result) => {
        if (isErrored(result)) {
          if (hasSettled) {
            return;
          }
          hasSettled = true;
          resolve(result);
          return;
        }
        completed++;
        values[key] = result.value;
        if (completed === target && !hasSettled) {
          hasSettled = true;
          resolve(complete(values));
        }
      }).catch((error) => {
        if (hasSettled) {
          return;
        }
        hasSettled = true;
        reject(error);
      });
    }
  });
}

// src/combine-async.ts
async function combineAsync(promises) {
  if (Array.isArray(promises)) {
    return combineAsyncArray(promises);
  }
  return combineAsyncRecord(promises);
}

// src/combine-array.ts
function combineArray(fetchables) {
  for (const fetchable of fetchables) {
    if (fetchable.state === "error" || fetchable.state === "pending") {
      return fetchable;
    }
  }
  const values = new Array(fetchables.length);
  for (let i = 0; i < fetchables.length; ++i) {
    values[i] = fetchables[i].value;
  }
  return complete(values);
}

// src/combine-record.ts
function combineRecord(fetchables) {
  const result = {};
  for (const key in fetchables) {
    const fetchable = fetchables[key];
    if (fetchable.state === "error" || fetchable.state === "pending") {
      return fetchable;
    }
    result[key] = fetchable.value;
  }
  return complete(result);
}

// src/combine.ts
function combine(fetchables) {
  if (Array.isArray(fetchables)) {
    return combineArray(fetchables);
  }
  return combineRecord(fetchables);
}

// src/errored.ts
var ENABLE_STACK_TRACES = false;
function __enableErroredStackTraces() {
  ENABLE_STACK_TRACES = true;
}
function errored(error) {
  if (!ENABLE_STACK_TRACES) {
    return {
      state: "error",
      error
    };
  }
  return {
    state: "error",
    error,
    stack: new Error().stack
  };
}

// src/from-promise.ts
async function fromPromise(promise) {
  return promise.then(complete).catch(errored);
}

// src/from-throwable.ts
function fromThrowable(func) {
  try {
    return complete(func());
  } catch (error) {
    return errored(error);
  }
}

// src/is-complete.ts
function isComplete(fetchable) {
  return fetchable.state === "complete";
}

// src/is-pending.ts
function isPending(fetchable) {
  return fetchable.state === "pending";
}

// src/map-error.ts
function mapError(fetchable, func) {
  switch (fetchable.state) {
    case "error":
      return errored(func(fetchable.error));
    case "pending":
    case "complete":
      return fetchable;
  }
}

// src/map.ts
function map(fetchable, func) {
  switch (fetchable.state) {
    case "error":
    case "pending":
      return fetchable;
    case "complete":
      return complete(func(fetchable.value));
  }
}

// src/pending.ts
var PENDING = { state: "pending" };
function pending() {
  return PENDING;
}

// src/value-or-else.ts
function valueOrElse(fetchable, fallback) {
  if (isComplete(fetchable)) {
    return fetchable.value;
  }
  return fallback;
}
export {
  __enableErroredStackTraces,
  bind,
  bindError,
  combine,
  combineAsync,
  complete,
  errored,
  fromPromise,
  fromThrowable,
  isComplete,
  isErrored,
  isPending,
  map,
  mapError,
  pending,
  valueOrElse
};
